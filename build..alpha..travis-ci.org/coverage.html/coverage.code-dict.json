{"/home/travis/build/npmtest/node-npmtest-nightwatch/test.js":"/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/lib.npmtest_nightwatch.js":"/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nightwatch = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nightwatch = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nightwatch && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nightwatch\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nightwatch.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_nightwatch.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nightwatch.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_nightwatch.__dirname +\n                    '/lib.npmtest_nightwatch.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/index.js":"/*!\n * Module dependencies.\n */\nvar path = require('path');\nvar util = require('util');\nvar events = require('events');\nvar HttpRequest = require('./http/request.js');\nvar CommandQueue = require('./core/queue.js');\nvar Assertion = require('./core/assertion.js');\nvar Logger = require('./util/logger.js');\nvar Api = require('./core/api.js');\nvar Utils = require('./util/utils.js');\n\nfunction Nightwatch(options) {\n  events.EventEmitter.call(this);\n\n  this.api = {\n    capabilities : {},\n    globals : options && options.persist_globals && options.globals || {},\n    sessionId : null\n  };\n\n  this.setMaxListeners(0);\n  this.sessionId = null;\n  this.context = null;\n  this.terminated = false;\n\n  this.setOptions(options)\n      .setCapabilities()\n      .loadKeyCodes();\n\n  this.errors = [];\n  this.results = {\n    passed:0,\n    failed:0,\n    errors:0,\n    skipped:0,\n    tests:[]\n  };\n\n  Assertion.init(this);\n  Api.init(this).load();\n\n  this.queue = CommandQueue;\n  this.queue.empty();\n  this.queue.reset();\n}\n\nNightwatch.DEFAULT_CAPABILITIES = {\n  browserName: 'firefox',\n  javascriptEnabled: true,\n  acceptSslCerts: true,\n  platform: 'ANY'\n};\n\nutil.inherits(Nightwatch, events.EventEmitter);\n\nNightwatch.prototype.assertion = Assertion.assert;\n\nNightwatch.prototype.setOptions = function(options) {\n  this.options = {};\n  this.api.options = {};\n  if (options && typeof options == 'object') {\n    for (var propName in options) {\n      this.options[propName] = options[propName];\n    }\n  }\n\n  this.api.launchUrl = this.options.launchUrl || this.options.launch_url || null;\n  // backwords compatibility\n  this.api.launch_url = this.api.launchUrl;\n\n  if (this.options.globals && typeof this.options.globals == 'object' && !this.options.persist_globals) {\n    for (var globalKey in this.options.globals) {\n      this.api.globals[globalKey] = this.options.globals[globalKey];\n    }\n  }\n\n  var screenshots = this.options.screenshots;\n  var screenshotsEnabled = screenshots && screenshots.enabled || false;\n\n  this.api.options.screenshots = screenshotsEnabled;\n  if (screenshotsEnabled) {\n    if (typeof screenshots.path == 'undefined') {\n      throw new Error('Please specify the screenshots.path in nightwatch.json.');\n    }\n    this.options.screenshots.on_error = this.options.screenshots.on_error ||\n      (typeof this.options.screenshots.on_error == 'undefined');\n    this.api.screenshotsPath = this.api.options.screenshotsPath = screenshots.path;\n  } else {\n    this.options.screenshots = {\n      enabled : false,\n      path : ''\n    };\n  }\n\n  this.setLocateStrategy();\n\n  if (this.options.silent) {\n    Logger.disable();\n  } else {\n    Logger.enable();\n  }\n\n  this.options.start_session = this.options.start_session || (typeof this.options.start_session == 'undefined');\n\n  this.api.options.skip_testcases_on_fail = this.options.skip_testcases_on_fail ||\n    (typeof this.options.skip_testcases_on_fail == 'undefined' && this.options.start_session); // off by default for unit tests\n\n  this.api.options.log_screenshot_data = this.options.log_screenshot_data ||\n    (typeof this.options.log_screenshot_data == 'undefined');\n  var seleniumPort     = this.options.seleniumPort || this.options.selenium_port;\n  var seleniumHost     = this.options.seleniumHost || this.options.selenium_host;\n  var useSSL           = this.options.useSsl || this.options.use_ssl;\n  var proxy            = this.options.proxy;\n  var timeoutOptions   = this.options.request_timeout_options || {};\n\n  if (seleniumPort) {\n    HttpRequest.setSeleniumPort(seleniumPort);\n  }\n  if (seleniumHost) {\n    HttpRequest.setSeleniumHost(seleniumHost);\n  }\n  if (useSSL) {\n    HttpRequest.useSSL(true);\n  }\n  if (proxy) {\n    HttpRequest.setProxy(proxy);\n  }\n  if (typeof timeoutOptions.timeout != 'undefined') {\n    HttpRequest.setTimeout(timeoutOptions.timeout);\n  }\n  if (typeof timeoutOptions.retry_attempts != 'undefined') {\n    HttpRequest.setRetryAttempts(timeoutOptions.retry_attempts);\n  }\n\n  if (typeof this.options.default_path_prefix == 'string') {\n    HttpRequest.setDefaultPathPrefix(this.options.default_path_prefix);\n  }\n\n  var username = this.options.username;\n  var key = this.options.accesKey || this.options.access_key || this.options.password;\n\n  if (username && key) {\n    this.api.options.username = username;\n    this.api.options.accessKey = key;\n\n    HttpRequest.setCredentials({\n      username : username,\n      key : key\n    });\n  }\n\n  this.endSessionOnFail(typeof this.options.end_session_on_fail == 'undefined' || this.options.end_session_on_fail);\n\n  return this;\n};\n\nNightwatch.prototype.endSessionOnFail = function(value) {\n  if (typeof value == 'undefined') {\n    return this.options.end_session_on_fail;\n  }\n\n  this.options.end_session_on_fail = value;\n  return this;\n};\n\nNightwatch.prototype.setCapabilities = function() {\n  this.desiredCapabilities = {};\n  for (var capability in Nightwatch.DEFAULT_CAPABILITIES) {\n    this.desiredCapabilities[capability] = Nightwatch.DEFAULT_CAPABILITIES[capability];\n  }\n\n  if (this.options.desiredCapabilities) {\n    for (var prop in this.options.desiredCapabilities) {\n      if (this.options.desiredCapabilities.hasOwnProperty(prop)) {\n        this.desiredCapabilities[prop] = this.options.desiredCapabilities[prop];\n      }\n    }\n  }\n  this.api.options.desiredCapabilities = this.desiredCapabilities;\n  return this;\n};\n\nNightwatch.prototype.setLocateStrategy = function () {\n  this.locateStrategy = this.options.use_xpath ? 'xpath' : 'css selector';\n  return this;\n};\n\nNightwatch.prototype.loadKeyCodes = function() {\n  this.api.Keys = require('./util/keys.json');\n  return this;\n};\n\nNightwatch.prototype.start = function() {\n  if (!this.sessionId && this.options.start_session) {\n    this\n      .once('selenium:session_create', this.start)\n      .startSession();\n    return this;\n  }\n\n  var self = this;\n\n  this.queue.reset();\n  this.queue.run(function(error) {\n    if (error) {\n      var stackTrace = '';\n      if (error.stack) {\n        stackTrace = error.stack.split('\\n').slice(1).join('\\n');\n      }\n\n      self.results.errors++;\n      self.errors.push(error.name + ': ' + error.message + '\\n' + stackTrace);\n      if (self.options.output) {\n        Utils.showStackTraceWithHeadline(error.name + ': ' + error.message, stackTrace, true);\n      }\n\n      if (self.options.start_session) {\n        self.terminate();\n      }\n      return;\n    }\n\n    self.finished();\n  });\n\n  return this;\n};\n\nNightwatch.prototype.terminate = function(deferred) {\n  // in case this was a synchronous command (e.g. assert.ok()) we need to wait for other possible\n  // commands which might have been added afterwards while client is terminated\n  if (deferred) {\n    this.queue.instance().once('queue:started', this.terminateSession.bind(this));\n  } else {\n    this.terminateSession();\n  }\n\n  this.terminated = true;\n  return this;\n};\n\nNightwatch.prototype.resetTerminated = function() {\n  this.terminated = false;\n  return this;\n};\n\nNightwatch.prototype.terminateSession = function() {\n  this.queue.reset();\n  this.queue.empty();\n\n  if (this.options.end_session_on_fail && this.options.start_session) {\n    this.api.end(function() {\n      this.finished();\n    }.bind(this));\n\n    // FIXME: sometimes the queue is incorrectly restarted when another .end() is\n    // scheduled from globalBeforeEach and results into a session command being sent with\n    // null as the sessionId\n    this.queue.run();\n  } else {\n    this.finished();\n  }\n  return this;\n};\n\nNightwatch.prototype.complete = function() {\n  return this.emit('complete');\n};\n\nNightwatch.prototype.finished = function() {\n  Logger.info('FINISHED');\n\n  this.emit('nightwatch:finished', this.results, this.errors);\n\n  return this;\n};\n\nNightwatch.prototype.getFailureMessage = function() {\n  var errors = '';\n\n  var failure_msg = [];\n  if (this.results.failed > 0) {\n    failure_msg.push(Logger.colors.red(this.results.failed) +\n      ' assertions failed');\n  }\n  if (this.results.errors > 0) {\n    failure_msg.push(Logger.colors.red(this.results.errors) + ' errors');\n  }\n  if (this.results.passed > 0) {\n    failure_msg.push(Logger.colors.green(this.results.passed) + ' passed');\n  }\n\n  if (this.results.skipped > 0) {\n    failure_msg.push(Logger.colors.blue(this.results.skipped) + ' skipped');\n  }\n\n  return failure_msg.join(', ').replace(/,([^,]*)$/g, function($0, $1) {\n    return  ' and' + $1;\n  });\n};\n\nNightwatch.prototype.printResult = function(elapsedTime) {\n  if (this.options.output && this.options.start_session) {\n    var ok = false;\n    if (this.results.failed === 0 && this.results.errors === 0) {\n      ok = true;\n    }\n\n    if (ok && this.results.passed > 0) {\n      console.log('\\n' + Logger.colors.green('OK.'),\n        Logger.colors.green(this.results.passed) + ' assertions passed. (' + Utils.formatElapsedTime(elapsedTime, true) + ')');\n    } else if (ok && this.results.passed === 0) {\n      if (this.options.start_session) {\n        console.log(Logger.colors.green('No assertions ran.'));\n      }\n    } else {\n      var failure_msg = this.getFailureMessage();\n      console.log('\\n' +  Logger.colors.red('FAILED: '), failure_msg, '(' + Utils.formatElapsedTime(elapsedTime, true) + ')');\n    }\n  }\n};\n\nNightwatch.prototype.clearResult = function() {\n  this.errors.length = 0;\n  this.results.passed = 0;\n  this.results.failed = 0;\n  this.results.errors = 0;\n  this.results.skipped = 0;\n  this.results.tests.length = 0;\n};\n\nNightwatch.prototype.handleException = function(err) {\n  var stack = err.stack.split('\\n');\n  var failMessage = stack.shift();\n  var firstLine = ' ' + String.fromCharCode(10006) + ' ' + failMessage;\n  if (typeof err.actual != 'undefined' && typeof err.expected != 'undefined') {\n    firstLine += '\\033[0;90m - expected ' + Logger.colors.green('\"' + err.expected + '\"') + ' \\033[0;90mbut got: ' + Logger.colors.red('\"' + err.actual + '\"');\n  }\n\n  if (this.options.output) {\n    Utils.showStackTraceWithHeadline(firstLine, stack);\n  }\n\n  if (err.name == 'AssertionError') {\n    this.results.failed++;\n    stack.unshift(failMessage + ' - expected \"' + err.expected + '\" but got: \"' + err.actual + '\"');\n    this.results.stackTrace = stack.join('\\n');\n  } else {\n    this.addError('\\n  ' + err.stack, firstLine);\n    this.terminate();\n  }\n};\n\nNightwatch.prototype.runProtocolAction = function(requestOptions, callback) {\n  var self = this;\n\n  var request = new HttpRequest(requestOptions)\n    .on('result', function(result) {\n      if (typeof callback != 'function') {\n        var error = new Error('Callback parameter is not a function - ' + typeof(callback) + ' passed: \"' + callback + '\"');\n        self.errors.push(error.stack);\n        self.results.errors++;\n      } else {\n        callback.call(self.api, result);\n      }\n\n      if (result.lastScreenshotFile && self.results.tests.length > 0) {\n        var lastTest = self.results.tests[self.results.tests.length-1];\n        lastTest.screenshots = lastTest.screenshots || [];\n        lastTest.screenshots.push(result.lastScreenshotFile);\n        delete result.lastScreenshotFile;\n      }\n\n      request.emit('complete');\n    })\n    .on('success', function(result, response) {\n      if (result.status && result.status !== 0) {\n        result = self.handleTestError(result);\n      }\n      request.emit('result', result, response);\n    })\n    .on('error', function(result, response, screenshotContent) {\n      result = self.handleTestError(result);\n\n      if (screenshotContent && self.options.screenshots.on_error) {\n        var fileNamePath = Utils.getScreenshotFileName(self.api.currentTest, true, self.options.screenshots.path);\n        self.saveScreenshotToFile(fileNamePath, screenshotContent);\n        result.lastScreenshotFile = fileNamePath;\n      }\n\n      request.emit('result', result, response);\n    });\n\n  return request;\n};\n\nNightwatch.prototype.addError = function(message, logMessage) {\n  var currentTest;\n  if (this.api.currentTest) {\n    currentTest = '[' + Utils.getTestSuiteName(this.api.currentTest.module) + ' / ' + this.api.currentTest.name + ']';\n  } else {\n    currentTest = 'tests';\n  }\n\n  this.errors.push('  Error while running '+ currentTest  + ':\\n' + message);\n  this.results.errors++;\n  if (this.options.output) {\n    Logger.warn('    ' + (logMessage || message));\n  }\n\n};\n\nNightwatch.prototype.saveScreenshotToFile = function(fileName, content, cb) {\n  var mkpath = require('mkpath');\n  var fs = require('fs');\n  var self = this;\n  cb = cb || function() {};\n\n  var dir = path.resolve(fileName, '..');\n  var fail = function(err) {\n    if (self.options.output) {\n      console.log(Logger.colors.yellow('Couldn\\'t save screenshot to '), fileName);\n    }\n\n    Logger.warn(err);\n    cb(err);\n  };\n\n  mkpath(dir, function(err) {\n    if (err) {\n      fail(err);\n    } else {\n      fs.writeFile(fileName, content, 'base64', function(err) {\n        if (err) {\n          fail(err);\n        } else {\n          cb(null, fileName);\n        }\n      });\n    }\n  });\n};\n\nNightwatch.prototype.handleTestError = function(result) {\n  var errorMessage = '';\n  if (result && result.status) {\n    var errorCodes = require('./api/errors.json');\n    errorMessage = errorCodes[result.status] && errorCodes[result.status].message || '';\n  }\n\n  return {\n    status: -1,\n    value : result && result.value || null,\n    errorStatus: result && result.status || '',\n    error : errorMessage\n  };\n};\n\nNightwatch.prototype.startSession = function () {\n  if (this.terminated) {\n    return this;\n  }\n  var self = this;\n  var options = {\n    path : '/session',\n    data : {\n      desiredCapabilities : this.desiredCapabilities\n    }\n  };\n\n  var request = new HttpRequest(options);\n  request.on('success', function(data, response, isRedirect) {\n    if (data && data.sessionId) {\n      self.sessionId = self.api.sessionId = data.sessionId;\n      if (data.value) {\n        self.api.capabilities = data.value;\n      }\n      Logger.info('Got sessionId from selenium', self.sessionId);\n      self.emit('selenium:session_create', self.sessionId, request, response);\n    } else if (isRedirect) {\n      self.followRedirect(request, response);\n    } else {\n      request.emit('error', data, null);\n    }\n  })\n  .on('error', function(data, err) {\n    if (self.options.output) {\n      console.error('\\n' + Logger.colors.light_red('Error retrieving a new session from the selenium server'));\n    }\n\n    if (typeof data == 'object' && Object.keys(data).length === 0) {\n      data = '';\n    }\n\n    if (!data && err) {\n      data = err;\n    }\n\n    self.emit('error', data);\n  })\n  .send();\n\n  return this;\n};\n\nNightwatch.prototype.followRedirect = function (request, response) {\n  if (!response.headers || !response.headers.location) {\n    this.emit('error', null, null);\n    return this;\n  }\n  var url = require('url');\n  var urlParts = url.parse(response.headers.location);\n  request.setOptions({\n    path   : urlParts.pathname,\n    host   : urlParts.hostname,\n    port   : urlParts.port,\n    method : 'GET'\n  }).send();\n\n  return this;\n};\n\nexports = module.exports = {};\n\nexports.client = function(options) {\n  return new Nightwatch(options);\n};\n\nexports.cli = function(runTests) {\n  var cli = require('./runner/cli/cli.js');\n  cli.setup();\n\n  var argv = cli.init();\n  if (argv.help) {\n    cli.showHelp();\n  } else if (argv.version) {\n    var packageConfig = require(__dirname + '/../package.json');\n    console.log(packageConfig.name + ' v' + packageConfig.version);\n  } else {\n    if (typeof runTests != 'function') {\n      throw new Error('Supplied argument needs to be a function!');\n    }\n    runTests(argv);\n  }\n};\n\nexports.runner = function(argv, done, settings) {\n  var runner = exports.CliRunner(argv);\n  return runner.setup(settings, done).runTests(done);\n};\n\nexports.initGrunt = function(grunt) {\n  grunt.registerMultiTask('nightwatch', 'run nightwatch.', function() {\n    var done = this.async();\n    var options = this.options();\n    var settings = this.data && this.data.settings;\n    var argv = this.data && this.data.argv;\n\n    exports.cli(function(a) {\n      Object.keys(argv).forEach(function(key) {\n        if (key === 'env' && a['parallel-mode'] === true) {\n          return;\n        }\n        a[key] = argv[key];\n      });\n\n      if (a.test) {\n        a.test = path.resolve(a.test);\n      }\n\n      if (options.cwd) {\n        process.chdir(options.cwd);\n      }\n\n      exports.runner(a, done, settings);\n    });\n  });\n};\n\nexports.CliRunner = function(argv) {\n  var CliRunner = require('./runner/cli/clirunner.js');\n  return new CliRunner(argv);\n};\n\nexports.initClient = function(opts) {\n  var Manager = require('./runner/clientmanager.js');\n  var instance = new Manager();\n  return instance.init(opts);\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/http/request.js":"var util   = require('util');\nvar events = require('events');\nvar http   = require('http');\nvar https  = require('https');\nvar Logger = require('./../util/logger');\nvar format = util.format;\n\nmodule.exports = (function() {\n  var Settings = {\n    selenium_host  : 'localhost',\n    selenium_port  : 4444,\n    default_path   : '/wd/hub',\n    credentials    : null,\n    use_ssl        : false,\n    proxy          : null,\n    timeout        : 60000,\n    retry_attempts : 0\n  };\n\n  var DO_NOT_LOG_ERRORS = [\n    'Unable to locate element',\n    '{\"errorMessage\":\"Unable to find element',\n    'no such element'\n  ];\n\n  function HttpRequest(options) {\n    events.EventEmitter.call(this);\n    this.setOptions(options);\n  }\n\n  util.inherits(HttpRequest, events.EventEmitter);\n\n  HttpRequest.prototype.setOptions = function(options) {\n    this.data           = options.data && jsonStringify(options.data) || '';\n    this.contentLength  = this.data.length;\n    this.reqOptions     = this.createOptions(options);\n    this.hostname       = formatHostname(this.reqOptions.host, this.reqOptions.port);\n    this.request        = null;\n    this.timeout        = Settings.timeout;\n    this.retryAttempts  = Settings.retry_attempts;\n\n    return this;\n  };\n\n  HttpRequest.prototype.setPathPrefix = function(options) {\n    this.defaultPathPrefix = options.path && options.path.indexOf(Settings.default_path) === -1 ?\n      Settings.default_path : '';\n    return this;\n  };\n\n  HttpRequest.prototype.createOptions = function(options) {\n    this.setPathPrefix(options);\n\n    var reqOptions = {\n      path    : this.defaultPathPrefix + (options.path || ''),\n      host    : options.host || Settings.selenium_host,\n      port    : options.selenium_port || Settings.selenium_port,\n      method  : options.method || 'POST',\n      headers : {}\n    };\n    var requestMethod = reqOptions.method.toUpperCase();\n    if (options.sessionId) {\n      reqOptions.path = reqOptions.path.replace(':sessionId', options.sessionId);\n    }\n\n    if (requestMethod === 'GET') {\n      reqOptions.headers['Accept'] = 'application/json';\n    }\n\n    if (this.contentLength > 0) {\n      reqOptions.headers['Content-Type'] = 'application/json; charset=utf-8';\n    }\n\n    if (needsContentLengthHeader(requestMethod)) {\n      reqOptions.headers['Content-Length'] = this.contentLength;\n    }\n\n    if (Settings.credentials &&\n      Settings.credentials.username && Settings.credentials.key\n      ) {\n      var authHeader = new Buffer(Settings.credentials.username + ':' + Settings.credentials.key).toString('base64');\n      reqOptions.headers['Authorization'] = 'Basic ' + authHeader;\n    }\n\n    if (Settings.proxy) {\n      var ProxyAgent = require('proxy-agent');\n      var proxyUri = Settings.proxy;\n      reqOptions.agent = new ProxyAgent(proxyUri);\n    }\n\n    return reqOptions;\n  };\n\n  HttpRequest.prototype.send = function() {\n    var self = this;\n    var startTime = new Date();\n    var isAborted = false;\n\n    this.request = (Settings.use_ssl ? https: http).request(this.reqOptions, function (response) {\n      response.setEncoding('utf8');\n      var redirected = false;\n      if (isRedirect(response.statusCode)) {\n        redirected = true;\n      }\n\n      var flushed = '';\n      response.on('data', function (chunk) {\n        if (self.reqOptions.method !== 'HEAD') {\n          flushed += chunk;\n        }\n      });\n\n      response.on('end', function () {\n        var elapsedTime = new Date() - startTime;\n        var screenshotContent;\n        var result, errorMessage = '';\n        if (flushed) {\n          result = parseResult(flushed);\n          if (result.value) {\n            if (result.value.screen) {\n              screenshotContent = result.value.screen;\n              delete result.value.screen;\n            }\n\n            if (result.value.stackTrace) {\n              // Selenium stack traces won't help us here and they will pollute the output\n              delete result.value.stackTrace;\n            }\n\n            if (needsFormattedErrorMessage(result)) {\n              errorMessage = formatErrorMessage(result.value);\n              delete result.value.localizedMessage;\n              delete result.value.message;\n            }\n          }\n        } else {\n          result = {};\n        }\n\n        if (errorMessage !== '') {\n          console.log(Logger.colors.yellow('There was an error while executing the Selenium command') +\n            (!Logger.isEnabled() ? ' - enabling the --verbose option might offer more details.' : '')\n          );\n          console.log(errorMessage);\n        }\n\n        self.emit('beforeResult', result);\n\n        var base64Data;\n        if (result.suppressBase64Data) {\n          base64Data = result.value;\n          result.value = '';\n        }\n\n        var logMethod = response.statusCode.toString().indexOf('5') === 0 ? 'error' : 'info';\n        Logger[logMethod](util.format('Response %s %s %s (%sms) ', response.statusCode, self.reqOptions.method, self.hostname + self.reqOptions.path, elapsedTime), result);\n\n        if (result.suppressBase64Data) {\n          result.value = base64Data;\n        }\n\n        if (response.statusCode.toString().indexOf('2') === 0 || redirected) {\n          if (isAborted) {\n            return;\n          }\n          self.emit('success', result, response, redirected);\n        } else {\n          self.emit('error', result, response, screenshotContent);\n        }\n      });\n    });\n\n    this.request.on('error', function(response) {\n      self.emit('error', {}, response);\n    });\n\n    this.request.setTimeout(this.timeout, function() {\n      if (self.retryAttempts) {\n        self.request.socket.unref();\n        isAborted = true; // prevent emitting of the success event multiple times.\n        self.retryAttempts = self.retryAttempts - 1;\n        self.send();\n      } else {\n        self.request.abort();\n      }\n    });\n\n    Logger.info('Request: ' + this.reqOptions.method + ' ' + this.hostname + this.reqOptions.path,\n      '\\n - data: ', this.data, '\\n - headers: ', JSON.stringify(this.reqOptions.headers));\n\n    this.request.write(this.data);\n    this.request.end();\n\n    return this;\n  };\n\n  /**\n   *\n   * @param s\n   * @param emit_unicode\n   * @returns {string}\n   */\n  HttpRequest.JSON_stringify = function(s, emit_unicode) {\n    var json = JSON.stringify(s);\n    if (json) {\n      return emit_unicode ? json : json.replace(jsonRegex, jsonRegexReplace);\n    }\n  };\n\n  HttpRequest.setSeleniumPort = function(port) {\n    Settings.selenium_port = port;\n  };\n  HttpRequest.useSSL = function(value) {\n    Settings.use_ssl = value;\n  };\n  HttpRequest.setSeleniumHost = function(host) {\n    Settings.selenium_host = host;\n  };\n  HttpRequest.setCredentials = function(credentials) {\n    Settings.credentials = credentials;\n  };\n  HttpRequest.setProxy = function(proxy) {\n    Settings.proxy = proxy;\n  };\n  HttpRequest.setDefaultPathPrefix = function(path) {\n    Settings.default_path = path;\n  };\n  HttpRequest.setTimeout = function(timeout) {\n    Settings.timeout = timeout;\n  };\n  HttpRequest.setRetryAttempts = function(retryAttempts) {\n    Settings.retry_attempts = retryAttempts;\n  };\n\n  ///////////////////////////////////////////////////////////\n  // Helpers\n  ///////////////////////////////////////////////////////////\n  var jsonRegex = new RegExp('[\\\\u007f-\\\\uffff]', 'g');\n  var jsonRegexReplace = function(c) {\n    return '\\\\u'+('0000'+c.charCodeAt(0).toString(16)).slice(-4);\n  };\n\n  /**\n   * Built in JSON.stringify() will return unicode characters that require UTF-8 encoding on the wire.\n   * This function will replace unicode characters with their escaped (ASCII-safe) equivalents to support\n   * the keys sending command.\n   *\n   * @param {object} s\n   * @returns {string}\n   */\n  function jsonStringify(s) {\n    var json = JSON.stringify(s);\n    if (json) {\n      return json.replace(jsonRegex, jsonRegexReplace);\n    }\n\n    return json;\n  }\n\n  function formatHostname(hostname, port) {\n    var isLocalHost = ['127.0.0.1', 'localhost'].indexOf(hostname) > -1;\n    var protocol = Settings.use_ssl ? 'https://' : 'http://';\n    var isPortDefault = [80, 443].indexOf(port) > -1;\n    if (isLocalHost) {\n      return '';\n    }\n    return protocol + hostname + (!isPortDefault && (':' + port) || '');\n  }\n\n  function isRedirect(statusCode) {\n    return [302, 303, 304].indexOf(statusCode) > -1;\n  }\n\n  function needsContentLengthHeader(requestMethod) {\n    return ['POST', 'DELETE'].indexOf(requestMethod) > -1;\n  }\n\n  function needsFormattedErrorMessage(result) {\n    return !!(result.localizedMessage || result.message);\n  }\n\n  function hasLocalizedMessage(result) {\n    return !!result.localizedMessage;\n  }\n\n  function formatErrorMessage(info) {\n    var msg = hasLocalizedMessage(info) ? info.localizedMessage : info.message;\n    if (shouldLogErrorMessage(msg)) {\n      msg = msg.replace(/\\n/g, '\\n\\t');\n    }\n    return msg;\n  }\n\n  function parseResult(data) {\n    var result;\n    data = stripUnknownChars(data);\n\n    try {\n      result = JSON.parse(data);\n    } catch (err) {\n      console.log(Logger.colors.red('Error processing the server response:'), '\\n', data);\n      result = {value: -1, error: err.message};\n    }\n    return result;\n  }\n\n  function shouldLogErrorMessage(msg) {\n    return !DO_NOT_LOG_ERRORS.some(function(item) {\n      return msg.indexOf(item) === 0;\n    });\n  }\n\n  function stripUnknownChars(str) {\n    var x = [], i = 0, length = str.length;\n\n    for (i; i < length; i++) {\n      if (str.charCodeAt(i)) {\n        x.push(str.charAt(i));\n      }\n    }\n    return x.join('');\n  }\n\n  return HttpRequest;\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/util/logger.js":"var util = require('util');\nvar Settings = {\n  log_timestamp : false,\n  colors : true,\n  enabled : true\n};\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n  'Oct', 'Nov', 'Dec'];\n\nfunction getDate() {\n  var now = new Date();\n  return [now.toLocaleDateString(), now.toLocaleTimeString()].join(' ');\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n    pad(d.getMinutes()),\n    pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nfunction getPrefix(tag, severity) {\n  var levels = ['EMERG', 'ALERT', 'CRITICAL', 'ERROR', 'WARNING', 'NOTICE', 'INFO', 'DEBUG'];\n  return tag + ' ' + levels[severity] +' - ';\n}\n\nfunction ConsoleColor() {\n  var self = this;\n  var mappings = {\n    blue  : '0;34',\n    light_blue  : '1;34'\n  };\n  this.background = new Background();\n\n  this.foreground_colors = {};\n  this.foreground_colors['black'] = '0;30';\n  this.foreground_colors['dark_gray'] = '1;30';\n  this.foreground_colors['blue'] = '0;34';\n  this.foreground_colors['light_blue'] = '1;34';\n  this.foreground_colors['green'] = '0;32';\n  this.foreground_colors['light_green'] = '1;32';\n  this.foreground_colors['cyan'] = '0;36';\n  this.foreground_colors['light_cyan'] = '1;36';\n  this.foreground_colors['red'] = '0;31';\n  this.foreground_colors['light_red'] = '1;31';\n  this.foreground_colors['purple'] = '0;35';\n  this.foreground_colors['light_purple'] = '1;35';\n  this.foreground_colors['brown'] = '0;33';\n  this.foreground_colors['yellow'] = '1;33';\n  this.foreground_colors['light_gray'] = '0;37';\n  this.foreground_colors['white'] = '1;37';\n  this.foreground_colors['stack_trace'] = '0;90';\n\n  this.background_colors = {};\n  this.background_colors['black'] = '40';\n  this.background_colors['red'] = '41';\n  this.background_colors['green'] = '42';\n  this.background_colors['yellow'] = '43';\n  this.background_colors['blue'] = '44';\n  this.background_colors['magenta'] = '45';\n  this.background_colors['cyan'] = '46';\n  this.background_colors['light_gray'] = '47';\n\n  Object.keys(this.foreground_colors).forEach(function(k) {\n    ConsoleColor.prototype[k.toLowerCase()] = function Foreground(text, background) {\n      var string = '\\033[' + self.foreground_colors[k.toLowerCase()] + 'm';\n      if (background !== undefined) {\n        string += background();\n      }\n\n      string += text + '\\033[0m';\n      return string;\n    };\n  });\n\n  Object.keys(this.background_colors).forEach(function(k) {\n    Background.prototype[k.toLowerCase()] = function Background(text) {\n      return '\\033[' + self.background_colors[k.toLowerCase()] + 'm';\n    };\n  });\n  return this;\n}\nfunction Background() { return this; }\n\nvar colors = new ConsoleColor();\nfunction logObject(obj) {\n  console.log(util.inspect(obj, {\n    showHidden : false,\n    depth : 3,\n    colors : Settings.colors\n  }));\n}\n\nfunction logTimestamp() {\n  if (Settings.log_timestamp) {\n    return colors.white(timestamp()) + ' ';\n  }\n  return '';\n}\n\nfunction logMessage(type, message, args) {\n  if (!message || !Settings.enabled) {\n    return;\n  }\n\n  var messageStr = '';\n  var timestamp = logTimestamp();\n  switch (type) {\n  case 'ERROR':\n    messageStr = colors.yellow(type, colors.background.dark_gray) +' '+\n                timestamp + colors.light_green(message);\n    break;\n  case 'INFO':\n    messageStr = colors.light_purple(type, colors.background.black) +' '+\n                timestamp + colors.light_cyan(message);\n    break;\n  case 'LOG':\n    messageStr = colors.white(type+' ', colors.background.black) +' '+\n                timestamp + colors.white(message);\n    break;\n  case 'WARN':\n    messageStr = colors.light_green(type, colors.background.black) +' '+\n                timestamp + colors.light_green(message);\n    break;\n  }\n\n  process.stdout.write(messageStr);\n\n  if (args.length > 0) {\n    var inlineArgs = [];\n    args.forEach(function(item) {\n      if (Object.prototype.toString.call(item) === '[object Object]' && Object.keys(item).length > 0) {\n        if (inlineArgs.length) {\n          console.log.apply(console, inlineArgs);\n          inlineArgs = [];\n        }\n        logObject(item);\n      } else {\n        inlineArgs.push(item);\n      }\n    });\n    if (inlineArgs.length) {\n      process.stdout.write(' ');\n      console.log.apply(console, inlineArgs);\n      inlineArgs = [];\n    }\n  } else {\n    process.stdout.write('\\n');\n  }\n}\n\nexports.info = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('INFO', message, args);\n};\n\nexports.log = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('LOG', message, args);\n};\n\nexports.warn = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('WARN', message, args);\n};\n\nexports.error = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('ERROR', message, args);\n};\n\nexports.disableColors = function () {\n  Settings.colors = false;\n  Object.keys(ConsoleColor.prototype).forEach(function (color) {\n    ConsoleColor.prototype[color] = function (text) {\n      return text;\n    };\n  });\n};\n\nexports.disable = function() {\n  Settings.enabled = false;\n};\nexports.enable = function() {\n  Settings.enabled = true;\n};\nexports.isEnabled = function() {\n  return Settings.enabled;\n};\nexports.colors = colors;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/queue.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('./../util/logger.js');\n\nfunction AsyncTree() {\n  events.EventEmitter.call(this);\n  this.rootNode = {\n    name : '__root__',\n    children : [],\n    started : false,\n    done : false,\n    parent : this.rootNode\n  };\n  this.currentNode = this.rootNode;\n}\nutil.inherits(AsyncTree, events.EventEmitter);\n\nAsyncTree.prototype.append = function(nodeName, command, context, args, stackTrace) {\n  var node = {\n    startTime  : null,\n    name       : nodeName,\n    command    : command,\n    context    : context,\n    args       : args || [],\n    started    : false,\n    done       : false,\n    children   : [],\n    parent     : this.currentNode,\n    stackTrace : stackTrace\n  };\n\n  this.currentNode.children.push(node);\n\n  if (this.currentNode.started && !this.currentNode.done) {\n    this.scheduleTraverse(node);\n  }\n};\n\nAsyncTree.prototype.print = function(node, level) {\n  process.stdout.write(node.name + '\\n');\n  level = level || 1;\n  for (var i = 0; i < node.children.length; i++) {\n    var childNode = node.children[i];\n    for (var k = 0; k < level; k++) {\n      process.stdout.write(' |- ');\n    }\n    if (childNode.children.length) {\n      var levelUp = level + 1;\n      arguments.callee(childNode, levelUp);\n    } else {\n      process.stdout.write(childNode.name + '\\n');\n    }\n  }\n  process.stdout.write('');\n};\n\nAsyncTree.prototype.scheduleTraverse = function(node) {\n  if (this.scheduled) {\n    return this;\n  }\n  this.scheduled = true;\n  var self = this;\n  process.nextTick(function() {\n    self.scheduled = false;\n    self.traverse();\n  });\n};\n\nAsyncTree.prototype.traverse = function() {\n  this.emit('queue:started');\n  this.currentNode.started = true;\n\n  this.walkDown(this.currentNode);\n  return this;\n};\n\nAsyncTree.prototype.walkDown = function walkDown(context) {\n  var node = this.getNextChild(context);\n  if (node) {\n    this.runChildNode(node);\n  } else {\n    if (context.instance && !context.done) {\n      return;\n    }\n\n    this.currentNode.done = true;\n    if (this.currentNode.name === '__root__') {\n      this.done();\n    } else {\n      this.walkUp(context);\n    }\n  }\n};\n\nAsyncTree.prototype.walkUp = function(context) {\n  this.currentNode = context.parent;\n  this.walkDown(context.parent);\n};\n\nAsyncTree.prototype.getNextChild = function(context) {\n  for (var i = 0; i < context.children.length; i++) {\n    if (!context.children[i].started) {\n      var child = context.children[i];\n      context.children.splice(i, 1);\n      return child;\n    }\n  }\n  return false;\n};\n\nAsyncTree.prototype.runChildNode = function runChildNode(node) {\n  var self = this;\n\n  this.runCommand(node, function onCommandComplete() {\n    var timems = new Date().getTime() - node.startTime;\n    // checking if new children have been added while running this command which haven't finished yet\n    var childrenInProgress = false;\n    var currentChildNode = null;\n    for (var i = 0; i < node.children.length; i++) {\n      currentChildNode = node.children[i];\n      if (!currentChildNode.done) {\n        childrenInProgress = true;\n        break;\n      }\n    }\n\n    Logger.log('   ' + Logger.colors.green('→') +\n      ' Completed command ' + Logger.colors.light_green(node.name), '(' + timems,  'ms)');\n    node.done = true;\n    if (!childrenInProgress) {\n      self.traverse();\n    }\n  });\n};\n\nAsyncTree.prototype.runCommand = function(node, callback) {\n  this.currentNode = node;\n  node.started = true;\n\n  try {\n    var commandFn = node.command;\n    if (typeof node.command !== 'function') {\n      // backwards compatibility\n      commandFn = node.command.command;\n    }\n\n    if (typeof commandFn !== 'function') {\n      throw new Error('Command must be a function');\n    }\n\n    node.startTime = new Date().getTime();\n    commandFn.prototype.constructor.stackTrace = node.stackTrace;\n\n    var instance = commandFn.apply(node.context, node.args);\n    if (instance instanceof events.EventEmitter) {\n      node.instance = instance;\n      instance.once('complete', callback);\n    }\n    return node.context;\n  } catch (err) {\n    err.stack = node.stackTrace;\n    err.name = 'Error while running ' + node.name + ' command';\n    this.emit('error', err);\n    return this;\n  }\n};\n\nAsyncTree.prototype.done = function() {\n  this.rootNode.started = false;\n  this.emit('queue:finished');\n  return this;\n};\n\nAsyncTree.prototype.empty = function() {\n  this.rootNode.children = [];\n  return this;\n};\n\nAsyncTree.prototype.reset = function() {\n  this.rootNode.started = false;\n  this.rootNode.done = false;\n  this.removeAllListeners();\n  this.currentNode = this.rootNode;\n  return this;\n};\n\nmodule.exports = new (function() {\n  var queue = new AsyncTree();\n\n  this.reset = function() {\n    queue.reset();\n  };\n\n  this.empty = function() {\n    queue.empty();\n  };\n\n  this.add = function() {\n    queue.append.apply(queue, arguments);\n  };\n\n  this.run = function queueRunner(callback) {\n    if (queue.rootNode.started) {\n      return queue;\n    }\n\n    if (callback) {\n      queue.once('queue:finished', function() {\n        callback(null);\n      })\n      .on('error', function(err) {\n        callback(err);\n      });\n    }\n\n    return queue.traverse();\n  };\n\n  this.done = function() {\n    queue.done();\n  };\n\n  this.instance = function instance() {\n    return queue;\n  };\n\n  this.list = function list() {\n    return queue.rootNode.children.map(function(item) {\n      return item.name;\n    });\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/assertion.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('./../util/logger.js');\nvar Utils = require('./../util/utils.js');\n\nmodule.exports = new (function() {\n  var doneSymbol = Utils.symbols.ok;\n  var failSymbol = Utils.symbols.fail;\n  var initialized = false;\n  var client;\n\n  /**\n   * Abstract assertion class that will subclass all defined assertions\n   *\n   * All assertions must implement the following api:\n   *\n   * - @type {boolean|function}\n   *   expected\n   * - @type {string}\n   *   message\n   * - @type {function}\n   *   pass\n   * - @type {function}\n   *   value\n   * - @type {function}\n   *   command\n   * - @type {function} - Optional\n   *   failure\n   *\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @constructor\n   */\n  function BaseAssertion(abortOnFailure, client) {\n    events.EventEmitter.call(this);\n    this.abortOnFailure = abortOnFailure;\n    this.client = client;\n    this.api = client.api;\n    this.startTime = new Date().getTime();\n    this.globals = this.api.globals || {};\n    this.timeout = this.globals.retryAssertionTimeout || 0; //ms\n    this.rescheduleInterval = this.globals.waitForConditionPollInterval || 500; //ms\n    this.shouldRetry = this.timeout > 0;\n  }\n\n  util.inherits(BaseAssertion, events.EventEmitter);\n\n  BaseAssertion.prototype.complete = function() {\n    var self = this, args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('complete');\n\n    setImmediate(function() {\n      self.emit.apply(self, args);\n    });\n  };\n\n  /**\n   * Performs the command method\n   * @returns {*}\n   * @private\n   */\n  BaseAssertion.prototype._executeCommand = function() {\n    var self = this;\n    var methods = [\n      'expected',\n      'message',\n      ['pass'],\n      ['value'],\n      ['command']\n    ];\n    methods.forEach(function(method) {\n      if (Array.isArray(method)) {\n        var name = method[0];\n        if (typeof self[name] !== 'function') {\n          throw new Error('Assertion must implement method ' + name);\n        }\n      } else if (typeof self[method] == 'undefined') {\n        throw new Error('Assertion must implement method/property ' + method);\n      }\n    });\n\n    return this._scheduleAssertion();\n  };\n\n  BaseAssertion.prototype._scheduleAssertion = function() {\n    var self = this;\n    return this.command(function(result) {\n      var passed, value;\n\n      if (typeof self.failure == 'function' && self.failure(result)) {\n        passed = false;\n        value = null;\n      } else {\n        value = self.value(result);\n        passed = self.pass(value);\n      }\n\n      var timeSpent = new Date().getTime() - self.startTime;\n      if (!passed && timeSpent < self.timeout) {\n        return self._reschedule();\n      }\n\n      var expected = typeof self.expected == 'function' ? self.expected() : self.expected;\n      var message = self._getFullMessage(passed, timeSpent);\n\n      self.client.assertion(passed, value, expected, message, self.abortOnFailure, self._stackTrace);\n      self.emit('complete');\n    });\n  };\n\n  BaseAssertion.prototype._getFullMessage = function(passed, timeSpent) {\n    if ( !this.shouldRetry) {\n      return this.message;\n    }\n    var timeLogged = passed ? timeSpent : this.timeout;\n    return this.message + ' after ' + timeLogged + ' milliseconds.';\n  };\n\n  BaseAssertion.prototype._reschedule = function() {\n    setTimeout(function(){}, this.rescheduleInterval);\n    return this._scheduleAssertion();\n  };\n\n  /**\n   *\n   * @param {string} stackTrace\n   * @param {string|null} message\n   */\n  function buildStackTrace(stackTrace, message) {\n    var stackParts = stackTrace.split('\\n');\n    stackParts.shift();\n\n    if (message) {\n      stackParts.unshift(message);\n    }\n\n    return Utils.stackTraceFilter(stackParts);\n  }\n\n  /**\n   * Assertion factory that creates the assertion instances with the supplied assertion definition\n   *  and options\n   *\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @constructor\n   */\n  function AssertionInstance(assertionFn, abortOnFailure, client) {\n    this.abortOnFailure = abortOnFailure;\n    this.client = client;\n    this.assertionFn = assertionFn;\n  }\n\n  /**\n   * This will call the supplied constructor of the assertion, after calling the Base constructor\n   *  first with other arguments and then inherits the rest of the methods from BaseAssertion\n   *\n   * @param {function} constructor\n   * @param {Array} args\n   * @returns {*}\n   * @private\n   */\n  AssertionInstance.prototype._constructFromSuper = function(constructor, args) {\n    var self = this;\n    function F() {\n      BaseAssertion.apply(this, [self.abortOnFailure, self.client]);\n      return constructor.apply(this, args);\n    }\n\n    util.inherits(constructor, BaseAssertion);\n    F.prototype = constructor.prototype;\n    return new F();\n  };\n\n  AssertionInstance.prototype._commandFn = function commandFn() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var instance = this._constructFromSuper(this.assertionFn, args);\n    instance._stackTrace = commandFn.stackTrace;\n    return instance._executeCommand();\n  };\n\n  /**\n   * @public\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @returns {AssertionInstance}\n   */\n  this.factory = function(assertionFn, abortOnFailure, client) {\n    return new AssertionInstance(assertionFn, abortOnFailure, client);\n  };\n\n\n  /**\n   * Performs an assertion\n   *\n   * @param {Boolean} passed\n   * @param {Object} receivedValue\n   * @param {Object} expectedValue\n   * @param {String} message\n   * @param {Boolean} abortOnFailure\n   * @param {String} originalStackTrace\n   */\n  this.assert = function assert(passed, receivedValue, expectedValue, message, abortOnFailure, originalStackTrace) {\n    if (!initialized) {\n      throw new Error('init must be called first.');\n    }\n\n    var failure = '';\n    var stacktrace = '';\n    var fullMsg = '';\n\n    if (passed) {\n      if (client.options.output && client.options.detailed_output) {\n        console.log(' ' + Logger.colors.green(doneSymbol) + ' ' + message);\n      }\n      client.results.passed++;\n    } else {\n      failure = 'Expected \"' + expectedValue + '\" but got: \"' + receivedValue + '\"';\n      var err = new Error();\n\n      err.name = message;\n      err.message = message + ' - ' + failure;\n\n      if (!originalStackTrace) {\n        Error.captureStackTrace(err, arguments.callee);\n        originalStackTrace = err.stack;\n      }\n\n      err.stack = buildStackTrace(originalStackTrace, client.options.start_session ? null : 'AssertionError: ' + message);\n\n      fullMsg = message;\n      if (client.options.output && client.options.detailed_output) {\n        var logged = ' ' + Logger.colors.red(failSymbol);\n        if (typeof expectedValue != 'undefined' && typeof receivedValue != 'undefined') {\n          fullMsg += ' ' + Logger.colors.white(' - expected ' + Logger.colors.green('\"' +\n                expectedValue + '\"')) + ' but got: ' + Logger.colors.red('\"' + receivedValue + '\"');\n        }\n        logged += ' ' + fullMsg;\n        console.log(logged);\n      }\n\n      stacktrace = err.stack;\n      if (client.options.output && client.options.detailed_output) {\n        var parts = stacktrace.split('\\n');\n        console.log(Logger.colors.stack_trace(parts.join('\\n')) + '\\n');\n      }\n\n      client.results.lastError = err;\n      client.results.failed++;\n    }\n\n    client.results.tests.push({\n      message : message,\n      stackTrace : stacktrace,\n      fullMsg : fullMsg,\n      failure : failure !== '' ? failure : false\n    });\n\n    if (!passed && abortOnFailure) {\n      client.terminate(true);\n    }\n  };\n\n  /**\n   * Initializer\n   *\n   * @param {Object} c Nightwatch client instance\n   */\n  this.init = function(c) {\n    client = c;\n    initialized = true;\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/util/utils.js":"var path = require('path');\nvar fs = require('fs');\nvar Util = module.exports = {};\nvar Logger = require('./logger.js');\n\nvar formatRegExp = /%[sdj%]/g;\nvar testSuiteNameRegxp = /(_|-|\\.)*([A-Z]*)/g;\nvar nameSeparatorRegxp = /(\\s|\\/)/;\n\nUtil.formatElapsedTime = function(timeMs, includeMs) {\n  var seconds = timeMs/1000;\n  return (seconds < 1 && timeMs + 'ms') ||\n    (seconds > 1 && seconds < 60 && (seconds + 's')) ||\n    (Math.floor(seconds/60) + 'm' + ' ' + Math.floor(seconds%60) + 's' + (includeMs ? (' / ' + timeMs + 'ms') : ''));\n};\n\n/**\n * Wrap a synchronous function, turning it into an async fn with a callback as\n * the last argument if necessary. `asyncArgCount` is the expected argument\n * count if `fn` is already asynchronous.\n *\n * @param {number} asyncArgCount\n * @param {function} fn\n * @param {object} [context]\n */\nUtil.makeFnAsync = function (asyncArgCount, fn, context) {\n  if (fn.length === asyncArgCount) {\n    return fn;\n  }\n\n  return function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var done = args.pop();\n    context = context || null;\n    fn.apply(context, args);\n    done();\n  };\n};\n\n/**\n * Waits a number of ms for a `done` callback to be invoked\n *\n * @param {function} done\n * @param {string} fnName\n * @param {number} timeMs\n * @param {function} [onCatch]\n * @param {function} [onTimerStarted]\n * @return {Function}\n */\nUtil.setCallbackTimeout = function(done, fnName, timeMs, onCatch, onTimerStarted) {\n  var timeout = setTimeout(function() {\n    if (onCatch) {\n      var err = new Error('done() callback timeout of '+ timeMs +' ms was reached while executing \"' + fnName + '\".' +\n        ' Make sure to call the done() callback when the operation finishes.');\n      onCatch(err, fnName, timeout);\n    }\n\n  }, timeMs);\n\n  if (onTimerStarted) {\n    onTimerStarted(timeout);\n  }\n\n  return function(ex) {\n    clearTimeout(timeout);\n    done(ex, true);\n  };\n};\n\nUtil.checkFunction = function(name, parent) {\n  return parent && (typeof parent[name] == 'function') && parent[name] || false;\n};\n\nUtil.getTestSuiteName = function(moduleName) {\n  var words;\n\n  moduleName = moduleName.replace(testSuiteNameRegxp, function(match, $0, $1, offset, string) {\n    if (!match) {\n      return '';\n    }\n    return (offset > 0 && (string.charAt(offset-1) !== ' ') ? ' ':'') + $1;\n  });\n\n  words = moduleName.split(nameSeparatorRegxp).map(function(word, index, matches) {\n    if (word == '/') {\n      return ' / ';\n    }\n    return word.charAt(0).toUpperCase() + word.substr(1);\n  });\n\n  return words.join('');\n};\n\n/**\n * A smaller version of util.format that doesn't support json and\n * if a placeholder is missing, it is omitted instead of appended\n *\n * @param f\n * @returns {string}\n */\nUtil.format = function format(f) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') {\n      return '%';\n    }\n    if (i >= len) {\n      return x;\n    }\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n      case '%d':\n        return Number(args[i++]);\n      default:\n        return x;\n    }\n  });\n};\n\nUtil.getScreenshotFileName = function(currentTest, is_error, screenshots_path) {\n  var prefix = currentTest.module + '/' + currentTest.name;\n  prefix = prefix.replace(/\\s/g, '-').replace(/\"|'/g, '');\n  prefix += is_error ? '_ERROR' : '_FAILED';\n\n  var d = new Date();\n  var dateParts = d.toString().replace(/:/g,'').split(' ');\n  dateParts.shift();\n  dateParts.pop();\n  var dateStamp = dateParts.join('-');\n\n  return path.resolve(path.join(screenshots_path, prefix + '_' + dateStamp + '.png'));\n};\n\nUtil.isObject = function(obj) {\n  return (typeof obj == 'object') && (obj !== null);\n};\n\nUtil.processAsyncQueue = function(concurrency, files, cb) {\n  var maxWorkers = Math.min(concurrency, files.length);\n  var queue = [];\n  var add = function(item) {\n    queue.push(item);\n  };\n\n  var workers = 0;\n  var index = 0;\n  var next = function() {\n    workers -= 1;\n    process();\n  };\n\n  for (var i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n\n  var process = function() {\n    while (workers < maxWorkers) {\n      workers += 1;\n\n      if (queue.length) {\n        var item = queue.shift();\n        cb(item, index++, next);\n      }\n    }\n  };\n\n  process();\n};\n\nUtil.getModuleKey = function(filePath, srcFolders, fullPaths) {\n  var modulePathParts = filePath.split(path.sep);\n  var diffInFolder = '';\n  var folder = '';\n  var parentFolder = '';\n  var moduleName = modulePathParts.pop();\n  filePath = modulePathParts.join(path.sep);\n\n  if (srcFolders) {\n    for (var i = 0; i < srcFolders.length; i++) {\n      folder = path.resolve(srcFolders[i]);\n      if (fullPaths.length > 1) {\n        parentFolder = folder.split(path.sep).pop();\n      }\n      if (filePath.indexOf(folder) === 0) {\n        diffInFolder = filePath.substring(folder.length + 1);\n        break;\n      }\n    }\n  }\n\n  return path.join(parentFolder, diffInFolder, moduleName);\n};\n\nUtil.showStackTraceWithHeadline = function(headline, stack, isErr) {\n  var logMethod = isErr ? 'error' : 'log';\n  var stackTrace;\n  console[logMethod](Logger.colors.red(headline));\n\n  if (Array.isArray(stack) && stack.length > 0) {\n    stackTrace = Util.stackTraceFilter(stack);\n  } else {\n    stackTrace = stack;\n  }\n\n  if (stack) {\n    console[logMethod](Logger.colors.stack_trace(stackTrace));\n  }\n};\n\nUtil.stackTraceFilter = function(parts) {\n  var stack = parts.reduce(function(list, line) {\n    if (contains(line, [\n        'node_modules',\n        '(node.js:',\n        '(events.js:'\n      ])) {\n        return list;\n      }\n\n    list.push(line);\n    return list;\n  }, []);\n\n  return stack.join('\\n');\n};\n\nvar indentRegex = /^/gm;\nUtil.showStackTrace = function(stack) {\n  var parts = stack.split('\\n');\n  var headline = parts.shift();\n\n  console.log(Logger.colors.red(headline.replace(indentRegex, '   ')));\n  if (parts.length > 0) {\n    var result = Util.stackTraceFilter(parts);\n    console.log(Logger.colors.stack_trace(result.replace(indentRegex, '   ')));\n  }\n};\n\nUtil.symbols = (function() {\n  var ok = String.fromCharCode(10004);\n  var fail = String.fromCharCode(10006);\n\n  if (process.platform === 'win32') {\n    ok = '\\u221A';\n    fail = '\\u00D7';\n  }\n\n  return {\n    ok: ok,\n    fail: fail\n  };\n})();\n\nUtil.isErrorObject = function(err) {\n  return err instanceof Error || Object.prototype.toString.call(err) === '[object Error]';\n};\n\n// util to replace deprecated fs.existsSync\nUtil.dirExistsSync = function (path) {\n  try {\n    return fs.statSync(path).isDirectory();\n  } catch (e) {\n    return false;\n  }\n};\n\nUtil.fileExistsSync = function (path) {\n  try {\n    return fs.statSync(path).isFile();\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction contains(str, text) {\n  if (Array.isArray(text)) {\n    for (var i = 0; i < text.length; i++) {\n      if (contains(str, text[i])) {\n        return true;\n      }\n    }\n  }\n\n  return str.indexOf(text) > -1;\n}","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/api.js":"/*!\n * Module dependencies.\n */\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar events = require('events');\nvar assertModule = require('assert');\nvar CommandQueue = require('./queue.js');\nvar Assertion = require('./assertion.js');\nvar Page = require('../page-object/page.js');\n\nmodule.exports = new (function() {\n\n  var client;\n  var custom_commands_path;\n  var custom_assertions_path;\n  var page_objects_path;\n  var assertOperators = {\n    ok : ['ok', 'ko'],\n    equal : ['==', '!='],\n    notEqual : ['!=', '=='],\n    deepEqual : ['deepEqual', 'not deepEqual'],\n    notDeepEqual : ['not deepEqual', 'deepEqual'],\n    strictEqual : ['===', '!=='],\n    notStrictEqual : ['!==', '==='],\n    throws : ['throws', 'doesNotThrow'],\n    doesNotThrow : ['doesNotThrow', 'throws'],\n    fail : 'fail',\n    ifError : 'ifError'\n  };\n\n  /////////////////////////////////////////////////////////////////////\n  // Assertions\n  /////////////////////////////////////////////////////////////////////\n  /**\n   * Extends the node.js assert module\n   *\n   * @param prop\n   * @param abortOnFailure\n   * @returns {Function}\n   */\n  function makeAssertion(prop, abortOnFailure) {\n    return function() {\n      var passed;\n      var expected = null;\n      var actual = null;\n      var lastArgument = arguments[arguments.length-1];\n      var isLastArgString = typeof lastArgument === 'string';\n      var message = isLastArgString &&\n        (arguments.length > 2 || typeof arguments[0] === 'boolean') &&\n        lastArgument || (typeof arguments[0] === 'function' && '[Function]');\n\n      var args = Array.prototype.slice.call(arguments, 0);\n\n      try {\n        assertModule[prop].apply(null, arguments);\n        passed = true;\n        message = 'Passed [' + prop + ']: ' + (message || getAssertMessage(prop, args, passed));\n      } catch (ex) {\n        passed = false;\n        message = 'Failed [' + prop + ']: ' + ('(' + ex.message + ')' || message || getAssertMessage(prop, args, passed));\n        actual = ex.actual;\n        expected = ex.expected;\n      }\n\n      return Assertion.assert(passed, actual, expected, message, abortOnFailure);\n    };\n  }\n\n  function getAssertMessage(prop, args, passed) {\n    if (!Array.isArray(assertOperators[prop])) {\n      return assertOperators[prop] || '';\n    }\n\n    var operator = passed ? assertOperators[prop][0] : assertOperators[prop][1];\n\n    if (args.length === 2) {\n      args.splice(1, 0, operator);\n    } else {\n      args.push(operator);\n    }\n    args = args.map(function(argument) {\n      if (argument && typeof argument == 'object') {\n        argument = util.inspect(argument);\n      }\n      return argument;\n    });\n    return args.join(' ');\n  }\n\n  /**\n   * Loads the available assertions\n   */\n  function loadAssertions(parent) {\n    parent = parent || client.api;\n    parent.assert = {};\n    if (client.options.start_session) {\n      parent.verify = {};\n    }\n    for (var prop in assertModule) {\n      if (assertModule.hasOwnProperty(prop)) {\n        parent.assert[prop] = (function(prop) {\n          return makeAssertion(prop, true);\n        })(prop);\n        if (client.options.start_session) {\n          parent.verify[prop] = (function (prop) {\n            return makeAssertion(prop, false);\n          })(prop);\n        }\n      }\n    }\n\n    if (client.options.start_session) {\n      var dirPath = path.join(__dirname, './../api/assertions/');\n\n      loadAssertionFiles(dirPath, parent.assert, true);\n      loadAssertionFiles(dirPath, parent.verify, false);\n    }\n  }\n\n  /**\n   * Create an instance of an assertion\n   *\n   * @param {string} commandName\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {object} parent\n   * @returns {AssertionInstance}\n   */\n  function createAssertion(commandName, assertionFn, abortOnFailure, parent) {\n    var assertion;\n    if (typeof assertionFn === 'object' && assertionFn.assertion) {\n      assertion = Assertion.factory(assertionFn.assertion, abortOnFailure, client);\n      addCommand(commandName, assertion._commandFn, assertion, parent);\n      return assertion;\n    }\n\n    // backwards compatibility\n    var module = loadCommandModule(assertionFn, client.api, {\n      abortOnFailure : abortOnFailure\n    });\n\n    addCommand(commandName, module.command, module.context, parent);\n    return assertion;\n  }\n\n  /**\n   * Loads the actual assertion files.\n   *\n   * @param {String} dirPath\n   * @param {Object} parent\n   * @param {Boolean} abortOnFailure\n   */\n  function loadAssertionFiles(dirPath, parent, abortOnFailure) {\n    var commandFiles = fs.readdirSync(dirPath);\n\n    for (var i = 0, len = commandFiles.length; i < len; i++) {\n      if (path.extname(commandFiles[i]) === '.js') {\n        var commandName = path.basename(commandFiles[i], '.js');\n        var assertionFn = require(path.join(dirPath, commandFiles[i]));\n        createAssertion(commandName, assertionFn, abortOnFailure, parent);\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  // Commands\n  /////////////////////////////////////////////////////////////////////\n  /**\n   * Loads selenium protocol actions\n   */\n  function loadProtocolActions(parent) {\n    parent = parent || client.api;\n    var protocol = require('./../api/protocol.js')(client);\n    var actions  = Object.keys(protocol);\n    actions.forEach(function(command) {\n      addCommand(command, protocol[command], client.api, parent);\n    });\n  }\n\n  /**\n   * Loads all the composite commands defined by nightwatch\n   */\n  function loadAllCommands(parent) {\n    loadElementCommands(parent);\n    loadClientCommands(parent);\n    loadCommandFiles(client.api, parent, true);\n  }\n\n  /**\n   * Loads the element composite commands defined by nightwatch\n   */\n  function loadElementCommands(parent) {\n    parent = parent || client.api;\n    var elementCommands = require('./../api/element-commands.js')(client);\n    var entries = Object.keys(elementCommands);\n    entries.forEach(function(command) {\n      addCommand(command, elementCommands[command], client.api, parent);\n    });\n  }\n\n  /**\n   * Loads all the client commands defined by nightwatch\n   */\n  function loadClientCommands(parent) {\n    parent = parent || client.api;\n    var clientCommands = require('./../api/client-commands.js')(client);\n    var entries = Object.keys(clientCommands);\n    entries.forEach(function(command) {\n      addCommand(command, clientCommands[command], client.api, parent, true);\n    });\n  }\n\n  /**\n   * Loads the external commands\n   */\n  function loadCommandFiles(context, parent, shouldLoadClientCommands) {\n    var relativePaths = ['./../api/element-commands/'];\n    if (shouldLoadClientCommands) {\n      relativePaths.push('./../api/client-commands/');\n    }\n\n    relativePaths.forEach(function(relativePath) {\n      var commandFiles = fs.readdirSync(path.join(__dirname, relativePath));\n      var commandName;\n      var commandModule;\n\n      for (var i = 0, len = commandFiles.length; i < len; i++) {\n        var ext = path.extname(commandFiles[i]);\n        commandName = path.basename(commandFiles[i], ext);\n        if (ext === '.js' && commandName.substr(0, 1) !== '_') {\n          commandModule = require(__dirname + relativePath + commandFiles[i]);\n          var m = loadCommandModule(commandModule, context);\n          addCommand(commandName, m.command, m.context, parent);\n        }\n      }\n    });\n  }\n\n  /**\n   * Loads a command module either specified as an object with a `command` method\n   * or specified as a function which will be instantiated (new function() {..})\n   *\n   * @param {object|function} module\n   * @param {object} context\n   * @param {object} [addt_props]\n   * @returns {{command: function, context: *}}\n   */\n  function loadCommandModule(module, context, addt_props, return_val) {\n    var m = {command: null, context: context};\n\n    function F() {\n      if (typeof module === 'object') {\n        events.EventEmitter.call(this);\n      }\n      if (addt_props) {\n        for (var prop in addt_props) {\n          if (addt_props.hasOwnProperty(prop)) {\n            this[prop] = addt_props[prop];\n          }\n        }\n      }\n      this.client = client;\n      this.api = client.api;\n      if (typeof module === 'function') {\n        module.call(this);\n      }\n    }\n\n    if (typeof module === 'object' && module.command) {\n      util.inherits(F, events.EventEmitter);\n      F.prototype.command = function() {\n        return module.command.apply(this, arguments);\n      };\n    } else if (typeof module === 'function') {\n      F.prototype = Object.create(module.prototype);\n      F.prototype.constructor = F;\n    }\n\n    m.command = function commandFn() {\n      var instance = new F();\n      if (typeof module === 'function') {\n        context = m.context = instance;\n      }\n      instance.command.prototype.constructor.stackTrace = commandFn.stackTrace;\n      instance.command.apply(context, arguments);\n      return context;\n    };\n\n    return m;\n  }\n\n  /**\n   * Loads custom commands defined by the user\n   * @param {string} [dirPath]\n   * @param {object} [parent]\n   */\n  function loadCustomCommands(dirPath, parent) {\n    if (!custom_commands_path && !dirPath) {\n      return;\n    }\n\n    dirPath = dirPath || custom_commands_path;\n    parent = parent || client.api;\n\n    if (Array.isArray(dirPath)) {\n      dirPath.forEach(function(folder) {\n        loadCustomCommands(folder, parent);\n      });\n      return;\n    }\n\n    var absPath = path.resolve(dirPath);\n    var commandFiles = fs.readdirSync(absPath);\n\n    commandFiles.forEach(function(file) {\n      var fullPath = path.join(absPath, file);\n      if (fs.lstatSync(fullPath).isDirectory()) {\n        parent[file] = parent[file] || {};\n        var pathFolder = path.join(dirPath, file);\n        loadCustomCommands(pathFolder, parent[file]);\n      } else if (path.extname(file) === '.js') {\n        var commandModule = require(fullPath);\n        var name = path.basename(file, '.js');\n\n        if (!commandModule) {\n          throw new Error('Module ' + file + 'should have a public method or function.');\n        }\n\n        var m = loadCommandModule(commandModule, client.api);\n        addCommand(name, m.command, m.context, parent, true);\n      }\n    });\n  }\n\n  /**\n   * Loads custom assertions, similarly to custom commands\n   * @param [folder]\n   */\n  function loadCustomAssertions(folder, parent) {\n    folder = folder || custom_assertions_path;\n    parent = parent || client.api;\n    if (!custom_assertions_path) {\n      return;\n    }\n\n    if (Array.isArray(folder)) {\n      folder.forEach(function(folderName) {\n        loadCustomAssertions(folderName, parent);\n      });\n      return;\n    }\n\n    loadCustomAssertionFolder(folder, parent);\n  }\n\n  function loadCustomAssertionFolder(folderName, parent) {\n    var absPath = path.resolve(folderName);\n    loadAssertionFiles(absPath, parent.assert, true);\n    loadAssertionFiles(absPath, parent.verify, false);\n  }\n\n  function loadExpectAssertions(parent) {\n    parent = parent || client.api;\n    var Expect = require('../api/expect.js')(client);\n    var assertions  = Object.keys(Expect);\n\n    try {\n      var chaiExpect = module.require('chai').expect;\n      parent.expect = function() {\n        return chaiExpect.apply(chaiExpect, arguments);\n      };\n    } catch (err) {\n      parent.expect = {};\n    }\n\n    assertions.forEach(function(assertion) {\n      parent.expect[assertion] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        var command = Expect[assertion].apply(parent, args);\n\n        function F(element) {\n          events.EventEmitter.call(this);\n          this.client = client;\n          this.element = element;\n        }\n        util.inherits(F, events.EventEmitter);\n        F.prototype.command = function commandFn() {\n          this.element._stackTrace = commandFn.stackTrace;\n          this.element.locate(this);\n          return this;\n        };\n\n        var instance = new F(command.element);\n        var err = new Error;\n        Error.captureStackTrace(err, arguments.callee);\n        CommandQueue.add(assertion, instance.command, instance, [], err.stack);\n\n        return command.expect;\n      };\n    });\n  }\n\n  /**\n   * Loads page object files\n   * @param {string} [dirPath]\n   */\n  function loadPageObjects(dirPath, parent) {\n    if (!page_objects_path && !dirPath) {\n      return;\n    }\n\n    dirPath = dirPath || page_objects_path;\n    client.api.page = client.api.page || {};\n    parent = parent || client.api.page;\n\n    if (Array.isArray(dirPath)) {\n      dirPath.forEach(function(folder) {\n        loadPageObjects(folder);\n      });\n      return;\n    }\n\n    var absPath = path.resolve(dirPath);\n    var pageFiles = fs.readdirSync(absPath);\n\n    pageFiles.forEach(function(file) {\n      var fullPath = path.join(absPath, file);\n      if (fs.lstatSync(fullPath).isDirectory()) {\n        parent[file] = parent[file] || {};\n        var pathFolder = path.join(dirPath, file);\n        loadPageObjects(pathFolder, parent[file]);\n      } else if (path.extname(file) === '.js') {\n        var pageName = path.basename(file, '.js');\n        var pageFnOrObject = require(path.join(absPath, file));\n        addPageObject(pageName, pageFnOrObject, client.api, parent);\n      }\n    });\n  }\n\n  /**\n   * Instantiates the page object class\n   * @param {String} name\n   * @param {Object} pageFnOrObject\n   * @param {Object} context\n   * @param {Object} parent\n   */\n  function addPageObject(name, pageFnOrObject, context, parent) {\n    parent[name] = function() {\n      var args = Array.prototype.slice.call(arguments);\n      args.unshift(context);\n\n      if (useEnhancedModel(pageFnOrObject)) {\n        var loadOntoPageObject = function(parent) {\n          if (client.options.start_session) {\n            loadElementCommands(parent);\n            loadCommandFiles(client.api, parent, false);\n            loadExpectAssertions(parent);\n            // Alias\n            parent.expect.section = parent.expect.element;\n          }\n          loadAssertions(parent);\n          loadCustomCommands(null, parent);\n          loadCustomAssertions(null, parent);\n          return parent;\n        };\n        pageFnOrObject.name = name;\n        return new Page(pageFnOrObject, loadOntoPageObject, context, client);\n      }\n\n      return new (function() {\n        if (typeof pageFnOrObject == 'function') {\n          return createPageObject(pageFnOrObject, args);\n        }\n\n        return pageFnOrObject;\n      })();\n    };\n  }\n\n  function useEnhancedModel(pageFnOrObject) {\n    return typeof pageFnOrObject == 'object' && (pageFnOrObject.elements || pageFnOrObject.sections);\n  }\n\n  /**\n   *\n   * @param pageFnOrObject\n   * @param args\n   * @returns {Object}\n   */\n  function createPageObject(pageFnOrObject, args) {\n    function PageObject() {\n      return pageFnOrObject.apply(this, args);\n    }\n    PageObject.prototype = pageFnOrObject.prototype;\n    return new PageObject();\n  }\n\n  /**\n   * Adds a command/assertion to the queue.\n   *\n   * @param {String} name\n   * @param {Object} command\n   * @param {Object} context\n   * @param {Object} [parent]\n   */\n  function addCommand(name, command, context, parent) {\n    parent = parent || client.api;\n    if (parent[name]) {\n      client.results.errors++;\n      var error = new Error('The command \"' + name + '\" is already defined!');\n      client.errors.push(error.stack);\n      throw error;\n    }\n    parent[name] = function commandFn() {\n      var args = Array.prototype.slice.call(arguments);\n\n      var originalStackTrace;\n      if (commandFn.stackTrace) {\n        originalStackTrace = commandFn.stackTrace;\n      } else {\n        var err = new Error;\n        Error.captureStackTrace(err, arguments.callee);\n        originalStackTrace = err.stack;\n      }\n\n      CommandQueue.add(name, command, context, args, originalStackTrace);\n      return client.api; // for chaining\n    };\n  }\n\n  /**\n   * Initialize the api\n   *\n   * @param {Object} c The nightwatch client instance\n   * @api public\n   */\n  this.init = function(c) {\n    client = c;\n    custom_commands_path = c.options.custom_commands_path;\n    custom_assertions_path = c.options.custom_assertions_path;\n    page_objects_path = c.options.page_objects_path;\n    return this;\n  };\n\n  /**\n   * Loads everything\n   */\n  this.load = function() {\n    if (client.options.start_session) {\n      loadProtocolActions();\n      loadAllCommands();\n      loadPageObjects();\n      loadExpectAssertions();\n    }\n    loadAssertions();\n    loadCustomCommands();\n    loadCustomAssertions();\n    return this;\n  };\n\n  this.addCommand = addCommand;\n  this.loadCustomCommands = loadCustomCommands;\n  this.loadCustomAssertions = loadCustomAssertions;\n  this.loadPageObjects = loadPageObjects;\n  this.createAssertion = createAssertion;\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/page.js":"var PageUtils = require('./page-utils.js');\nvar CommandWrapper = require('./command-wrapper.js');\n\n/**\n * Class that all pages subclass from\n *\n * @param {Object} options Page options defined in page object\n * @constructor\n */\nfunction Page(options, commandLoader, api, client) {\n  this.commandLoader = commandLoader;\n  this.api = api;\n  this.client = client;\n  this.name = options.name;\n  this.url = options.url;\n\n  PageUtils\n    .createProps(this, options.props || {})\n    .createElements(this, options.elements || {})\n    .createSections(this, options.sections || {})\n    .addCommands(this, options.commands || []);\n\n  CommandWrapper.addWrappedCommands(this, this.commandLoader);\n}\n\nPage.prototype = {\n  /**\n   * Returns the url passed as an argument (or null if no arguments are passed).\n   *  If the supplied url is a function, it invokes that function with the page as its context.\n   *\n   * @method getUrl\n   * @param {string} url\n   * @returns {string|null}\n   */\n  getUrl: function(url) {\n    if (typeof url === 'function') {\n      return url.call(this);\n    } else if (typeof url === 'string') {\n      return url;\n    }\n\n    return null;\n  },\n\n  /**\n   * This command is an alias to url and also a convenience method because when called without any arguments\n   *  it performs a call to .url() with passing the value of `url` property on the page object.\n   * Uses `url` protocol command.\n   *\n   * @method navigate\n   * @param {Object} [url=this.url] Url to navigate to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @returns {*}\n   */\n  navigate: function(url, callback) {\n    var goToUrl = this.getUrl(url || this.url);\n    if (goToUrl === null) {\n      throw new Error('Invalid URL: You must either add a url property to \"' +\n        this.name + '\" or provide a url as an argument');\n    }\n    this.api.url(goToUrl, callback);\n    return this;\n  }\n};\n\nmodule.exports = Page;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/page-utils.js":"module.exports = new (function() {\n  /**\n   * Returns the properties object passed as an argument (or null if no arguments are passed).\n   *  If the supplied properties argument is a function, it invokes that function with the page as its context.\n   *\n   * @method createProps\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object|Function} props Object or Function that returns an object\n   * @returns {null}\n   */\n  this.createProps = function(parent, props) {\n    parent.props = typeof props === 'function' ? props.call(parent) : props;\n\n    return this;\n  };\n\n  /**\n   * Assigns the `elements` property for a page or section object.\n   *  For each object in the passed array, it creates a new element object by instantiating Element with its options\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object|Array} elements Object or array of objects to become element objects\n   * @returns {null}\n   */\n  this.createElements = function(parent, elements) {\n    var Element = require('./element.js');\n    var elementObjects = {};\n    var el;\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function(els) {\n      Object.keys(els).forEach(function(e) {\n        el = typeof els[e] === 'string' ? { selector: els[e] } : els[e];\n        el.parent = parent;\n        el.name = e;\n        elementObjects[el.name] = new Element(el);\n      });\n    });\n\n    parent.elements = elementObjects;\n\n    return this;\n  };\n\n  /**\n   * Assigns the `section` property for a page or section object.\n   *  For each object in the passed array, it creates a new section object by instantiating Section with its options\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Array} sections Array of objects to become section objects\n   * @returns {null}\n   */\n  this.createSections = function(parent, sections) {\n    var Section = require('./section.js');\n    var sectionObjects = {};\n    var sec;\n\n    Object.keys(sections).forEach(function(s) {\n      sec = sections[s];\n      sec.parent = parent;\n      sec.name = s;\n      sectionObjects[sec.name] = new Section(sec);\n    });\n\n    parent.section = sectionObjects;\n\n    return this;\n  };\n\n  /**\n   * Mixes in the passed functions to the page or section object.\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object} command Array of commands that will be added to the age or section\n   * @returns {null}\n   */\n  this.addCommands = function(parent, commands) {\n    commands.forEach(function(m) {\n      Object.keys(m).forEach(function(k) {\n        parent[k] = m[k];\n      });\n    });\n\n    return this;\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/command-wrapper.js":"module.exports = new (function() {\n\n  /**\n   * Given an element name, returns that element object\n   *\n   * @param {Object} parent The parent page or section\n   * @param {string} elementName Name of element\n   * @returns {Object} The element object\n   */\n  function getElement(parent, elementName) {\n    elementName = elementName.substring(1);\n    if (!(elementName in parent.elements)) {\n      throw new Error(elementName + ' was not found in \"' + parent.name +\n        '\". Available elements: ' + Object.keys(parent.elements));\n    }\n    return parent.elements[elementName];\n  }\n\n  /**\n   * Given a section name, returns that section object\n   *\n   * @param {Object} parent The parent page or section\n   * @param {string} sectionName Name of section\n   * @returns {Object} The section object\n   */\n  function getSection(parent, sectionName) {\n    sectionName = sectionName.substring(1);\n    if (!(sectionName in parent.section)) {\n      throw new Error(sectionName + ' was not found in \"' + parent.name +\n        '\". Available sections: ' + Object.keys(parent.sections));\n    }\n    return parent.section[sectionName];\n  }\n\n  /**\n   * Calls use(Css|Xpath|Recursion) command\n   *\n   * Uses `useXpath`, `useCss`, and `useRecursion` commands.\n   *\n   * @param {Object} client The Nightwatch instance\n   * @param {string} desiredStrategy (css selector|xpath|recursion)\n   * @returns {null}\n   */\n  function setLocateStrategy(client, desiredStrategy) {\n    var methodMap = {\n      xpath : 'useXpath',\n      'css selector' : 'useCss',\n      recursion : 'useRecursion'\n    };\n\n    if (desiredStrategy in methodMap) {\n      client.api[methodMap[desiredStrategy]]();\n    }\n  }\n\n  /**\n   * Creates a closure that enables calling commands and assertions on the page or section.\n   * For all element commands and assertions, it fetches element's selector and locate strategy\n   *  For elements nested under sections, it sets 'recursion' as the locate strategy and passes as its first argument to the command an array of its ancestors + self\n   *  If the command or assertion is not on an element, it calls it with the untouched passed arguments\n   *\n   * @param {Object} parent The parent page or section\n   * @param {function} commandFn The actual command function\n   * @param {string} commandName The name of the command (\"click\", \"containsText\", etc)\n   * @param {Boolean} [isChaiAssertion]\n   * @returns {function}\n   */\n  function makeWrappedCommand(parent, commandFn, commandName, isChaiAssertion) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var prevLocateStrategy = parent.client.locateStrategy;\n      var elementCommand = isElementCommand(args);\n\n      if (elementCommand) {\n        var firstArg;\n        var desiredStrategy;\n        var callbackIndex;\n        var originalCallback;\n        var elementOrSectionName = args.shift();\n        var getter = (isChaiAssertion && commandName === 'section') ? getSection : getElement;\n        var elementOrSection = getter(parent, elementOrSectionName);\n        var ancestors = getAncestorsWithElement(elementOrSection);\n\n        if (ancestors.length === 1) {\n          firstArg = elementOrSection.selector;\n          desiredStrategy = elementOrSection.locateStrategy;\n        } else {\n          firstArg = ancestors;\n          desiredStrategy = 'recursion';\n        }\n\n        setLocateStrategy(parent.client, desiredStrategy);\n        args.unshift(firstArg);\n\n        // if a callback is being used with this command, wrap it in\n        // a function that allows us to restore the locate strategy\n        // to its original value before the callback is called\n\n        callbackIndex = findCallbackIndex(args);\n        if (callbackIndex !== -1) {\n          originalCallback = args[callbackIndex];\n\n          args[callbackIndex] = function callbackWrapper() {\n\n            // restore the locate strategy directly through client.locateStrategy.\n            // setLocateStrategy() can't be used since it uses the api commands\n            // which get added to the command queue and will not update the\n            // strategy in time for the callback which is getting immediately\n            // called after\n\n            parent.client.locateStrategy = prevLocateStrategy;\n            return originalCallback.apply(parent.client.api, arguments);\n          };\n        }\n      }\n\n      var c = commandFn.apply(parent.client, args);\n      if (elementCommand) {\n        setLocateStrategy(parent.client, prevLocateStrategy);\n      }\n      return (isChaiAssertion ? c : parent);\n    };\n  }\n\n  /**\n   *\n   * @param {Array} args\n   * @return {boolean}\n   */\n  function isElementCommand(args) {\n    return (args.length > 0) && (args[0].toString().indexOf('@') === 0);\n  }\n\n  /**\n   * Identifies the location of a callback function within an arguments array.\n   *\n   * @param {Array} args Arguments array in which to find the location of a callback.\n   * @returns {number} Index location of the callback in the args array. If not found, -1 is returned.\n   */\n  function findCallbackIndex(args) {\n\n    if (args.length === 0) {\n      return -1;\n    }\n\n    // callbacks will usually be the last argument. waitFor methods allow an additional\n    // message argument to follow the callback which will also need to be checked for.\n\n    // last argument\n\n    var index = args.length - 1;\n    if (typeof args[index] === 'function') {\n      return index;\n    }\n\n    // second to last argument (waitfor calls)\n\n    index--;\n    if (typeof args[index] === 'function') {\n      return index;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Retrieves an array of ancestors of the supplied element. The last element in the array is the element object itself\n   *\n   * @param {Object} element The element\n   * @returns {Array}\n   */\n  function getAncestorsWithElement(element) {\n    var elements = [];\n    function addElement(e) {\n      elements.unshift(e);\n      if (e.parent && e.parent.selector) {\n        addElement(e.parent);\n      }\n    }\n    addElement(element);\n    return elements;\n  }\n\n  /**\n   * Adds commands (elements commands, assertions, etc) to the page or section\n   *\n   * @param {Object} parent The parent page or section\n   * @param {Object} target What the command is added to (parent|section or assertion object on parent|section)\n   * @param {Object} commands\n   * @returns {null}\n   */\n  function applyCommandsToTarget(parent, target, commands) {\n\n    Object.keys(commands).forEach(function(commandName) {\n      if (isValidAssertion(commandName)) {\n        target[commandName] = target[commandName] || {};\n\n        var isChaiAssertion = commandName === 'expect';\n        var assertions = commands[commandName];\n\n        Object.keys(assertions).forEach(function(assertionName) {\n          target[commandName][assertionName] = addCommand(target[commandName], assertions[assertionName], assertionName, parent, isChaiAssertion);\n        });\n      } else {\n        target[commandName] = addCommand(target, commands[commandName], commandName, parent, false);\n      }\n    });\n  }\n\n  function addCommand(target, commandFn, commandName, parent, isChaiAssertion) {\n    if (target[commandName]) {\n      parent.client.results.errors++;\n      var error = new Error('The command \"' + commandName + '\" is already defined!');\n      parent.client.errors.push(error.stack);\n      throw error;\n    }\n\n    return makeWrappedCommand(parent, commandFn, commandName, isChaiAssertion);\n  }\n\n  function isValidAssertion(commandName) {\n    return ['assert', 'verify', 'expect'].indexOf(commandName) > -1;\n  }\n\n  /**\n   * Entrypoint to add commands (elements commands, assertions, etc) to the page or section\n   *\n   * @param {Object} parent The parent page or section\n   * @param {function} commandLoader function that retrieves commands\n   * @returns {null}\n   */\n  this.addWrappedCommands = function (parent, commandLoader) {\n    var commands = {};\n    commands = commandLoader(commands);\n    applyCommandsToTarget(parent, parent, commands);\n  };\n\n})();\n"}