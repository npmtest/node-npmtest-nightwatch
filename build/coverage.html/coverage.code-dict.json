{"/home/travis/build/npmtest/node-npmtest-nightwatch/test.js":"/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/lib.npmtest_nightwatch.js":"/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nightwatch = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nightwatch = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nightwatch && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nightwatch */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nightwatch\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nightwatch.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nightwatch.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nightwatch.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nightwatch.__dirname + '/lib.npmtest_nightwatch.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/index.js":"/*!\n * Module dependencies.\n */\nvar path = require('path');\nvar util = require('util');\nvar events = require('events');\nvar HttpRequest = require('./http/request.js');\nvar CommandQueue = require('./core/queue.js');\nvar Assertion = require('./core/assertion.js');\nvar Logger = require('./util/logger.js');\nvar Api = require('./core/api.js');\nvar Utils = require('./util/utils.js');\n\nfunction Nightwatch(options) {\n  events.EventEmitter.call(this);\n\n  this.api = {\n    capabilities : {},\n    globals : options && options.persist_globals && options.globals || {},\n    sessionId : null\n  };\n\n  this.setMaxListeners(0);\n  this.sessionId = null;\n  this.context = null;\n  this.terminated = false;\n\n  this.setOptions(options)\n      .setCapabilities()\n      .loadKeyCodes();\n\n  this.errors = [];\n  this.results = {\n    passed:0,\n    failed:0,\n    errors:0,\n    skipped:0,\n    tests:[]\n  };\n\n  Assertion.init(this);\n  Api.init(this).load();\n\n  this.queue = CommandQueue;\n  this.queue.empty();\n  this.queue.reset();\n}\n\nNightwatch.DEFAULT_CAPABILITIES = {\n  browserName: 'firefox',\n  javascriptEnabled: true,\n  acceptSslCerts: true,\n  platform: 'ANY'\n};\n\nutil.inherits(Nightwatch, events.EventEmitter);\n\nNightwatch.prototype.assertion = Assertion.assert;\n\nNightwatch.prototype.setOptions = function(options) {\n  this.options = {};\n  this.api.options = {};\n  if (options && typeof options == 'object') {\n    for (var propName in options) {\n      this.options[propName] = options[propName];\n    }\n  }\n\n  this.api.launchUrl = this.options.launchUrl || this.options.launch_url || null;\n  // backwords compatibility\n  this.api.launch_url = this.api.launchUrl;\n\n  if (this.options.globals && typeof this.options.globals == 'object' && !this.options.persist_globals) {\n    for (var globalKey in this.options.globals) {\n      this.api.globals[globalKey] = this.options.globals[globalKey];\n    }\n  }\n\n  var screenshots = this.options.screenshots;\n  var screenshotsEnabled = screenshots && screenshots.enabled || false;\n\n  this.api.options.screenshots = screenshotsEnabled;\n  if (screenshotsEnabled) {\n    if (typeof screenshots.path == 'undefined') {\n      throw new Error('Please specify the screenshots.path in nightwatch.json.');\n    }\n    this.options.screenshots.on_error = this.options.screenshots.on_error ||\n      (typeof this.options.screenshots.on_error == 'undefined');\n    this.api.screenshotsPath = this.api.options.screenshotsPath = screenshots.path;\n  } else {\n    this.options.screenshots = {\n      enabled : false,\n      path : ''\n    };\n  }\n\n  this.setLocateStrategy();\n\n  if (this.options.silent) {\n    Logger.disable();\n  } else {\n    Logger.enable();\n  }\n\n  this.options.start_session = this.options.start_session || (typeof this.options.start_session == 'undefined');\n\n  this.api.options.skip_testcases_on_fail = this.options.skip_testcases_on_fail ||\n    (typeof this.options.skip_testcases_on_fail == 'undefined' && this.options.start_session); // off by default for unit tests\n\n  this.api.options.log_screenshot_data = this.options.log_screenshot_data ||\n    (typeof this.options.log_screenshot_data == 'undefined');\n  var seleniumPort     = this.options.seleniumPort || this.options.selenium_port;\n  var seleniumHost     = this.options.seleniumHost || this.options.selenium_host;\n  var useSSL           = this.options.useSsl || this.options.use_ssl;\n  var proxy            = this.options.proxy;\n  var timeoutOptions   = this.options.request_timeout_options || {};\n\n  if (seleniumPort) {\n    HttpRequest.setSeleniumPort(seleniumPort);\n  }\n  if (seleniumHost) {\n    HttpRequest.setSeleniumHost(seleniumHost);\n  }\n  if (useSSL) {\n    HttpRequest.useSSL(true);\n  }\n  if (proxy) {\n    HttpRequest.setProxy(proxy);\n  }\n  if (typeof timeoutOptions.timeout != 'undefined') {\n    HttpRequest.setTimeout(timeoutOptions.timeout);\n  }\n  if (typeof timeoutOptions.retry_attempts != 'undefined') {\n    HttpRequest.setRetryAttempts(timeoutOptions.retry_attempts);\n  }\n\n  if (typeof this.options.default_path_prefix == 'string') {\n    HttpRequest.setDefaultPathPrefix(this.options.default_path_prefix);\n  }\n\n  var username = this.options.username;\n  var key = this.options.accesKey || this.options.access_key || this.options.password;\n\n  if (username && key) {\n    this.api.options.username = username;\n    this.api.options.accessKey = key;\n\n    HttpRequest.setCredentials({\n      username : username,\n      key : key\n    });\n  }\n\n  this.endSessionOnFail(typeof this.options.end_session_on_fail == 'undefined' || this.options.end_session_on_fail);\n\n  return this;\n};\n\nNightwatch.prototype.endSessionOnFail = function(value) {\n  if (typeof value == 'undefined') {\n    return this.options.end_session_on_fail;\n  }\n\n  this.options.end_session_on_fail = value;\n  return this;\n};\n\nNightwatch.prototype.setCapabilities = function() {\n  this.desiredCapabilities = {};\n  for (var capability in Nightwatch.DEFAULT_CAPABILITIES) {\n    this.desiredCapabilities[capability] = Nightwatch.DEFAULT_CAPABILITIES[capability];\n  }\n\n  if (this.options.desiredCapabilities) {\n    for (var prop in this.options.desiredCapabilities) {\n      if (this.options.desiredCapabilities.hasOwnProperty(prop)) {\n        this.desiredCapabilities[prop] = this.options.desiredCapabilities[prop];\n      }\n    }\n  }\n  this.api.options.desiredCapabilities = this.desiredCapabilities;\n  return this;\n};\n\nNightwatch.prototype.setLocateStrategy = function () {\n  this.locateStrategy = this.options.use_xpath ? 'xpath' : 'css selector';\n  return this;\n};\n\nNightwatch.prototype.loadKeyCodes = function() {\n  this.api.Keys = require('./util/keys.json');\n  return this;\n};\n\nNightwatch.prototype.start = function() {\n  if (!this.sessionId && this.options.start_session) {\n    this\n      .once('selenium:session_create', this.start)\n      .startSession();\n    return this;\n  }\n\n  var self = this;\n\n  this.queue.reset();\n  this.queue.run(function(error) {\n    if (error) {\n      var stackTrace = '';\n      if (error.stack) {\n        stackTrace = error.stack.split('\\n').slice(1).join('\\n');\n      }\n\n      self.results.errors++;\n      self.errors.push(error.name + ': ' + error.message + '\\n' + stackTrace);\n      if (self.options.output) {\n        Utils.showStackTraceWithHeadline(error.name + ': ' + error.message, stackTrace, true);\n      }\n\n      if (self.options.start_session) {\n        self.terminate();\n      }\n      return;\n    }\n\n    self.finished();\n  });\n\n  return this;\n};\n\nNightwatch.prototype.terminate = function(deferred) {\n  // in case this was a synchronous command (e.g. assert.ok()) we need to wait for other possible\n  // commands which might have been added afterwards while client is terminated\n  if (deferred) {\n    this.queue.instance().once('queue:started', this.terminateSession.bind(this));\n  } else {\n    this.terminateSession();\n  }\n\n  this.terminated = true;\n  return this;\n};\n\nNightwatch.prototype.resetTerminated = function() {\n  this.terminated = false;\n  return this;\n};\n\nNightwatch.prototype.terminateSession = function() {\n  this.queue.reset();\n  this.queue.empty();\n\n  if (this.options.end_session_on_fail && this.options.start_session) {\n    this.api.end(function() {\n      this.finished();\n    }.bind(this));\n\n    // FIXME: sometimes the queue is incorrectly restarted when another .end() is\n    // scheduled from globalBeforeEach and results into a session command being sent with\n    // null as the sessionId\n    this.queue.run();\n  } else {\n    this.finished();\n  }\n  return this;\n};\n\nNightwatch.prototype.complete = function() {\n  return this.emit('complete');\n};\n\nNightwatch.prototype.finished = function() {\n  Logger.info('FINISHED');\n\n  this.emit('nightwatch:finished', this.results, this.errors);\n\n  return this;\n};\n\nNightwatch.prototype.getFailureMessage = function() {\n  var errors = '';\n\n  var failure_msg = [];\n  if (this.results.failed > 0) {\n    failure_msg.push(Logger.colors.red(this.results.failed) +\n      ' assertions failed');\n  }\n  if (this.results.errors > 0) {\n    failure_msg.push(Logger.colors.red(this.results.errors) + ' errors');\n  }\n  if (this.results.passed > 0) {\n    failure_msg.push(Logger.colors.green(this.results.passed) + ' passed');\n  }\n\n  if (this.results.skipped > 0) {\n    failure_msg.push(Logger.colors.blue(this.results.skipped) + ' skipped');\n  }\n\n  return failure_msg.join(', ').replace(/,([^,]*)$/g, function($0, $1) {\n    return  ' and' + $1;\n  });\n};\n\nNightwatch.prototype.printResult = function(elapsedTime) {\n  if (this.options.output && this.options.start_session) {\n    var ok = false;\n    if (this.results.failed === 0 && this.results.errors === 0) {\n      ok = true;\n    }\n\n    if (ok && this.results.passed > 0) {\n      console.log('\\n' + Logger.colors.green('OK.'),\n        Logger.colors.green(this.results.passed) + ' assertions passed. (' + Utils.formatElapsedTime(elapsedTime, true) + ')');\n    } else if (ok && this.results.passed === 0) {\n      if (this.options.start_session) {\n        console.log(Logger.colors.green('No assertions ran.'));\n      }\n    } else {\n      var failure_msg = this.getFailureMessage();\n      console.log('\\n' +  Logger.colors.red('FAILED: '), failure_msg, '(' + Utils.formatElapsedTime(elapsedTime, true) + ')');\n    }\n  }\n};\n\nNightwatch.prototype.clearResult = function() {\n  this.errors.length = 0;\n  this.results.passed = 0;\n  this.results.failed = 0;\n  this.results.errors = 0;\n  this.results.skipped = 0;\n  this.results.tests.length = 0;\n};\n\nNightwatch.prototype.handleException = function(err) {\n  var stack = err.stack.split('\\n');\n  var failMessage = stack.shift();\n  var firstLine = ' ' + String.fromCharCode(10006) + ' ' + failMessage;\n  if (typeof err.actual != 'undefined' && typeof err.expected != 'undefined') {\n    firstLine += '\\033[0;90m - expected ' + Logger.colors.green('\"' + err.expected + '\"') + ' \\033[0;90mbut got: ' + Logger.colors.red('\"' + err.actual + '\"');\n  }\n\n  if (this.options.output) {\n    Utils.showStackTraceWithHeadline(firstLine, stack);\n  }\n\n  if (err.name == 'AssertionError') {\n    this.results.failed++;\n    stack.unshift(failMessage + ' - expected \"' + err.expected + '\" but got: \"' + err.actual + '\"');\n    this.results.stackTrace = stack.join('\\n');\n  } else {\n    this.addError('\\n  ' + err.stack, firstLine);\n    this.terminate();\n  }\n};\n\nNightwatch.prototype.runProtocolAction = function(requestOptions, callback) {\n  var self = this;\n\n  var request = new HttpRequest(requestOptions)\n    .on('result', function(result) {\n      if (typeof callback != 'function') {\n        var error = new Error('Callback parameter is not a function - ' + typeof(callback) + ' passed: \"' + callback + '\"');\n        self.errors.push(error.stack);\n        self.results.errors++;\n      } else {\n        callback.call(self.api, result);\n      }\n\n      if (result.lastScreenshotFile && self.results.tests.length > 0) {\n        var lastTest = self.results.tests[self.results.tests.length-1];\n        lastTest.screenshots = lastTest.screenshots || [];\n        lastTest.screenshots.push(result.lastScreenshotFile);\n        delete result.lastScreenshotFile;\n      }\n\n      request.emit('complete');\n    })\n    .on('success', function(result, response) {\n      if (result.status && result.status !== 0) {\n        result = self.handleTestError(result);\n      }\n      request.emit('result', result, response);\n    })\n    .on('error', function(result, response, screenshotContent) {\n      result = self.handleTestError(result);\n\n      if (screenshotContent && self.options.screenshots.on_error) {\n        var fileNamePath = Utils.getScreenshotFileName(self.api.currentTest, true, self.options.screenshots.path);\n        self.saveScreenshotToFile(fileNamePath, screenshotContent);\n        result.lastScreenshotFile = fileNamePath;\n      }\n\n      request.emit('result', result, response);\n    });\n\n  return request;\n};\n\nNightwatch.prototype.addError = function(message, logMessage) {\n  var currentTest;\n  if (this.api.currentTest) {\n    currentTest = '[' + Utils.getTestSuiteName(this.api.currentTest.module) + ' / ' + this.api.currentTest.name + ']';\n  } else {\n    currentTest = 'tests';\n  }\n\n  this.errors.push('  Error while running '+ currentTest  + ':\\n' + message);\n  this.results.errors++;\n  if (this.options.output) {\n    Logger.warn('    ' + (logMessage || message));\n  }\n\n};\n\nNightwatch.prototype.saveScreenshotToFile = function(fileName, content, cb) {\n  var mkpath = require('mkpath');\n  var fs = require('fs');\n  var self = this;\n  cb = cb || function() {};\n\n  var dir = path.resolve(fileName, '..');\n  var fail = function(err) {\n    if (self.options.output) {\n      console.log(Logger.colors.yellow('Couldn\\'t save screenshot to '), fileName);\n    }\n\n    Logger.warn(err);\n    cb(err);\n  };\n\n  mkpath(dir, function(err) {\n    if (err) {\n      fail(err);\n    } else {\n      fs.writeFile(fileName, content, 'base64', function(err) {\n        if (err) {\n          fail(err);\n        } else {\n          cb(null, fileName);\n        }\n      });\n    }\n  });\n};\n\nNightwatch.prototype.handleTestError = function(result) {\n  var errorMessage = '';\n  if (result && result.status) {\n    var errorCodes = require('./api/errors.json');\n    errorMessage = errorCodes[result.status] && errorCodes[result.status].message || '';\n  }\n\n  return {\n    status: -1,\n    value : result && result.value || null,\n    errorStatus: result && result.status || '',\n    error : errorMessage\n  };\n};\n\nNightwatch.prototype.startSession = function () {\n  if (this.terminated) {\n    return this;\n  }\n  var self = this;\n  var options = {\n    path : '/session',\n    data : {\n      desiredCapabilities : this.desiredCapabilities\n    }\n  };\n\n  var request = new HttpRequest(options);\n  request.on('success', function(data, response, isRedirect) {\n    if (data && data.sessionId) {\n      self.sessionId = self.api.sessionId = data.sessionId;\n      if (data.value) {\n        self.api.capabilities = data.value;\n      }\n      Logger.info('Got sessionId from selenium', self.sessionId);\n      self.emit('selenium:session_create', self.sessionId, request, response);\n    } else if (isRedirect) {\n      self.followRedirect(request, response);\n    } else {\n      request.emit('error', data, null);\n    }\n  })\n  .on('error', function(data, err) {\n    if (self.options.output) {\n      console.error('\\n' + Logger.colors.light_red('Error retrieving a new session from the selenium server'));\n    }\n\n    if (typeof data == 'object' && Object.keys(data).length === 0) {\n      data = '';\n    }\n\n    if (!data && err) {\n      data = err;\n    }\n\n    self.emit('error', data);\n  })\n  .send();\n\n  return this;\n};\n\nNightwatch.prototype.followRedirect = function (request, response) {\n  if (!response.headers || !response.headers.location) {\n    this.emit('error', null, null);\n    return this;\n  }\n  var url = require('url');\n  var urlParts = url.parse(response.headers.location);\n  request.setOptions({\n    path   : urlParts.pathname,\n    host   : urlParts.hostname,\n    port   : urlParts.port,\n    method : 'GET'\n  }).send();\n\n  return this;\n};\n\nexports = module.exports = {};\n\nexports.client = function(options) {\n  return new Nightwatch(options);\n};\n\nexports.cli = function(runTests) {\n  var cli = require('./runner/cli/cli.js');\n  cli.setup();\n\n  var argv = cli.init();\n  if (argv.help) {\n    cli.showHelp();\n  } else if (argv.version) {\n    var packageConfig = require(__dirname + '/../package.json');\n    console.log(packageConfig.name + ' v' + packageConfig.version);\n  } else {\n    if (typeof runTests != 'function') {\n      throw new Error('Supplied argument needs to be a function!');\n    }\n    runTests(argv);\n  }\n};\n\nexports.runner = function(argv, done, settings) {\n  var runner = exports.CliRunner(argv);\n  return runner.setup(settings, done).runTests(done);\n};\n\nexports.initGrunt = function(grunt) {\n  grunt.registerMultiTask('nightwatch', 'run nightwatch.', function() {\n    var done = this.async();\n    var options = this.options();\n    var settings = this.data && this.data.settings;\n    var argv = this.data && this.data.argv;\n\n    exports.cli(function(a) {\n      Object.keys(argv).forEach(function(key) {\n        if (key === 'env' && a['parallel-mode'] === true) {\n          return;\n        }\n        a[key] = argv[key];\n      });\n\n      if (a.test) {\n        a.test = path.resolve(a.test);\n      }\n\n      if (options.cwd) {\n        process.chdir(options.cwd);\n      }\n\n      exports.runner(a, done, settings);\n    });\n  });\n};\n\nexports.CliRunner = function(argv) {\n  var CliRunner = require('./runner/cli/clirunner.js');\n  return new CliRunner(argv);\n};\n\nexports.initClient = function(opts) {\n  var Manager = require('./runner/clientmanager.js');\n  var instance = new Manager();\n  return instance.init(opts);\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/http/request.js":"var util   = require('util');\nvar events = require('events');\nvar http   = require('http');\nvar https  = require('https');\nvar Logger = require('./../util/logger');\nvar format = util.format;\n\nmodule.exports = (function() {\n  var Settings = {\n    selenium_host  : 'localhost',\n    selenium_port  : 4444,\n    default_path   : '/wd/hub',\n    credentials    : null,\n    use_ssl        : false,\n    proxy          : null,\n    timeout        : 60000,\n    retry_attempts : 0\n  };\n\n  var DO_NOT_LOG_ERRORS = [\n    'Unable to locate element',\n    '{\"errorMessage\":\"Unable to find element',\n    'no such element'\n  ];\n\n  function HttpRequest(options) {\n    events.EventEmitter.call(this);\n    this.setOptions(options);\n  }\n\n  util.inherits(HttpRequest, events.EventEmitter);\n\n  HttpRequest.prototype.setOptions = function(options) {\n    this.data           = options.data && jsonStringify(options.data) || '';\n    this.contentLength  = this.data.length;\n    this.reqOptions     = this.createOptions(options);\n    this.hostname       = formatHostname(this.reqOptions.host, this.reqOptions.port);\n    this.request        = null;\n    this.timeout        = Settings.timeout;\n    this.retryAttempts  = Settings.retry_attempts;\n\n    return this;\n  };\n\n  HttpRequest.prototype.setPathPrefix = function(options) {\n    this.defaultPathPrefix = options.path && options.path.indexOf(Settings.default_path) === -1 ?\n      Settings.default_path : '';\n    return this;\n  };\n\n  HttpRequest.prototype.createOptions = function(options) {\n    this.setPathPrefix(options);\n\n    var reqOptions = {\n      path    : this.defaultPathPrefix + (options.path || ''),\n      host    : options.host || Settings.selenium_host,\n      port    : options.selenium_port || Settings.selenium_port,\n      method  : options.method || 'POST',\n      headers : {}\n    };\n    var requestMethod = reqOptions.method.toUpperCase();\n    if (options.sessionId) {\n      reqOptions.path = reqOptions.path.replace(':sessionId', options.sessionId);\n    }\n\n    if (requestMethod === 'GET') {\n      reqOptions.headers['Accept'] = 'application/json';\n    }\n\n    if (this.contentLength > 0) {\n      reqOptions.headers['Content-Type'] = 'application/json; charset=utf-8';\n    }\n\n    if (needsContentLengthHeader(requestMethod)) {\n      reqOptions.headers['Content-Length'] = this.contentLength;\n    }\n\n    if (Settings.credentials &&\n      Settings.credentials.username && Settings.credentials.key\n      ) {\n      var authHeader = new Buffer(Settings.credentials.username + ':' + Settings.credentials.key).toString('base64');\n      reqOptions.headers['Authorization'] = 'Basic ' + authHeader;\n    }\n\n    if (Settings.proxy) {\n      var ProxyAgent = require('proxy-agent');\n      var proxyUri = Settings.proxy;\n      reqOptions.agent = new ProxyAgent(proxyUri);\n    }\n\n    return reqOptions;\n  };\n\n  HttpRequest.prototype.send = function() {\n    var self = this;\n    var startTime = new Date();\n    var isAborted = false;\n\n    this.request = (Settings.use_ssl ? https: http).request(this.reqOptions, function (response) {\n      response.setEncoding('utf8');\n      var redirected = false;\n      if (isRedirect(response.statusCode)) {\n        redirected = true;\n      }\n\n      var flushed = '';\n      response.on('data', function (chunk) {\n        if (self.reqOptions.method !== 'HEAD') {\n          flushed += chunk;\n        }\n      });\n\n      response.on('end', function () {\n        var elapsedTime = new Date() - startTime;\n        var screenshotContent;\n        var result, errorMessage = '';\n        if (flushed) {\n          result = parseResult(flushed);\n          if (result.value) {\n            if (result.value.screen) {\n              screenshotContent = result.value.screen;\n              delete result.value.screen;\n            }\n\n            if (result.value.stackTrace) {\n              // Selenium stack traces won't help us here and they will pollute the output\n              delete result.value.stackTrace;\n            }\n\n            if (needsFormattedErrorMessage(result)) {\n              errorMessage = formatErrorMessage(result.value);\n              delete result.value.localizedMessage;\n              delete result.value.message;\n            }\n          }\n        } else {\n          result = {};\n        }\n\n        if (errorMessage !== '') {\n          console.log(Logger.colors.yellow('There was an error while executing the Selenium command') +\n            (!Logger.isEnabled() ? ' - enabling the --verbose option might offer more details.' : '')\n          );\n          console.log(errorMessage);\n        }\n\n        self.emit('beforeResult', result);\n\n        var base64Data;\n        if (result.suppressBase64Data) {\n          base64Data = result.value;\n          result.value = '';\n        }\n\n        var logMethod = response.statusCode.toString().indexOf('5') === 0 ? 'error' : 'info';\n        Logger[logMethod](util.format('Response %s %s %s (%sms) ', response.statusCode, self.reqOptions.method, self.hostname + self.reqOptions.path, elapsedTime), result);\n\n        if (result.suppressBase64Data) {\n          result.value = base64Data;\n        }\n\n        if (response.statusCode.toString().indexOf('2') === 0 || redirected) {\n          if (isAborted) {\n            return;\n          }\n          self.emit('success', result, response, redirected);\n        } else {\n          self.emit('error', result, response, screenshotContent);\n        }\n      });\n    });\n\n    this.request.on('error', function(response) {\n      self.emit('error', {}, response);\n    });\n\n    this.request.setTimeout(this.timeout, function() {\n      if (self.retryAttempts) {\n        self.request.socket.unref();\n        isAborted = true; // prevent emitting of the success event multiple times.\n        self.retryAttempts = self.retryAttempts - 1;\n        self.send();\n      } else {\n        self.request.abort();\n      }\n    });\n\n    Logger.info('Request: ' + this.reqOptions.method + ' ' + this.hostname + this.reqOptions.path,\n      '\\n - data: ', this.data, '\\n - headers: ', JSON.stringify(this.reqOptions.headers));\n\n    this.request.write(this.data);\n    this.request.end();\n\n    return this;\n  };\n\n  /**\n   *\n   * @param s\n   * @param emit_unicode\n   * @returns {string}\n   */\n  HttpRequest.JSON_stringify = function(s, emit_unicode) {\n    var json = JSON.stringify(s);\n    if (json) {\n      return emit_unicode ? json : json.replace(jsonRegex, jsonRegexReplace);\n    }\n  };\n\n  HttpRequest.setSeleniumPort = function(port) {\n    Settings.selenium_port = port;\n  };\n  HttpRequest.useSSL = function(value) {\n    Settings.use_ssl = value;\n  };\n  HttpRequest.setSeleniumHost = function(host) {\n    Settings.selenium_host = host;\n  };\n  HttpRequest.setCredentials = function(credentials) {\n    Settings.credentials = credentials;\n  };\n  HttpRequest.setProxy = function(proxy) {\n    Settings.proxy = proxy;\n  };\n  HttpRequest.setDefaultPathPrefix = function(path) {\n    Settings.default_path = path;\n  };\n  HttpRequest.setTimeout = function(timeout) {\n    Settings.timeout = timeout;\n  };\n  HttpRequest.setRetryAttempts = function(retryAttempts) {\n    Settings.retry_attempts = retryAttempts;\n  };\n\n  ///////////////////////////////////////////////////////////\n  // Helpers\n  ///////////////////////////////////////////////////////////\n  var jsonRegex = new RegExp('[\\\\u007f-\\\\uffff]', 'g');\n  var jsonRegexReplace = function(c) {\n    return '\\\\u'+('0000'+c.charCodeAt(0).toString(16)).slice(-4);\n  };\n\n  /**\n   * Built in JSON.stringify() will return unicode characters that require UTF-8 encoding on the wire.\n   * This function will replace unicode characters with their escaped (ASCII-safe) equivalents to support\n   * the keys sending command.\n   *\n   * @param {object} s\n   * @returns {string}\n   */\n  function jsonStringify(s) {\n    var json = JSON.stringify(s);\n    if (json) {\n      return json.replace(jsonRegex, jsonRegexReplace);\n    }\n\n    return json;\n  }\n\n  function formatHostname(hostname, port) {\n    var isLocalHost = ['127.0.0.1', 'localhost'].indexOf(hostname) > -1;\n    var protocol = Settings.use_ssl ? 'https://' : 'http://';\n    var isPortDefault = [80, 443].indexOf(port) > -1;\n    if (isLocalHost) {\n      return '';\n    }\n    return protocol + hostname + (!isPortDefault && (':' + port) || '');\n  }\n\n  function isRedirect(statusCode) {\n    return [302, 303, 304].indexOf(statusCode) > -1;\n  }\n\n  function needsContentLengthHeader(requestMethod) {\n    return ['POST', 'DELETE'].indexOf(requestMethod) > -1;\n  }\n\n  function needsFormattedErrorMessage(result) {\n    return !!(result.localizedMessage || result.message);\n  }\n\n  function hasLocalizedMessage(result) {\n    return !!result.localizedMessage;\n  }\n\n  function formatErrorMessage(info) {\n    var msg = hasLocalizedMessage(info) ? info.localizedMessage : info.message;\n    if (shouldLogErrorMessage(msg)) {\n      msg = msg.replace(/\\n/g, '\\n\\t');\n    }\n    return msg;\n  }\n\n  function parseResult(data) {\n    var result;\n    data = stripUnknownChars(data);\n\n    try {\n      result = JSON.parse(data);\n    } catch (err) {\n      console.log(Logger.colors.red('Error processing the server response:'), '\\n', data);\n      result = {value: -1, error: err.message};\n    }\n    return result;\n  }\n\n  function shouldLogErrorMessage(msg) {\n    return !DO_NOT_LOG_ERRORS.some(function(item) {\n      return msg.indexOf(item) === 0;\n    });\n  }\n\n  function stripUnknownChars(str) {\n    var x = [], i = 0, length = str.length;\n\n    for (i; i < length; i++) {\n      if (str.charCodeAt(i)) {\n        x.push(str.charAt(i));\n      }\n    }\n    return x.join('');\n  }\n\n  return HttpRequest;\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/util/logger.js":"var util = require('util');\nvar Settings = {\n  log_timestamp : false,\n  colors : true,\n  enabled : true\n};\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n  'Oct', 'Nov', 'Dec'];\n\nfunction getDate() {\n  var now = new Date();\n  return [now.toLocaleDateString(), now.toLocaleTimeString()].join(' ');\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n    pad(d.getMinutes()),\n    pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nfunction getPrefix(tag, severity) {\n  var levels = ['EMERG', 'ALERT', 'CRITICAL', 'ERROR', 'WARNING', 'NOTICE', 'INFO', 'DEBUG'];\n  return tag + ' ' + levels[severity] +' - ';\n}\n\nfunction ConsoleColor() {\n  var self = this;\n  var mappings = {\n    blue  : '0;34',\n    light_blue  : '1;34'\n  };\n  this.background = new Background();\n\n  this.foreground_colors = {};\n  this.foreground_colors['black'] = '0;30';\n  this.foreground_colors['dark_gray'] = '1;30';\n  this.foreground_colors['blue'] = '0;34';\n  this.foreground_colors['light_blue'] = '1;34';\n  this.foreground_colors['green'] = '0;32';\n  this.foreground_colors['light_green'] = '1;32';\n  this.foreground_colors['cyan'] = '0;36';\n  this.foreground_colors['light_cyan'] = '1;36';\n  this.foreground_colors['red'] = '0;31';\n  this.foreground_colors['light_red'] = '1;31';\n  this.foreground_colors['purple'] = '0;35';\n  this.foreground_colors['light_purple'] = '1;35';\n  this.foreground_colors['brown'] = '0;33';\n  this.foreground_colors['yellow'] = '1;33';\n  this.foreground_colors['light_gray'] = '0;37';\n  this.foreground_colors['white'] = '1;37';\n  this.foreground_colors['stack_trace'] = '0;90';\n\n  this.background_colors = {};\n  this.background_colors['black'] = '40';\n  this.background_colors['red'] = '41';\n  this.background_colors['green'] = '42';\n  this.background_colors['yellow'] = '43';\n  this.background_colors['blue'] = '44';\n  this.background_colors['magenta'] = '45';\n  this.background_colors['cyan'] = '46';\n  this.background_colors['light_gray'] = '47';\n\n  Object.keys(this.foreground_colors).forEach(function(k) {\n    ConsoleColor.prototype[k.toLowerCase()] = function Foreground(text, background) {\n      var string = '\\033[' + self.foreground_colors[k.toLowerCase()] + 'm';\n      if (background !== undefined) {\n        string += background();\n      }\n\n      string += text + '\\033[0m';\n      return string;\n    };\n  });\n\n  Object.keys(this.background_colors).forEach(function(k) {\n    Background.prototype[k.toLowerCase()] = function Background(text) {\n      return '\\033[' + self.background_colors[k.toLowerCase()] + 'm';\n    };\n  });\n  return this;\n}\nfunction Background() { return this; }\n\nvar colors = new ConsoleColor();\nfunction logObject(obj) {\n  console.log(util.inspect(obj, {\n    showHidden : false,\n    depth : 3,\n    colors : Settings.colors\n  }));\n}\n\nfunction logTimestamp() {\n  if (Settings.log_timestamp) {\n    return colors.white(timestamp()) + ' ';\n  }\n  return '';\n}\n\nfunction logMessage(type, message, args) {\n  if (!message || !Settings.enabled) {\n    return;\n  }\n\n  var messageStr = '';\n  var timestamp = logTimestamp();\n  switch (type) {\n  case 'ERROR':\n    messageStr = colors.yellow(type, colors.background.dark_gray) +' '+\n                timestamp + colors.light_green(message);\n    break;\n  case 'INFO':\n    messageStr = colors.light_purple(type, colors.background.black) +' '+\n                timestamp + colors.light_cyan(message);\n    break;\n  case 'LOG':\n    messageStr = colors.white(type+' ', colors.background.black) +' '+\n                timestamp + colors.white(message);\n    break;\n  case 'WARN':\n    messageStr = colors.light_green(type, colors.background.black) +' '+\n                timestamp + colors.light_green(message);\n    break;\n  }\n\n  process.stdout.write(messageStr);\n\n  if (args.length > 0) {\n    var inlineArgs = [];\n    args.forEach(function(item) {\n      if (Object.prototype.toString.call(item) === '[object Object]' && Object.keys(item).length > 0) {\n        if (inlineArgs.length) {\n          console.log.apply(console, inlineArgs);\n          inlineArgs = [];\n        }\n        logObject(item);\n      } else {\n        inlineArgs.push(item);\n      }\n    });\n    if (inlineArgs.length) {\n      process.stdout.write(' ');\n      console.log.apply(console, inlineArgs);\n      inlineArgs = [];\n    }\n  } else {\n    process.stdout.write('\\n');\n  }\n}\n\nexports.info = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('INFO', message, args);\n};\n\nexports.log = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('LOG', message, args);\n};\n\nexports.warn = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('WARN', message, args);\n};\n\nexports.error = function(message) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  logMessage('ERROR', message, args);\n};\n\nexports.disableColors = function () {\n  Settings.colors = false;\n  Object.keys(ConsoleColor.prototype).forEach(function (color) {\n    ConsoleColor.prototype[color] = function (text) {\n      return text;\n    };\n  });\n};\n\nexports.disable = function() {\n  Settings.enabled = false;\n};\nexports.enable = function() {\n  Settings.enabled = true;\n};\nexports.isEnabled = function() {\n  return Settings.enabled;\n};\nexports.colors = colors;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/queue.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('./../util/logger.js');\n\nfunction AsyncTree() {\n  events.EventEmitter.call(this);\n  this.rootNode = {\n    name : '__root__',\n    children : [],\n    started : false,\n    done : false,\n    parent : this.rootNode\n  };\n  this.currentNode = this.rootNode;\n}\nutil.inherits(AsyncTree, events.EventEmitter);\n\nAsyncTree.prototype.append = function(nodeName, command, context, args, stackTrace) {\n  var node = {\n    startTime  : null,\n    name       : nodeName,\n    command    : command,\n    context    : context,\n    args       : args || [],\n    started    : false,\n    done       : false,\n    children   : [],\n    parent     : this.currentNode,\n    stackTrace : stackTrace\n  };\n\n  this.currentNode.children.push(node);\n\n  if (this.currentNode.started && !this.currentNode.done) {\n    this.scheduleTraverse(node);\n  }\n};\n\nAsyncTree.prototype.print = function(node, level) {\n  process.stdout.write(node.name + '\\n');\n  level = level || 1;\n  for (var i = 0; i < node.children.length; i++) {\n    var childNode = node.children[i];\n    for (var k = 0; k < level; k++) {\n      process.stdout.write(' |- ');\n    }\n    if (childNode.children.length) {\n      var levelUp = level + 1;\n      arguments.callee(childNode, levelUp);\n    } else {\n      process.stdout.write(childNode.name + '\\n');\n    }\n  }\n  process.stdout.write('');\n};\n\nAsyncTree.prototype.scheduleTraverse = function(node) {\n  if (this.scheduled) {\n    return this;\n  }\n  this.scheduled = true;\n  var self = this;\n  process.nextTick(function() {\n    self.scheduled = false;\n    self.traverse();\n  });\n};\n\nAsyncTree.prototype.traverse = function() {\n  this.emit('queue:started');\n  this.currentNode.started = true;\n\n  this.walkDown(this.currentNode);\n  return this;\n};\n\nAsyncTree.prototype.walkDown = function walkDown(context) {\n  var node = this.getNextChild(context);\n  if (node) {\n    this.runChildNode(node);\n  } else {\n    if (context.instance && !context.done) {\n      return;\n    }\n\n    this.currentNode.done = true;\n    if (this.currentNode.name === '__root__') {\n      this.done();\n    } else {\n      this.walkUp(context);\n    }\n  }\n};\n\nAsyncTree.prototype.walkUp = function(context) {\n  this.currentNode = context.parent;\n  this.walkDown(context.parent);\n};\n\nAsyncTree.prototype.getNextChild = function(context) {\n  for (var i = 0; i < context.children.length; i++) {\n    if (!context.children[i].started) {\n      var child = context.children[i];\n      context.children.splice(i, 1);\n      return child;\n    }\n  }\n  return false;\n};\n\nAsyncTree.prototype.runChildNode = function runChildNode(node) {\n  var self = this;\n\n  this.runCommand(node, function onCommandComplete() {\n    var timems = new Date().getTime() - node.startTime;\n    // checking if new children have been added while running this command which haven't finished yet\n    var childrenInProgress = false;\n    var currentChildNode = null;\n    for (var i = 0; i < node.children.length; i++) {\n      currentChildNode = node.children[i];\n      if (!currentChildNode.done) {\n        childrenInProgress = true;\n        break;\n      }\n    }\n\n    Logger.log('   ' + Logger.colors.green('') +\n      ' Completed command ' + Logger.colors.light_green(node.name), '(' + timems,  'ms)');\n    node.done = true;\n    if (!childrenInProgress) {\n      self.traverse();\n    }\n  });\n};\n\nAsyncTree.prototype.runCommand = function(node, callback) {\n  this.currentNode = node;\n  node.started = true;\n\n  try {\n    var commandFn = node.command;\n    if (typeof node.command !== 'function') {\n      // backwards compatibility\n      commandFn = node.command.command;\n    }\n\n    if (typeof commandFn !== 'function') {\n      throw new Error('Command must be a function');\n    }\n\n    node.startTime = new Date().getTime();\n    commandFn.prototype.constructor.stackTrace = node.stackTrace;\n\n    var instance = commandFn.apply(node.context, node.args);\n    if (instance instanceof events.EventEmitter) {\n      node.instance = instance;\n      instance.once('complete', callback);\n    }\n    return node.context;\n  } catch (err) {\n    err.stack = node.stackTrace;\n    err.name = 'Error while running ' + node.name + ' command';\n    this.emit('error', err);\n    return this;\n  }\n};\n\nAsyncTree.prototype.done = function() {\n  this.rootNode.started = false;\n  this.emit('queue:finished');\n  return this;\n};\n\nAsyncTree.prototype.empty = function() {\n  this.rootNode.children = [];\n  return this;\n};\n\nAsyncTree.prototype.reset = function() {\n  this.rootNode.started = false;\n  this.rootNode.done = false;\n  this.removeAllListeners();\n  this.currentNode = this.rootNode;\n  return this;\n};\n\nmodule.exports = new (function() {\n  var queue = new AsyncTree();\n\n  this.reset = function() {\n    queue.reset();\n  };\n\n  this.empty = function() {\n    queue.empty();\n  };\n\n  this.add = function() {\n    queue.append.apply(queue, arguments);\n  };\n\n  this.run = function queueRunner(callback) {\n    if (queue.rootNode.started) {\n      return queue;\n    }\n\n    if (callback) {\n      queue.once('queue:finished', function() {\n        callback(null);\n      })\n      .on('error', function(err) {\n        callback(err);\n      });\n    }\n\n    return queue.traverse();\n  };\n\n  this.done = function() {\n    queue.done();\n  };\n\n  this.instance = function instance() {\n    return queue;\n  };\n\n  this.list = function list() {\n    return queue.rootNode.children.map(function(item) {\n      return item.name;\n    });\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/assertion.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('./../util/logger.js');\nvar Utils = require('./../util/utils.js');\n\nmodule.exports = new (function() {\n  var doneSymbol = Utils.symbols.ok;\n  var failSymbol = Utils.symbols.fail;\n  var initialized = false;\n  var client;\n\n  /**\n   * Abstract assertion class that will subclass all defined assertions\n   *\n   * All assertions must implement the following api:\n   *\n   * - @type {boolean|function}\n   *   expected\n   * - @type {string}\n   *   message\n   * - @type {function}\n   *   pass\n   * - @type {function}\n   *   value\n   * - @type {function}\n   *   command\n   * - @type {function} - Optional\n   *   failure\n   *\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @constructor\n   */\n  function BaseAssertion(abortOnFailure, client) {\n    events.EventEmitter.call(this);\n    this.abortOnFailure = abortOnFailure;\n    this.client = client;\n    this.api = client.api;\n    this.startTime = new Date().getTime();\n    this.globals = this.api.globals || {};\n    this.timeout = this.globals.retryAssertionTimeout || 0; //ms\n    this.rescheduleInterval = this.globals.waitForConditionPollInterval || 500; //ms\n    this.shouldRetry = this.timeout > 0;\n  }\n\n  util.inherits(BaseAssertion, events.EventEmitter);\n\n  BaseAssertion.prototype.complete = function() {\n    var self = this, args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('complete');\n\n    setImmediate(function() {\n      self.emit.apply(self, args);\n    });\n  };\n\n  /**\n   * Performs the command method\n   * @returns {*}\n   * @private\n   */\n  BaseAssertion.prototype._executeCommand = function() {\n    var self = this;\n    var methods = [\n      'expected',\n      'message',\n      ['pass'],\n      ['value'],\n      ['command']\n    ];\n    methods.forEach(function(method) {\n      if (Array.isArray(method)) {\n        var name = method[0];\n        if (typeof self[name] !== 'function') {\n          throw new Error('Assertion must implement method ' + name);\n        }\n      } else if (typeof self[method] == 'undefined') {\n        throw new Error('Assertion must implement method/property ' + method);\n      }\n    });\n\n    return this._scheduleAssertion();\n  };\n\n  BaseAssertion.prototype._scheduleAssertion = function() {\n    var self = this;\n    return this.command(function(result) {\n      var passed, value;\n\n      if (typeof self.failure == 'function' && self.failure(result)) {\n        passed = false;\n        value = null;\n      } else {\n        value = self.value(result);\n        passed = self.pass(value);\n      }\n\n      var timeSpent = new Date().getTime() - self.startTime;\n      if (!passed && timeSpent < self.timeout) {\n        return self._reschedule();\n      }\n\n      var expected = typeof self.expected == 'function' ? self.expected() : self.expected;\n      var message = self._getFullMessage(passed, timeSpent);\n\n      self.client.assertion(passed, value, expected, message, self.abortOnFailure, self._stackTrace);\n      self.emit('complete');\n    });\n  };\n\n  BaseAssertion.prototype._getFullMessage = function(passed, timeSpent) {\n    if ( !this.shouldRetry) {\n      return this.message;\n    }\n    var timeLogged = passed ? timeSpent : this.timeout;\n    return this.message + ' after ' + timeLogged + ' milliseconds.';\n  };\n\n  BaseAssertion.prototype._reschedule = function() {\n    setTimeout(function(){}, this.rescheduleInterval);\n    return this._scheduleAssertion();\n  };\n\n  /**\n   *\n   * @param {string} stackTrace\n   * @param {string|null} message\n   */\n  function buildStackTrace(stackTrace, message) {\n    var stackParts = stackTrace.split('\\n');\n    stackParts.shift();\n\n    if (message) {\n      stackParts.unshift(message);\n    }\n\n    return Utils.stackTraceFilter(stackParts);\n  }\n\n  /**\n   * Assertion factory that creates the assertion instances with the supplied assertion definition\n   *  and options\n   *\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @constructor\n   */\n  function AssertionInstance(assertionFn, abortOnFailure, client) {\n    this.abortOnFailure = abortOnFailure;\n    this.client = client;\n    this.assertionFn = assertionFn;\n  }\n\n  /**\n   * This will call the supplied constructor of the assertion, after calling the Base constructor\n   *  first with other arguments and then inherits the rest of the methods from BaseAssertion\n   *\n   * @param {function} constructor\n   * @param {Array} args\n   * @returns {*}\n   * @private\n   */\n  AssertionInstance.prototype._constructFromSuper = function(constructor, args) {\n    var self = this;\n    function F() {\n      BaseAssertion.apply(this, [self.abortOnFailure, self.client]);\n      return constructor.apply(this, args);\n    }\n\n    util.inherits(constructor, BaseAssertion);\n    F.prototype = constructor.prototype;\n    return new F();\n  };\n\n  AssertionInstance.prototype._commandFn = function commandFn() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var instance = this._constructFromSuper(this.assertionFn, args);\n    instance._stackTrace = commandFn.stackTrace;\n    return instance._executeCommand();\n  };\n\n  /**\n   * @public\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {Nightwatch} client\n   * @returns {AssertionInstance}\n   */\n  this.factory = function(assertionFn, abortOnFailure, client) {\n    return new AssertionInstance(assertionFn, abortOnFailure, client);\n  };\n\n\n  /**\n   * Performs an assertion\n   *\n   * @param {Boolean} passed\n   * @param {Object} receivedValue\n   * @param {Object} expectedValue\n   * @param {String} message\n   * @param {Boolean} abortOnFailure\n   * @param {String} originalStackTrace\n   */\n  this.assert = function assert(passed, receivedValue, expectedValue, message, abortOnFailure, originalStackTrace) {\n    if (!initialized) {\n      throw new Error('init must be called first.');\n    }\n\n    var failure = '';\n    var stacktrace = '';\n    var fullMsg = '';\n\n    if (passed) {\n      if (client.options.output && client.options.detailed_output) {\n        console.log(' ' + Logger.colors.green(doneSymbol) + ' ' + message);\n      }\n      client.results.passed++;\n    } else {\n      failure = 'Expected \"' + expectedValue + '\" but got: \"' + receivedValue + '\"';\n      var err = new Error();\n\n      err.name = message;\n      err.message = message + ' - ' + failure;\n\n      if (!originalStackTrace) {\n        Error.captureStackTrace(err, arguments.callee);\n        originalStackTrace = err.stack;\n      }\n\n      err.stack = buildStackTrace(originalStackTrace, client.options.start_session ? null : 'AssertionError: ' + message);\n\n      fullMsg = message;\n      if (client.options.output && client.options.detailed_output) {\n        var logged = ' ' + Logger.colors.red(failSymbol);\n        if (typeof expectedValue != 'undefined' && typeof receivedValue != 'undefined') {\n          fullMsg += ' ' + Logger.colors.white(' - expected ' + Logger.colors.green('\"' +\n                expectedValue + '\"')) + ' but got: ' + Logger.colors.red('\"' + receivedValue + '\"');\n        }\n        logged += ' ' + fullMsg;\n        console.log(logged);\n      }\n\n      stacktrace = err.stack;\n      if (client.options.output && client.options.detailed_output) {\n        var parts = stacktrace.split('\\n');\n        console.log(Logger.colors.stack_trace(parts.join('\\n')) + '\\n');\n      }\n\n      client.results.lastError = err;\n      client.results.failed++;\n    }\n\n    client.results.tests.push({\n      message : message,\n      stackTrace : stacktrace,\n      fullMsg : fullMsg,\n      failure : failure !== '' ? failure : false\n    });\n\n    if (!passed && abortOnFailure) {\n      client.terminate(true);\n    }\n  };\n\n  /**\n   * Initializer\n   *\n   * @param {Object} c Nightwatch client instance\n   */\n  this.init = function(c) {\n    client = c;\n    initialized = true;\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/util/utils.js":"var path = require('path');\nvar fs = require('fs');\nvar Util = module.exports = {};\nvar Logger = require('./logger.js');\n\nvar formatRegExp = /%[sdj%]/g;\nvar testSuiteNameRegxp = /(_|-|\\.)*([A-Z]*)/g;\nvar nameSeparatorRegxp = /(\\s|\\/)/;\n\nUtil.formatElapsedTime = function(timeMs, includeMs) {\n  var seconds = timeMs/1000;\n  return (seconds < 1 && timeMs + 'ms') ||\n    (seconds > 1 && seconds < 60 && (seconds + 's')) ||\n    (Math.floor(seconds/60) + 'm' + ' ' + Math.floor(seconds%60) + 's' + (includeMs ? (' / ' + timeMs + 'ms') : ''));\n};\n\n/**\n * Wrap a synchronous function, turning it into an async fn with a callback as\n * the last argument if necessary. `asyncArgCount` is the expected argument\n * count if `fn` is already asynchronous.\n *\n * @param {number} asyncArgCount\n * @param {function} fn\n * @param {object} [context]\n */\nUtil.makeFnAsync = function (asyncArgCount, fn, context) {\n  if (fn.length === asyncArgCount) {\n    return fn;\n  }\n\n  return function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var done = args.pop();\n    context = context || null;\n    fn.apply(context, args);\n    done();\n  };\n};\n\n/**\n * Waits a number of ms for a `done` callback to be invoked\n *\n * @param {function} done\n * @param {string} fnName\n * @param {number} timeMs\n * @param {function} [onCatch]\n * @param {function} [onTimerStarted]\n * @return {Function}\n */\nUtil.setCallbackTimeout = function(done, fnName, timeMs, onCatch, onTimerStarted) {\n  var timeout = setTimeout(function() {\n    if (onCatch) {\n      var err = new Error('done() callback timeout of '+ timeMs +' ms was reached while executing \"' + fnName + '\".' +\n        ' Make sure to call the done() callback when the operation finishes.');\n      onCatch(err, fnName, timeout);\n    }\n\n  }, timeMs);\n\n  if (onTimerStarted) {\n    onTimerStarted(timeout);\n  }\n\n  return function(ex) {\n    clearTimeout(timeout);\n    done(ex, true);\n  };\n};\n\nUtil.checkFunction = function(name, parent) {\n  return parent && (typeof parent[name] == 'function') && parent[name] || false;\n};\n\nUtil.getTestSuiteName = function(moduleName) {\n  var words;\n\n  moduleName = moduleName.replace(testSuiteNameRegxp, function(match, $0, $1, offset, string) {\n    if (!match) {\n      return '';\n    }\n    return (offset > 0 && (string.charAt(offset-1) !== ' ') ? ' ':'') + $1;\n  });\n\n  words = moduleName.split(nameSeparatorRegxp).map(function(word, index, matches) {\n    if (word == '/') {\n      return ' / ';\n    }\n    return word.charAt(0).toUpperCase() + word.substr(1);\n  });\n\n  return words.join('');\n};\n\n/**\n * A smaller version of util.format that doesn't support json and\n * if a placeholder is missing, it is omitted instead of appended\n *\n * @param f\n * @returns {string}\n */\nUtil.format = function format(f) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') {\n      return '%';\n    }\n    if (i >= len) {\n      return x;\n    }\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n      case '%d':\n        return Number(args[i++]);\n      default:\n        return x;\n    }\n  });\n};\n\nUtil.getScreenshotFileName = function(currentTest, is_error, screenshots_path) {\n  var prefix = currentTest.module + '/' + currentTest.name;\n  prefix = prefix.replace(/\\s/g, '-').replace(/\"|'/g, '');\n  prefix += is_error ? '_ERROR' : '_FAILED';\n\n  var d = new Date();\n  var dateParts = d.toString().replace(/:/g,'').split(' ');\n  dateParts.shift();\n  dateParts.pop();\n  var dateStamp = dateParts.join('-');\n\n  return path.resolve(path.join(screenshots_path, prefix + '_' + dateStamp + '.png'));\n};\n\nUtil.isObject = function(obj) {\n  return (typeof obj == 'object') && (obj !== null);\n};\n\nUtil.processAsyncQueue = function(concurrency, files, cb) {\n  var maxWorkers = Math.min(concurrency, files.length);\n  var queue = [];\n  var add = function(item) {\n    queue.push(item);\n  };\n\n  var workers = 0;\n  var index = 0;\n  var next = function() {\n    workers -= 1;\n    process();\n  };\n\n  for (var i = 0; i < files.length; i++) {\n    add(files[i]);\n  }\n\n  var process = function() {\n    while (workers < maxWorkers) {\n      workers += 1;\n\n      if (queue.length) {\n        var item = queue.shift();\n        cb(item, index++, next);\n      }\n    }\n  };\n\n  process();\n};\n\nUtil.getModuleKey = function(filePath, srcFolders, fullPaths) {\n  var modulePathParts = filePath.split(path.sep);\n  var diffInFolder = '';\n  var folder = '';\n  var parentFolder = '';\n  var moduleName = modulePathParts.pop();\n  filePath = modulePathParts.join(path.sep);\n\n  if (srcFolders) {\n    for (var i = 0; i < srcFolders.length; i++) {\n      folder = path.resolve(srcFolders[i]);\n      if (fullPaths.length > 1) {\n        parentFolder = folder.split(path.sep).pop();\n      }\n      if (filePath.indexOf(folder) === 0) {\n        diffInFolder = filePath.substring(folder.length + 1);\n        break;\n      }\n    }\n  }\n\n  return path.join(parentFolder, diffInFolder, moduleName);\n};\n\nUtil.showStackTraceWithHeadline = function(headline, stack, isErr) {\n  var logMethod = isErr ? 'error' : 'log';\n  var stackTrace;\n  console[logMethod](Logger.colors.red(headline));\n\n  if (Array.isArray(stack) && stack.length > 0) {\n    stackTrace = Util.stackTraceFilter(stack);\n  } else {\n    stackTrace = stack;\n  }\n\n  if (stack) {\n    console[logMethod](Logger.colors.stack_trace(stackTrace));\n  }\n};\n\nUtil.stackTraceFilter = function(parts) {\n  var stack = parts.reduce(function(list, line) {\n    if (contains(line, [\n        'node_modules',\n        '(node.js:',\n        '(events.js:'\n      ])) {\n        return list;\n      }\n\n    list.push(line);\n    return list;\n  }, []);\n\n  return stack.join('\\n');\n};\n\nvar indentRegex = /^/gm;\nUtil.showStackTrace = function(stack) {\n  var parts = stack.split('\\n');\n  var headline = parts.shift();\n\n  console.log(Logger.colors.red(headline.replace(indentRegex, '   ')));\n  if (parts.length > 0) {\n    var result = Util.stackTraceFilter(parts);\n    console.log(Logger.colors.stack_trace(result.replace(indentRegex, '   ')));\n  }\n};\n\nUtil.symbols = (function() {\n  var ok = String.fromCharCode(10004);\n  var fail = String.fromCharCode(10006);\n\n  if (process.platform === 'win32') {\n    ok = '\\u221A';\n    fail = '\\u00D7';\n  }\n\n  return {\n    ok: ok,\n    fail: fail\n  };\n})();\n\nUtil.isErrorObject = function(err) {\n  return err instanceof Error || Object.prototype.toString.call(err) === '[object Error]';\n};\n\n// util to replace deprecated fs.existsSync\nUtil.dirExistsSync = function (path) {\n  try {\n    return fs.statSync(path).isDirectory();\n  } catch (e) {\n    return false;\n  }\n};\n\nUtil.fileExistsSync = function (path) {\n  try {\n    return fs.statSync(path).isFile();\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction contains(str, text) {\n  if (Array.isArray(text)) {\n    for (var i = 0; i < text.length; i++) {\n      if (contains(str, text[i])) {\n        return true;\n      }\n    }\n  }\n\n  return str.indexOf(text) > -1;\n}","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/core/api.js":"/*!\n * Module dependencies.\n */\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar events = require('events');\nvar assertModule = require('assert');\nvar CommandQueue = require('./queue.js');\nvar Assertion = require('./assertion.js');\nvar Page = require('../page-object/page.js');\n\nmodule.exports = new (function() {\n\n  var client;\n  var custom_commands_path;\n  var custom_assertions_path;\n  var page_objects_path;\n  var assertOperators = {\n    ok : ['ok', 'ko'],\n    equal : ['==', '!='],\n    notEqual : ['!=', '=='],\n    deepEqual : ['deepEqual', 'not deepEqual'],\n    notDeepEqual : ['not deepEqual', 'deepEqual'],\n    strictEqual : ['===', '!=='],\n    notStrictEqual : ['!==', '==='],\n    throws : ['throws', 'doesNotThrow'],\n    doesNotThrow : ['doesNotThrow', 'throws'],\n    fail : 'fail',\n    ifError : 'ifError'\n  };\n\n  /////////////////////////////////////////////////////////////////////\n  // Assertions\n  /////////////////////////////////////////////////////////////////////\n  /**\n   * Extends the node.js assert module\n   *\n   * @param prop\n   * @param abortOnFailure\n   * @returns {Function}\n   */\n  function makeAssertion(prop, abortOnFailure) {\n    return function() {\n      var passed;\n      var expected = null;\n      var actual = null;\n      var lastArgument = arguments[arguments.length-1];\n      var isLastArgString = typeof lastArgument === 'string';\n      var message = isLastArgString &&\n        (arguments.length > 2 || typeof arguments[0] === 'boolean') &&\n        lastArgument || (typeof arguments[0] === 'function' && '[Function]');\n\n      var args = Array.prototype.slice.call(arguments, 0);\n\n      try {\n        assertModule[prop].apply(null, arguments);\n        passed = true;\n        message = 'Passed [' + prop + ']: ' + (message || getAssertMessage(prop, args, passed));\n      } catch (ex) {\n        passed = false;\n        message = 'Failed [' + prop + ']: ' + ('(' + ex.message + ')' || message || getAssertMessage(prop, args, passed));\n        actual = ex.actual;\n        expected = ex.expected;\n      }\n\n      return Assertion.assert(passed, actual, expected, message, abortOnFailure);\n    };\n  }\n\n  function getAssertMessage(prop, args, passed) {\n    if (!Array.isArray(assertOperators[prop])) {\n      return assertOperators[prop] || '';\n    }\n\n    var operator = passed ? assertOperators[prop][0] : assertOperators[prop][1];\n\n    if (args.length === 2) {\n      args.splice(1, 0, operator);\n    } else {\n      args.push(operator);\n    }\n    args = args.map(function(argument) {\n      if (argument && typeof argument == 'object') {\n        argument = util.inspect(argument);\n      }\n      return argument;\n    });\n    return args.join(' ');\n  }\n\n  /**\n   * Loads the available assertions\n   */\n  function loadAssertions(parent) {\n    parent = parent || client.api;\n    parent.assert = {};\n    if (client.options.start_session) {\n      parent.verify = {};\n    }\n    for (var prop in assertModule) {\n      if (assertModule.hasOwnProperty(prop)) {\n        parent.assert[prop] = (function(prop) {\n          return makeAssertion(prop, true);\n        })(prop);\n        if (client.options.start_session) {\n          parent.verify[prop] = (function (prop) {\n            return makeAssertion(prop, false);\n          })(prop);\n        }\n      }\n    }\n\n    if (client.options.start_session) {\n      var dirPath = path.join(__dirname, './../api/assertions/');\n\n      loadAssertionFiles(dirPath, parent.assert, true);\n      loadAssertionFiles(dirPath, parent.verify, false);\n    }\n  }\n\n  /**\n   * Create an instance of an assertion\n   *\n   * @param {string} commandName\n   * @param {function} assertionFn\n   * @param {boolean} abortOnFailure\n   * @param {object} parent\n   * @returns {AssertionInstance}\n   */\n  function createAssertion(commandName, assertionFn, abortOnFailure, parent) {\n    var assertion;\n    if (typeof assertionFn === 'object' && assertionFn.assertion) {\n      assertion = Assertion.factory(assertionFn.assertion, abortOnFailure, client);\n      addCommand(commandName, assertion._commandFn, assertion, parent);\n      return assertion;\n    }\n\n    // backwards compatibility\n    var module = loadCommandModule(assertionFn, client.api, {\n      abortOnFailure : abortOnFailure\n    });\n\n    addCommand(commandName, module.command, module.context, parent);\n    return assertion;\n  }\n\n  /**\n   * Loads the actual assertion files.\n   *\n   * @param {String} dirPath\n   * @param {Object} parent\n   * @param {Boolean} abortOnFailure\n   */\n  function loadAssertionFiles(dirPath, parent, abortOnFailure) {\n    var commandFiles = fs.readdirSync(dirPath);\n\n    for (var i = 0, len = commandFiles.length; i < len; i++) {\n      if (path.extname(commandFiles[i]) === '.js') {\n        var commandName = path.basename(commandFiles[i], '.js');\n        var assertionFn = require(path.join(dirPath, commandFiles[i]));\n        createAssertion(commandName, assertionFn, abortOnFailure, parent);\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  // Commands\n  /////////////////////////////////////////////////////////////////////\n  /**\n   * Loads selenium protocol actions\n   */\n  function loadProtocolActions(parent) {\n    parent = parent || client.api;\n    var protocol = require('./../api/protocol.js')(client);\n    var actions  = Object.keys(protocol);\n    actions.forEach(function(command) {\n      addCommand(command, protocol[command], client.api, parent);\n    });\n  }\n\n  /**\n   * Loads all the composite commands defined by nightwatch\n   */\n  function loadAllCommands(parent) {\n    loadElementCommands(parent);\n    loadClientCommands(parent);\n    loadCommandFiles(client.api, parent, true);\n  }\n\n  /**\n   * Loads the element composite commands defined by nightwatch\n   */\n  function loadElementCommands(parent) {\n    parent = parent || client.api;\n    var elementCommands = require('./../api/element-commands.js')(client);\n    var entries = Object.keys(elementCommands);\n    entries.forEach(function(command) {\n      addCommand(command, elementCommands[command], client.api, parent);\n    });\n  }\n\n  /**\n   * Loads all the client commands defined by nightwatch\n   */\n  function loadClientCommands(parent) {\n    parent = parent || client.api;\n    var clientCommands = require('./../api/client-commands.js')(client);\n    var entries = Object.keys(clientCommands);\n    entries.forEach(function(command) {\n      addCommand(command, clientCommands[command], client.api, parent, true);\n    });\n  }\n\n  /**\n   * Loads the external commands\n   */\n  function loadCommandFiles(context, parent, shouldLoadClientCommands) {\n    var relativePaths = ['./../api/element-commands/'];\n    if (shouldLoadClientCommands) {\n      relativePaths.push('./../api/client-commands/');\n    }\n\n    relativePaths.forEach(function(relativePath) {\n      var commandFiles = fs.readdirSync(path.join(__dirname, relativePath));\n      var commandName;\n      var commandModule;\n\n      for (var i = 0, len = commandFiles.length; i < len; i++) {\n        var ext = path.extname(commandFiles[i]);\n        commandName = path.basename(commandFiles[i], ext);\n        if (ext === '.js' && commandName.substr(0, 1) !== '_') {\n          commandModule = require(__dirname + relativePath + commandFiles[i]);\n          var m = loadCommandModule(commandModule, context);\n          addCommand(commandName, m.command, m.context, parent);\n        }\n      }\n    });\n  }\n\n  /**\n   * Loads a command module either specified as an object with a `command` method\n   * or specified as a function which will be instantiated (new function() {..})\n   *\n   * @param {object|function} module\n   * @param {object} context\n   * @param {object} [addt_props]\n   * @returns {{command: function, context: *}}\n   */\n  function loadCommandModule(module, context, addt_props, return_val) {\n    var m = {command: null, context: context};\n\n    function F() {\n      if (typeof module === 'object') {\n        events.EventEmitter.call(this);\n      }\n      if (addt_props) {\n        for (var prop in addt_props) {\n          if (addt_props.hasOwnProperty(prop)) {\n            this[prop] = addt_props[prop];\n          }\n        }\n      }\n      this.client = client;\n      this.api = client.api;\n      if (typeof module === 'function') {\n        module.call(this);\n      }\n    }\n\n    if (typeof module === 'object' && module.command) {\n      util.inherits(F, events.EventEmitter);\n      F.prototype.command = function() {\n        return module.command.apply(this, arguments);\n      };\n    } else if (typeof module === 'function') {\n      F.prototype = Object.create(module.prototype);\n      F.prototype.constructor = F;\n    }\n\n    m.command = function commandFn() {\n      var instance = new F();\n      if (typeof module === 'function') {\n        context = m.context = instance;\n      }\n      instance.command.prototype.constructor.stackTrace = commandFn.stackTrace;\n      instance.command.apply(context, arguments);\n      return context;\n    };\n\n    return m;\n  }\n\n  /**\n   * Loads custom commands defined by the user\n   * @param {string} [dirPath]\n   * @param {object} [parent]\n   */\n  function loadCustomCommands(dirPath, parent) {\n    if (!custom_commands_path && !dirPath) {\n      return;\n    }\n\n    dirPath = dirPath || custom_commands_path;\n    parent = parent || client.api;\n\n    if (Array.isArray(dirPath)) {\n      dirPath.forEach(function(folder) {\n        loadCustomCommands(folder, parent);\n      });\n      return;\n    }\n\n    var absPath = path.resolve(dirPath);\n    var commandFiles = fs.readdirSync(absPath);\n\n    commandFiles.forEach(function(file) {\n      var fullPath = path.join(absPath, file);\n      if (fs.lstatSync(fullPath).isDirectory()) {\n        parent[file] = parent[file] || {};\n        var pathFolder = path.join(dirPath, file);\n        loadCustomCommands(pathFolder, parent[file]);\n      } else if (path.extname(file) === '.js') {\n        var commandModule = require(fullPath);\n        var name = path.basename(file, '.js');\n\n        if (!commandModule) {\n          throw new Error('Module ' + file + 'should have a public method or function.');\n        }\n\n        var m = loadCommandModule(commandModule, client.api);\n        addCommand(name, m.command, m.context, parent, true);\n      }\n    });\n  }\n\n  /**\n   * Loads custom assertions, similarly to custom commands\n   * @param [folder]\n   */\n  function loadCustomAssertions(folder, parent) {\n    folder = folder || custom_assertions_path;\n    parent = parent || client.api;\n    if (!custom_assertions_path) {\n      return;\n    }\n\n    if (Array.isArray(folder)) {\n      folder.forEach(function(folderName) {\n        loadCustomAssertions(folderName, parent);\n      });\n      return;\n    }\n\n    loadCustomAssertionFolder(folder, parent);\n  }\n\n  function loadCustomAssertionFolder(folderName, parent) {\n    var absPath = path.resolve(folderName);\n    loadAssertionFiles(absPath, parent.assert, true);\n    loadAssertionFiles(absPath, parent.verify, false);\n  }\n\n  function loadExpectAssertions(parent) {\n    parent = parent || client.api;\n    var Expect = require('../api/expect.js')(client);\n    var assertions  = Object.keys(Expect);\n\n    try {\n      var chaiExpect = module.require('chai').expect;\n      parent.expect = function() {\n        return chaiExpect.apply(chaiExpect, arguments);\n      };\n    } catch (err) {\n      parent.expect = {};\n    }\n\n    assertions.forEach(function(assertion) {\n      parent.expect[assertion] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        var command = Expect[assertion].apply(parent, args);\n\n        function F(element) {\n          events.EventEmitter.call(this);\n          this.client = client;\n          this.element = element;\n        }\n        util.inherits(F, events.EventEmitter);\n        F.prototype.command = function commandFn() {\n          this.element._stackTrace = commandFn.stackTrace;\n          this.element.locate(this);\n          return this;\n        };\n\n        var instance = new F(command.element);\n        var err = new Error;\n        Error.captureStackTrace(err, arguments.callee);\n        CommandQueue.add(assertion, instance.command, instance, [], err.stack);\n\n        return command.expect;\n      };\n    });\n  }\n\n  /**\n   * Loads page object files\n   * @param {string} [dirPath]\n   */\n  function loadPageObjects(dirPath, parent) {\n    if (!page_objects_path && !dirPath) {\n      return;\n    }\n\n    dirPath = dirPath || page_objects_path;\n    client.api.page = client.api.page || {};\n    parent = parent || client.api.page;\n\n    if (Array.isArray(dirPath)) {\n      dirPath.forEach(function(folder) {\n        loadPageObjects(folder);\n      });\n      return;\n    }\n\n    var absPath = path.resolve(dirPath);\n    var pageFiles = fs.readdirSync(absPath);\n\n    pageFiles.forEach(function(file) {\n      var fullPath = path.join(absPath, file);\n      if (fs.lstatSync(fullPath).isDirectory()) {\n        parent[file] = parent[file] || {};\n        var pathFolder = path.join(dirPath, file);\n        loadPageObjects(pathFolder, parent[file]);\n      } else if (path.extname(file) === '.js') {\n        var pageName = path.basename(file, '.js');\n        var pageFnOrObject = require(path.join(absPath, file));\n        addPageObject(pageName, pageFnOrObject, client.api, parent);\n      }\n    });\n  }\n\n  /**\n   * Instantiates the page object class\n   * @param {String} name\n   * @param {Object} pageFnOrObject\n   * @param {Object} context\n   * @param {Object} parent\n   */\n  function addPageObject(name, pageFnOrObject, context, parent) {\n    parent[name] = function() {\n      var args = Array.prototype.slice.call(arguments);\n      args.unshift(context);\n\n      if (useEnhancedModel(pageFnOrObject)) {\n        var loadOntoPageObject = function(parent) {\n          if (client.options.start_session) {\n            loadElementCommands(parent);\n            loadCommandFiles(client.api, parent, false);\n            loadExpectAssertions(parent);\n            // Alias\n            parent.expect.section = parent.expect.element;\n          }\n          loadAssertions(parent);\n          loadCustomCommands(null, parent);\n          loadCustomAssertions(null, parent);\n          return parent;\n        };\n        pageFnOrObject.name = name;\n        return new Page(pageFnOrObject, loadOntoPageObject, context, client);\n      }\n\n      return new (function() {\n        if (typeof pageFnOrObject == 'function') {\n          return createPageObject(pageFnOrObject, args);\n        }\n\n        return pageFnOrObject;\n      })();\n    };\n  }\n\n  function useEnhancedModel(pageFnOrObject) {\n    return typeof pageFnOrObject == 'object' && (pageFnOrObject.elements || pageFnOrObject.sections);\n  }\n\n  /**\n   *\n   * @param pageFnOrObject\n   * @param args\n   * @returns {Object}\n   */\n  function createPageObject(pageFnOrObject, args) {\n    function PageObject() {\n      return pageFnOrObject.apply(this, args);\n    }\n    PageObject.prototype = pageFnOrObject.prototype;\n    return new PageObject();\n  }\n\n  /**\n   * Adds a command/assertion to the queue.\n   *\n   * @param {String} name\n   * @param {Object} command\n   * @param {Object} context\n   * @param {Object} [parent]\n   */\n  function addCommand(name, command, context, parent) {\n    parent = parent || client.api;\n    if (parent[name]) {\n      client.results.errors++;\n      var error = new Error('The command \"' + name + '\" is already defined!');\n      client.errors.push(error.stack);\n      throw error;\n    }\n    parent[name] = function commandFn() {\n      var args = Array.prototype.slice.call(arguments);\n\n      var originalStackTrace;\n      if (commandFn.stackTrace) {\n        originalStackTrace = commandFn.stackTrace;\n      } else {\n        var err = new Error;\n        Error.captureStackTrace(err, arguments.callee);\n        originalStackTrace = err.stack;\n      }\n\n      CommandQueue.add(name, command, context, args, originalStackTrace);\n      return client.api; // for chaining\n    };\n  }\n\n  /**\n   * Initialize the api\n   *\n   * @param {Object} c The nightwatch client instance\n   * @api public\n   */\n  this.init = function(c) {\n    client = c;\n    custom_commands_path = c.options.custom_commands_path;\n    custom_assertions_path = c.options.custom_assertions_path;\n    page_objects_path = c.options.page_objects_path;\n    return this;\n  };\n\n  /**\n   * Loads everything\n   */\n  this.load = function() {\n    if (client.options.start_session) {\n      loadProtocolActions();\n      loadAllCommands();\n      loadPageObjects();\n      loadExpectAssertions();\n    }\n    loadAssertions();\n    loadCustomCommands();\n    loadCustomAssertions();\n    return this;\n  };\n\n  this.addCommand = addCommand;\n  this.loadCustomCommands = loadCustomCommands;\n  this.loadCustomAssertions = loadCustomAssertions;\n  this.loadPageObjects = loadPageObjects;\n  this.createAssertion = createAssertion;\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/page.js":"var PageUtils = require('./page-utils.js');\nvar CommandWrapper = require('./command-wrapper.js');\n\n/**\n * Class that all pages subclass from\n *\n * @param {Object} options Page options defined in page object\n * @constructor\n */\nfunction Page(options, commandLoader, api, client) {\n  this.commandLoader = commandLoader;\n  this.api = api;\n  this.client = client;\n  this.name = options.name;\n  this.url = options.url;\n\n  PageUtils\n    .createProps(this, options.props || {})\n    .createElements(this, options.elements || {})\n    .createSections(this, options.sections || {})\n    .addCommands(this, options.commands || []);\n\n  CommandWrapper.addWrappedCommands(this, this.commandLoader);\n}\n\nPage.prototype = {\n  /**\n   * Returns the url passed as an argument (or null if no arguments are passed).\n   *  If the supplied url is a function, it invokes that function with the page as its context.\n   *\n   * @method getUrl\n   * @param {string} url\n   * @returns {string|null}\n   */\n  getUrl: function(url) {\n    if (typeof url === 'function') {\n      return url.call(this);\n    } else if (typeof url === 'string') {\n      return url;\n    }\n\n    return null;\n  },\n\n  /**\n   * This command is an alias to url and also a convenience method because when called without any arguments\n   *  it performs a call to .url() with passing the value of `url` property on the page object.\n   * Uses `url` protocol command.\n   *\n   * @method navigate\n   * @param {Object} [url=this.url] Url to navigate to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @returns {*}\n   */\n  navigate: function(url, callback) {\n    var goToUrl = this.getUrl(url || this.url);\n    if (goToUrl === null) {\n      throw new Error('Invalid URL: You must either add a url property to \"' +\n        this.name + '\" or provide a url as an argument');\n    }\n    this.api.url(goToUrl, callback);\n    return this;\n  }\n};\n\nmodule.exports = Page;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/page-utils.js":"module.exports = new (function() {\n  /**\n   * Returns the properties object passed as an argument (or null if no arguments are passed).\n   *  If the supplied properties argument is a function, it invokes that function with the page as its context.\n   *\n   * @method createProps\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object|Function} props Object or Function that returns an object\n   * @returns {null}\n   */\n  this.createProps = function(parent, props) {\n    parent.props = typeof props === 'function' ? props.call(parent) : props;\n\n    return this;\n  };\n\n  /**\n   * Assigns the `elements` property for a page or section object.\n   *  For each object in the passed array, it creates a new element object by instantiating Element with its options\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object|Array} elements Object or array of objects to become element objects\n   * @returns {null}\n   */\n  this.createElements = function(parent, elements) {\n    var Element = require('./element.js');\n    var elementObjects = {};\n    var el;\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function(els) {\n      Object.keys(els).forEach(function(e) {\n        el = typeof els[e] === 'string' ? { selector: els[e] } : els[e];\n        el.parent = parent;\n        el.name = e;\n        elementObjects[el.name] = new Element(el);\n      });\n    });\n\n    parent.elements = elementObjects;\n\n    return this;\n  };\n\n  /**\n   * Assigns the `section` property for a page or section object.\n   *  For each object in the passed array, it creates a new section object by instantiating Section with its options\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Array} sections Array of objects to become section objects\n   * @returns {null}\n   */\n  this.createSections = function(parent, sections) {\n    var Section = require('./section.js');\n    var sectionObjects = {};\n    var sec;\n\n    Object.keys(sections).forEach(function(s) {\n      sec = sections[s];\n      sec.parent = parent;\n      sec.name = s;\n      sectionObjects[sec.name] = new Section(sec);\n    });\n\n    parent.section = sectionObjects;\n\n    return this;\n  };\n\n  /**\n   * Mixes in the passed functions to the page or section object.\n   *\n   * @param {Page|Section} parent The page object or section instance\n   * @param {Object} command Array of commands that will be added to the age or section\n   * @returns {null}\n   */\n  this.addCommands = function(parent, commands) {\n    commands.forEach(function(m) {\n      Object.keys(m).forEach(function(k) {\n        parent[k] = m[k];\n      });\n    });\n\n    return this;\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/command-wrapper.js":"module.exports = new (function() {\n\n  /**\n   * Given an element name, returns that element object\n   *\n   * @param {Object} parent The parent page or section\n   * @param {string} elementName Name of element\n   * @returns {Object} The element object\n   */\n  function getElement(parent, elementName) {\n    elementName = elementName.substring(1);\n    if (!(elementName in parent.elements)) {\n      throw new Error(elementName + ' was not found in \"' + parent.name +\n        '\". Available elements: ' + Object.keys(parent.elements));\n    }\n    return parent.elements[elementName];\n  }\n\n  /**\n   * Given a section name, returns that section object\n   *\n   * @param {Object} parent The parent page or section\n   * @param {string} sectionName Name of section\n   * @returns {Object} The section object\n   */\n  function getSection(parent, sectionName) {\n    sectionName = sectionName.substring(1);\n    if (!(sectionName in parent.section)) {\n      throw new Error(sectionName + ' was not found in \"' + parent.name +\n        '\". Available sections: ' + Object.keys(parent.sections));\n    }\n    return parent.section[sectionName];\n  }\n\n  /**\n   * Calls use(Css|Xpath|Recursion) command\n   *\n   * Uses `useXpath`, `useCss`, and `useRecursion` commands.\n   *\n   * @param {Object} client The Nightwatch instance\n   * @param {string} desiredStrategy (css selector|xpath|recursion)\n   * @returns {null}\n   */\n  function setLocateStrategy(client, desiredStrategy) {\n    var methodMap = {\n      xpath : 'useXpath',\n      'css selector' : 'useCss',\n      recursion : 'useRecursion'\n    };\n\n    if (desiredStrategy in methodMap) {\n      client.api[methodMap[desiredStrategy]]();\n    }\n  }\n\n  /**\n   * Creates a closure that enables calling commands and assertions on the page or section.\n   * For all element commands and assertions, it fetches element's selector and locate strategy\n   *  For elements nested under sections, it sets 'recursion' as the locate strategy and passes as its first argument to the command an array of its ancestors + self\n   *  If the command or assertion is not on an element, it calls it with the untouched passed arguments\n   *\n   * @param {Object} parent The parent page or section\n   * @param {function} commandFn The actual command function\n   * @param {string} commandName The name of the command (\"click\", \"containsText\", etc)\n   * @param {Boolean} [isChaiAssertion]\n   * @returns {function}\n   */\n  function makeWrappedCommand(parent, commandFn, commandName, isChaiAssertion) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var prevLocateStrategy = parent.client.locateStrategy;\n      var elementCommand = isElementCommand(args);\n\n      if (elementCommand) {\n        var firstArg;\n        var desiredStrategy;\n        var callbackIndex;\n        var originalCallback;\n        var elementOrSectionName = args.shift();\n        var getter = (isChaiAssertion && commandName === 'section') ? getSection : getElement;\n        var elementOrSection = getter(parent, elementOrSectionName);\n        var ancestors = getAncestorsWithElement(elementOrSection);\n\n        if (ancestors.length === 1) {\n          firstArg = elementOrSection.selector;\n          desiredStrategy = elementOrSection.locateStrategy;\n        } else {\n          firstArg = ancestors;\n          desiredStrategy = 'recursion';\n        }\n\n        setLocateStrategy(parent.client, desiredStrategy);\n        args.unshift(firstArg);\n\n        // if a callback is being used with this command, wrap it in\n        // a function that allows us to restore the locate strategy\n        // to its original value before the callback is called\n\n        callbackIndex = findCallbackIndex(args);\n        if (callbackIndex !== -1) {\n          originalCallback = args[callbackIndex];\n\n          args[callbackIndex] = function callbackWrapper() {\n\n            // restore the locate strategy directly through client.locateStrategy.\n            // setLocateStrategy() can't be used since it uses the api commands\n            // which get added to the command queue and will not update the\n            // strategy in time for the callback which is getting immediately\n            // called after\n\n            parent.client.locateStrategy = prevLocateStrategy;\n            return originalCallback.apply(parent.client.api, arguments);\n          };\n        }\n      }\n\n      var c = commandFn.apply(parent.client, args);\n      if (elementCommand) {\n        setLocateStrategy(parent.client, prevLocateStrategy);\n      }\n      return (isChaiAssertion ? c : parent);\n    };\n  }\n\n  /**\n   *\n   * @param {Array} args\n   * @return {boolean}\n   */\n  function isElementCommand(args) {\n    return (args.length > 0) && (args[0].toString().indexOf('@') === 0);\n  }\n\n  /**\n   * Identifies the location of a callback function within an arguments array.\n   *\n   * @param {Array} args Arguments array in which to find the location of a callback.\n   * @returns {number} Index location of the callback in the args array. If not found, -1 is returned.\n   */\n  function findCallbackIndex(args) {\n\n    if (args.length === 0) {\n      return -1;\n    }\n\n    // callbacks will usually be the last argument. waitFor methods allow an additional\n    // message argument to follow the callback which will also need to be checked for.\n\n    // last argument\n\n    var index = args.length - 1;\n    if (typeof args[index] === 'function') {\n      return index;\n    }\n\n    // second to last argument (waitfor calls)\n\n    index--;\n    if (typeof args[index] === 'function') {\n      return index;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Retrieves an array of ancestors of the supplied element. The last element in the array is the element object itself\n   *\n   * @param {Object} element The element\n   * @returns {Array}\n   */\n  function getAncestorsWithElement(element) {\n    var elements = [];\n    function addElement(e) {\n      elements.unshift(e);\n      if (e.parent && e.parent.selector) {\n        addElement(e.parent);\n      }\n    }\n    addElement(element);\n    return elements;\n  }\n\n  /**\n   * Adds commands (elements commands, assertions, etc) to the page or section\n   *\n   * @param {Object} parent The parent page or section\n   * @param {Object} target What the command is added to (parent|section or assertion object on parent|section)\n   * @param {Object} commands\n   * @returns {null}\n   */\n  function applyCommandsToTarget(parent, target, commands) {\n\n    Object.keys(commands).forEach(function(commandName) {\n      if (isValidAssertion(commandName)) {\n        target[commandName] = target[commandName] || {};\n\n        var isChaiAssertion = commandName === 'expect';\n        var assertions = commands[commandName];\n\n        Object.keys(assertions).forEach(function(assertionName) {\n          target[commandName][assertionName] = addCommand(target[commandName], assertions[assertionName], assertionName, parent, isChaiAssertion);\n        });\n      } else {\n        target[commandName] = addCommand(target, commands[commandName], commandName, parent, false);\n      }\n    });\n  }\n\n  function addCommand(target, commandFn, commandName, parent, isChaiAssertion) {\n    if (target[commandName]) {\n      parent.client.results.errors++;\n      var error = new Error('The command \"' + commandName + '\" is already defined!');\n      parent.client.errors.push(error.stack);\n      throw error;\n    }\n\n    return makeWrappedCommand(parent, commandFn, commandName, isChaiAssertion);\n  }\n\n  function isValidAssertion(commandName) {\n    return ['assert', 'verify', 'expect'].indexOf(commandName) > -1;\n  }\n\n  /**\n   * Entrypoint to add commands (elements commands, assertions, etc) to the page or section\n   *\n   * @param {Object} parent The parent page or section\n   * @param {function} commandLoader function that retrieves commands\n   * @returns {null}\n   */\n  this.addWrappedCommands = function (parent, commandLoader) {\n    var commands = {};\n    commands = commandLoader(commands);\n    applyCommandsToTarget(parent, parent, commands);\n  };\n\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/index.js":"module.exports = process.env.NIGHTWATCH_COV ?\n  require('./lib-cov/index') :\n  require('./lib/index');\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/bin/runner.js":"/**\n * Module dependencies\n */\nvar Nightwatch = require('../lib/index.js');\nvar Utils = require('../lib/util/utils.js');\n\ntry {\n  Nightwatch.cli(function(argv) {\n    argv._source = argv['_'].slice(0);\n    Nightwatch.runner(argv);\n  });\n} catch (ex) {\n  Utils.showStackTraceWithHeadline('There was an error while starting the test runner:\\n', ex.stack + '\\n', true);\n  process.exit(2);\n}\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/cli/cli.js":"/**\n * Module dependencies\n */\nvar opt = require('optimist');\n\nmodule.exports = new (function() {\n\n  var _DEFAULTS_ = {};\n  var _COMMANDS_ = {};\n\n  function Command(name) {\n    this.name = name;\n    _DEFAULTS_[this.name] = {};\n  }\n\n  Command.prototype.demand = function(value) {\n    if (!value && _DEFAULTS_[this.name].demand) {\n      return _DEFAULTS_[this.name].demand;\n    }\n    _DEFAULTS_[this.name].demand = value;\n    return this;\n  };\n\n  Command.prototype.description = function(value) {\n    if (!value && _DEFAULTS_[this.name].description) {\n      return _DEFAULTS_[this.name].alias;\n    }\n    _DEFAULTS_[this.name].description = value;\n    return this;\n  };\n\n  Command.prototype.alias = function(value) {\n    if (!value && _DEFAULTS_[this.name].alias) {\n      return _DEFAULTS_[this.name].alias;\n    }\n    _DEFAULTS_[this.name].alias = value;\n    return this;\n  };\n\n  Command.prototype.defaults = function(value) {\n    if (!value && _DEFAULTS_[this.name]['default']) {\n      return _DEFAULTS_[this.name]['default'];\n    }\n    _DEFAULTS_[this.name]['default'] = value;\n    return this;\n  };\n\n  Command.prototype.isDefault = function(value) {\n    return _DEFAULTS_[this.name]['default'] === value;\n  };\n\n\n  this.showHelp = function() {\n    return opt.showHelp();\n  };\n\n  this.command = function(name) {\n    if (_COMMANDS_[name]) {\n      return _COMMANDS_[name];\n    }\n    _COMMANDS_[name] = new Command(name);\n\n    return _COMMANDS_[name];\n  };\n\n  this.init = function() {\n    var argv = opt.usage('Usage: $0 [source] [options]')\n      .option('source', {\n        string : true\n      })\n      .options(_DEFAULTS_).argv;\n\n    return argv;\n  };\n\n  this.setup = function() {\n    // CLI definitions\n\n    // $ nightwatch -c\n    // $ nightwatch --config\n    this.command('config')\n      .demand(true)\n      .description('Path to configuration file')\n      .alias('c')\n      .defaults('./nightwatch.json');\n\n    // $ nightwatch -o\n    // $ nightwatch --output\n    this.command('output')\n      .description('Where to save the (JUnit XML) test reports.')\n      .alias('o')\n      .defaults('tests_output');\n\n    // $ nightwatch -r\n    // $ nightwatch --reporter\n    this.command('reporter')\n      .description('Name of a predefined reporter (e.g. junit) or path to a custom reporter file to use.')\n      .alias('r')\n      .defaults('junit');\n\n    // $ nightwatch -e\n    // $ nightwatch --env saucelabs\n    this.command('env')\n      .description('Testing environment to use.')\n      .alias('e')\n      .defaults('default');\n\n    // $ nightwatch --verbose\n    this.command('verbose')\n      .description('Turns on selenium command logging during the session.');\n\n    // $ nightwatch -t\n    // $ nightwatch --test\n    this.command('test')\n      .description('Runs a single test.')\n      .alias('t');\n\n    // $ nightwatch --testcase\n    this.command('testcase')\n      .description('Used only together with --test. Runs the specified testcase from the current suite/module.');\n\n    // $ nightwatch -g\n    // $ nightwatch --group\n    this.command('group')\n      .description('Runs a group of tests (i.e. a folder)')\n      .alias('g');\n\n    // $ nightwatch -s\n    // $ nightwatch --skipgroup\n    this.command('skipgroup')\n      .description('Skips one or several (comma separated) group of tests.')\n      .alias('s');\n\n    // $ nightwatch -f\n    // $ nightwatch --filter\n    this.command('filter')\n      .description('Specify a filter (glob expression) as the file name format to use when loading the files.')\n      .defaults('')\n      .alias('f');\n\n    // $ nightwatch -a\n    // $ nightwatch --tag\n    this.command('tag')\n      .description('Only run tests with the given tag.')\n      .defaults('')\n      .alias('a');\n\n    // $ nightwatch --skiptags\n    this.command('skiptags')\n      .description('Skips tests that have the specified tag or tags (comma separated).');\n\n    // $ nightwatch --retries\n    this.command('retries')\n      .description('Retries failed or errored testcases up <n> times.');\n\n    // $ nightwatch --suiteRetries\n    this.command('suiteRetries')\n      .description('Retries failed or errored testsuites up <n> times.');\n\n    // $ nightwatch -h\n    // $ nightwatch --help\n    this.command('help')\n      .description('Shows this help.')\n      .alias('h');\n\n    // $ nightwatch -v\n    // $ nightwatch --version\n    this.command('version')\n      .alias('v')\n      .description('Shows version information.');\n\n    return this;\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/cli/clirunner.js":"var fs = require('fs');\nvar path = require('path');\nvar Q = require('q');\nvar clone = require('lodash.clone');\nvar defaults = require('lodash.defaultsdeep');\n\nvar Runner = require('../run.js');\nvar Logger = require('../../util/logger.js');\nvar Utils = require('../../util/utils.js');\nvar Selenium = require('../selenium.js');\nvar ChildProcess = require('./child-process.js');\nvar ErrorHandler = require('./errorhandler.js');\n\nvar SETTINGS_DEPRECTED_VAL = './settings.json';\nvar SETTINGS_JS_FILE = './nightwatch.conf.js';\n\nfunction CliRunner(argv) {\n  this.settings = null;\n  this.argv = argv;\n  this.test_settings = null;\n  this.output_folder = '';\n  this.parallelMode = false;\n  this.runningProcesses = {};\n  this.cli = require('./cli.js');\n}\n\nCliRunner.prototype = {\n  /**\n   * @param {function} [done]\n   * @deprecated - use .setup instead\n   * @returns {CliRunner}\n   */\n  init : function(done) {\n    this\n      .readSettings()\n      .parseTestSettings({}, done);\n\n    return this;\n  },\n\n  /**\n   * @param {object} [settings]\n   * @param {function} [done]\n   * @returns {CliRunner}\n   */\n  setup : function(settings, done) {\n    this\n      .readSettings()\n      .parseTestSettings(settings, done);\n\n    return this;\n  },\n\n  /**\n   * Read the provided config json file; defaults to settings.json if one isn't provided\n   */\n  readSettings : function() {\n    // use default nightwatch.json file if we haven't received another value\n\n    if (this.cli.command('config').isDefault(this.argv.config)) {\n      var defaultValue = this.cli.command('config').defaults();\n      var localJsValue = path.resolve(SETTINGS_JS_FILE);\n\n      if (Utils.fileExistsSync(SETTINGS_JS_FILE)) {\n        this.argv.config = localJsValue;\n      } else if (Utils.fileExistsSync(defaultValue)) {\n        this.argv.config = path.join(path.resolve('./'), this.argv.config);\n      } else if (Utils.fileExistsSync(SETTINGS_DEPRECTED_VAL)) {\n        this.argv.config = path.join(path.resolve('./'), SETTINGS_DEPRECTED_VAL);\n      } else {\n        var binFolder = path.resolve(__dirname + '/../../../bin');\n        var defaultFile = path.join(binFolder, this.argv.config);\n        if (Utils.fileExistsSync(defaultFile)) {\n          this.argv.config = defaultFile;\n        } else {\n          this.argv.config = path.join(binFolder, SETTINGS_DEPRECTED_VAL);\n        }\n      }\n    } else {\n      this.argv.config = path.resolve(this.argv.config);\n    }\n\n    this.argv.env = typeof this.argv.env == 'string' ? this.argv.env : 'default';\n\n    // reading the settings file\n    try {\n      this.settings = require(this.argv.config);\n      this.replaceEnvVariables(this.settings);\n\n      this.manageSelenium = !this.isParallelMode() && this.settings.selenium &&\n        this.settings.selenium.start_process || false;\n\n      if (typeof this.settings.src_folders == 'string') {\n        this.settings.src_folders = [this.settings.src_folders];\n      }\n\n      this.settings.output = this.settings.output || typeof this.settings.output == 'undefined';\n      this.settings.detailed_output = this.settings.detailed_output || typeof this.settings.detailed_output == 'undefined';\n    } catch (ex) {\n      Logger.error(ex.stack);\n      this.settings = {};\n    }\n\n    return this;\n  },\n\n  /**\n   * Looks for pattern ${VAR_NAME} in settings\n   * @param {Object} [target]\n   */\n  replaceEnvVariables : function(target) {\n    for (var key in target) {\n      switch(typeof target[key]) {\n        case 'object':\n          this.replaceEnvVariables(target[key]);\n        break;\n        case 'string':\n          target[key] = target[key].replace(/\\$\\{(\\w+)\\}/g, function(match, varName) {\n            return process.env[varName] || '${' + varName + '}';\n          });\n        break;\n      }\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Reads globals from an external js or json file set in the settings file\n   * @return {CliRunner}\n   */\n  readExternalGlobals : function () {\n    if (!this.settings.globals_path) {\n      return this;\n    }\n\n    var fullPath = path.resolve(this.settings.globals_path);\n\n    try {\n      var externalGlobals = require(fullPath);\n\n      if (!externalGlobals) {\n        return this;\n      }\n\n      // if we already have globals, make a copy of them\n      var globals = this.test_settings.globals ? clone(this.test_settings.globals, true) : {};\n\n      if (externalGlobals.hasOwnProperty(this.argv.env)) {\n        for (var prop in externalGlobals[this.argv.env]) {\n          externalGlobals[prop] = externalGlobals[this.argv.env][prop];\n        }\n      }\n\n      defaults(globals, externalGlobals);\n      this.test_settings.globals = globals;\n\n      return this;\n    } catch (err) {\n      var originalMsg = Logger.colors.red(err.name + ': ' + err.message);\n\n      err.name = 'Error reading external global file failed';\n      err.message = 'using '+ fullPath + ':\\n' + originalMsg;\n\n      throw err;\n    }\n  },\n\n  /**\n   * @returns {CliRunner}\n   */\n  setOutputFolder : function() {\n    var isDisabled = this.settings.output_folder === false && typeof(this.test_settings.output_folder) == 'undefined' ||\n      this.test_settings.output_folder === false;\n    var isDefault = this.cli.command('output').isDefault(this.argv.output);\n    var folder = this.test_settings.output_folder || this.settings.output_folder;\n\n    this.output_folder = isDisabled ? false : (isDefault && folder || this.argv.output);\n\n    return this;\n  },\n\n  singleTestRun: function () {\n    return typeof this.argv.test == 'string';\n  },\n\n  singleSourceFile: function() {\n    if (this.singleTestRun()) {\n      return fs.statSync(this.argv.test).isFile();\n    }\n\n    return (Array.isArray(this.argv._source) && this.argv._source.length == 1) && fs.statSync(this.argv._source[0]).isFile();\n  },\n\n  getTestSourceForSingle: function(targetPath) {\n    var testsource;\n\n    if (targetPath && path.resolve(targetPath) === targetPath) {\n      testsource = targetPath;\n    } else {\n      testsource = path.join(process.cwd(), targetPath);\n    }\n\n    if (testsource.substr(-3) != '.js') {\n      testsource += '.js';\n    }\n\n    return testsource;\n  },\n\n  /**\n   * Returns the path where the tests are located\n   * @returns {*}\n   */\n  getTestSource : function() {\n    var testsource;\n\n    if (this.isTestWorker() || this.singleSourceFile()) {\n      testsource = this.getTestSourceForSingle(this.argv.test || this.argv._source[0]);\n    } else {\n      if (this.argv.testcase) {\n        this.argv.testcase = null;\n\n        if (this.test_settings.output) {\n          ErrorHandler.logWarning('Option --testcase used without --test is ignored.');\n        }\n      }\n\n      if (Array.isArray(this.argv._source) && (this.argv._source.length > 0)) {\n        testsource = this.argv._source;\n      } else if (this.argv.group) {\n\n        // add support for multiple groups\n        if (typeof this.argv.group == 'string') {\n          this.argv.group = this.argv.group.split(',');\n        }\n\n        var groupTestsource = this.findGroupPathMultiple(this.argv.group);\n\n        // If a group does not exist in the multiple src folder case, it is removed\n        // from the test path list.\n        if (this.settings.src_folders.length === 1) {\n\n          // any incorrect path here will result in a run error\n          testsource = groupTestsource;\n\n        } else {\n\n          // only when all groups fail to match will there be a run error\n          testsource = groupTestsource.filter(Utils.dirExistsSync);\n\n          if (this.argv.verbose) {\n            var ignoredSource = groupTestsource.filter(function(path) {\n              return testsource.indexOf(path) === -1;\n            });\n\n            if (ignoredSource.length) {\n              Logger.warn('The following group paths were not found and will be excluded from the run:\\n - ' + ignoredSource.join('\\n - '));\n            }\n          }\n        }\n\n      } else {\n        testsource = this.settings.src_folders;\n      }\n    }\n\n    return testsource;\n  },\n\n  /**\n   * Gets test paths from each of the src folders for a single group.\n   *\n   * @param {string} groupName\n   * @return {Array}\n   */\n  findGroupPath : function(groupName) {\n    var fullGroupPath = path.resolve(groupName);\n\n    // for each src folder, append the group to the path\n    // to resolve the full test path\n\n    return this.settings.src_folders.map(function(srcFolder) {\n\n      var fullSrcFolder = path.resolve(srcFolder);\n      if (fullGroupPath.indexOf(fullSrcFolder) === 0) {\n        return groupName;\n      }\n\n      return path.join(srcFolder, groupName);\n    });\n  },\n\n  /**\n   * Gets test paths for tests from any number of groups.\n   *\n   * @param {Array} groups\n   */\n  findGroupPathMultiple : function(groups) {\n    var paths = [];\n\n    groups.forEach(function(groupName) {\n\n      // findGroupPath will return an array of paths\n\n      paths = paths.concat(this.findGroupPath(groupName));\n\n    }.bind(this));\n\n    return paths;\n  },\n\n  /**\n   * Starts the selenium server process\n   * @param {function} [callback]\n   * @returns {CliRunner}\n   */\n  startSelenium : function(callback) {\n    callback = callback || function() {};\n\n    if (this.isTestWorker()) {\n      callback();\n      return this;\n    }\n\n    var globalsContext = this.test_settings && this.test_settings.globals || null;\n    // adding a link to the test_settings object on the globals context\n    if (globalsContext) {\n      globalsContext.test_settings = this.test_settings;\n    }\n\n    var beforeGlobal = Utils.checkFunction('before', globalsContext) || function(done) {done();};\n    var self = this;\n    if (!this.manageSelenium) {\n      beforeGlobal.call(globalsContext, function() {\n        callback();\n      });\n      return this;\n    }\n\n    this.settings.parallelMode = this.parallelMode;\n\n    beforeGlobal.call(globalsContext, function() {\n      Selenium.startServer(self.settings, function(error, child, error_out, exitcode) {\n        if (error) {\n          console.error('There was an error while starting the Selenium server:');\n          ErrorHandler.handle({\n            message : error_out\n          });\n\n          return;\n        }\n        callback();\n      });\n    });\n\n    return this;\n  },\n\n  /**\n   * Stops the selenium server if it is running\n   * @return {*|promise}\n   */\n  stopSelenium : function() {\n    var deferred = Q.defer();\n\n    if (this.manageSelenium) {\n      Selenium.stopServer(function() {\n        deferred.resolve();\n      });\n    } else {\n      deferred.resolve();\n    }\n\n    return deferred.promise;\n  },\n\n  /**\n   * Starts the test runner\n   *\n   * @param {function} [finished] optional callback\n   * @returns {CliRunner}\n   */\n  runTests : function(finished) {\n    if (this.parallelMode) {\n      return this;\n    }\n\n    var self = this;\n    var handleError = ErrorHandler.handle;\n\n    this.startSelenium(function() {\n\n      self.runner(function(err, results) {\n        self.stopSelenium().then(function() {\n          if (self.isTestWorker()) {\n            handleError(err, results, finished);\n            return;\n          }\n\n          self.runGlobalAfter().then(function (ex) {\n            handleError(ex || err, results, finished);\n          });\n        });\n      });\n    });\n\n    return this;\n  },\n\n  runner : function(fn) {\n    var testRunner = this.settings.test_runner || 'default';\n    var testRunnerType = testRunner.type ? testRunner.type : testRunner;\n\n    // getTestSource() will throw on an error, so we need\n    // to wrap and pass along any error that does occur\n    // to the callback fn\n\n    var source;\n    try {\n      source = this.getTestSource();\n    } catch (err) {\n      fn(err, {});\n      return;\n    }\n\n    switch (testRunnerType) {\n      case 'default':\n        var runner = new Runner(source, this.test_settings, {\n          output_folder : this.output_folder,\n          src_folders : this.settings.src_folders,\n          live_output : this.settings.live_output,\n          detailed_output : this.settings.detailed_output,\n          start_session: this.startSession,\n          reporter : this.argv.reporter,\n          testcase : this.argv.testcase,\n          end_session_on_fail : this.endSessionOnFail,\n          retries : this.argv.retries,\n          test_worker : this.isTestWorker(),\n          suite_retries : this.argv.suiteRetries\n        }, fn);\n        return runner.run();\n\n      case 'mocha':\n        var MochaNightwatch = require('mocha-nightwatch');\n        var mochaOpts = testRunner.options || {\n            ui : 'bdd'\n          };\n\n        var mocha = new MochaNightwatch(mochaOpts);\n        var nightwatch = require('../../index.js');\n\n        Runner.setFinishCallback(fn);\n        Runner.readPaths(source, this.test_settings, function(error, modulePaths) {\n          if (error) {\n            fn(error, {});\n            return;\n          }\n          modulePaths.forEach(function(file) {\n            mocha.addFile(file);\n          });\n\n          mocha.run(nightwatch, this.test_settings, function(failures) {\n            fn(null, {\n              failed : failures\n            });\n\n            if (failures) {\n              process.exit(10);\n            }\n          });\n\n        }.bind(this));\n\n        return mocha;\n    }\n  },\n\n  inheritFromDefaultEnv : function() {\n    if (this.argv.env == 'default') {\n      return;\n    }\n    var defaultEnv = this.settings.test_settings['default'] || {};\n    defaults(this.test_settings, defaultEnv);\n\n    return this;\n  },\n\n  runGlobalAfter : function() {\n    var deferred = Q.defer();\n\n    var globalsContext = this.test_settings && this.test_settings.globals || null;\n    var afterGlobal = Utils.checkFunction('after', globalsContext) || function(done) {done();};\n    try {\n      afterGlobal.call(globalsContext, function done() {\n        deferred.resolve(null);\n      });\n    } catch (ex) {\n      deferred.resolve(ex);\n    }\n\n    return deferred.promise;\n  },\n\n  /**\n   * Validates and parses the test settings\n   * @param {object} [settings]\n   * @param {function} [done]\n   * @returns {CliRunner}\n   */\n  parseTestSettings : function(settings, done) {\n    // checking if the env passed is valid\n    if (!this.settings.test_settings) {\n      throw new Error('No testing environment specified.');\n    }\n\n    var envs = this.argv.env.split(',');\n    for (var i = 0; i < envs.length; i++) {\n      if (!(envs[i] in this.settings.test_settings)) {\n        throw new Error('Invalid testing environment specified: ' + envs[i]);\n      }\n    }\n\n    if (envs.length > 1) {\n      this.setupParallelMode(envs, done);\n      return this;\n    }\n\n    this.initTestSettings(this.argv.env, settings);\n\n    if (this.parallelModeWorkers()) {\n      this.setupParallelMode(null, done);\n    }\n\n    return this;\n  },\n\n  setGlobalOutputOptions: function () {\n    this.test_settings.output = this.test_settings.output || (this.settings.output && typeof this.test_settings.output == 'undefined');\n    this.test_settings.silent = this.test_settings.silent || typeof this.test_settings.silent == 'undefined';\n    if (this.argv.verbose) {\n      this.test_settings.silent = false;\n    }\n\n    return this;\n  },\n\n  /**\n   * Sets the specific test settings for the specified environment\n   * @param {string} [env]\n   * @param {object} [settings]\n   * @returns {CliRunner}\n   */\n  initTestSettings : function(env, settings) {\n    // picking the environment specific test settings\n    this.test_settings = env && this.settings.test_settings[env] || {};\n\n    if (env) {\n      this.test_settings.custom_commands_path = this.settings.custom_commands_path || '';\n      this.test_settings.custom_assertions_path = this.settings.custom_assertions_path || '';\n      this.test_settings.page_objects_path = this.settings.page_objects_path || '';\n\n      this.inheritFromDefaultEnv();\n      this.updateTestSettings(settings || {});\n      this.readExternalGlobals();\n    }\n\n    this.setOutputFolder();\n    this.setGlobalOutputOptions();\n\n    if (typeof this.test_settings.test_workers != 'undefined') {\n      this.settings.test_workers = this.test_settings.test_workers;\n    } else if (typeof this.settings.test_workers != 'undefined') {\n      this.test_settings.test_workers = this.settings.test_workers;\n    }\n\n    if (typeof this.test_settings.test_runner != 'undefined') {\n      this.settings.test_runner = this.test_settings.test_runner;\n    }\n\n    if (typeof this.test_settings.detailed_output != 'undefined') {\n      this.settings.detailed_output = this.test_settings.detailed_output;\n    }\n\n    if (typeof this.argv.skipgroup == 'string') {\n      this.test_settings.skipgroup = this.argv.skipgroup.split(',');\n    }\n\n    if (this.argv.filter) {\n      this.test_settings.filename_filter = this.argv.filter;\n    }\n\n    if (this.argv.tag) {\n      this.test_settings.tag_filter = this.argv.tag;\n    }\n\n    if (typeof this.argv.skiptags == 'string') {\n      this.test_settings.skiptags = this.argv.skiptags.split(',');\n    }\n\n    return this;\n  },\n\n  /**\n   *\n   * @param {Object} [test_settings]\n   * @returns {CliRunner}\n   */\n  updateTestSettings : function(test_settings) {\n    if (this.parallelMode && !this.parallelModeWorkers()) {\n      return this;\n    }\n\n    if (test_settings && typeof test_settings == 'object') {\n      for (var key in test_settings) {\n        this.test_settings[key] = test_settings[key];\n      }\n    }\n\n    this.settings.selenium = this.settings.selenium || {};\n\n    // overwrite selenium settings per environment\n    if (Utils.isObject(this.test_settings.selenium)) {\n      for (var prop in this.test_settings.selenium) {\n        this.settings.selenium[prop] = this.test_settings.selenium[prop];\n      }\n    }\n\n    this.manageSelenium = !this.isParallelMode() && this.settings.selenium.start_process || false;\n    this.startSession = this.settings.selenium.start_session || typeof this.settings.selenium.start_session == 'undefined';\n\n    this.mergeSeleniumOptions();\n    this.disableCliColorsIfNeeded();\n\n    this.endSessionOnFail = typeof this.settings.end_session_on_fail == 'undefined' || this.settings.end_session_on_fail;\n    if (typeof this.test_settings.end_session_on_fail != 'undefined') {\n      this.endSessionOnFail = this.test_settings.end_session_on_fail;\n    }\n    return this;\n  },\n\n  disableCliColorsIfNeeded : function() {\n    if (this.settings.disable_colors || this.test_settings.disable_colors) {\n      Logger.disableColors();\n    }\n    return this;\n  },\n\n  /**\n   * Backwards compatible method which attempts to merge deprecated driver specific options for selenium\n   * @returns {CliRunner}\n   */\n  mergeSeleniumOptions : function() {\n    if (!this.manageSelenium) {\n      return this;\n    }\n    this.settings.selenium.cli_args = this.settings.selenium.cli_args || {};\n    this.mergeCliArgs();\n\n    var deprecationNotice = function(propertyName, newSettingName) {\n      ErrorHandler.logWarning('DEPRECATION NOTICE: Property ' + propertyName + ' is deprecated since v0.5. Please' +\n        ' use the \"cli_args\" object on the \"selenium\" property to define \"' + newSettingName + '\". E.g.:');\n      var demoObj = '{\\n' +\n        '  \"cli_args\": {\\n' +\n        '    \"'+ Logger.colors.yellow(newSettingName) +'\": \"<VALUE>\"\\n' +\n        '  }\\n' +\n        '}';\n\n      console.log(demoObj, '\\n');\n    };\n\n    if (this.test_settings.firefox_profile) {\n      deprecationNotice('firefox_profile', 'webdriver.firefox.profile');\n      this.settings.selenium.cli_args['webdriver.firefox.profile'] = this.test_settings.firefox_profile;\n    }\n    if (this.test_settings.chrome_driver) {\n      deprecationNotice('chrome_driver', 'webdriver.chrome.driver');\n      this.settings.selenium.cli_args['webdriver.chrome.driver'] = this.test_settings.chrome_driver;\n    }\n    if (this.test_settings.ie_driver) {\n      deprecationNotice('ie_driver', 'webdriver.ie.driver');\n      this.settings.selenium.cli_args['webdriver.ie.driver'] = this.test_settings.ie_driver;\n    }\n\n    return this;\n  },\n\n  /**\n   * Merge current environment specific cli_args into the main cli_args object to be passed to selenium\n   *\n   * @returns {CliRunner}\n   */\n  mergeCliArgs : function() {\n    if (Utils.isObject(this.test_settings.cli_args)) {\n      for (var prop in this.test_settings.cli_args) {\n        if (this.test_settings.cli_args.hasOwnProperty(prop)) {\n          this.settings.selenium.cli_args[prop] = this.test_settings.cli_args[prop];\n        }\n      }\n    }\n    return this;\n  },\n\n  ////////////////////////////////////////////////////////////////////////////////////\n  // Parallelism related\n  ////////////////////////////////////////////////////////////////////////////////////\n  isParallelMode : function() {\n    return process.env.__NIGHTWATCH_PARALLEL_MODE === '1';\n  },\n\n  isTestWorker : function() {\n    return this.isParallelMode() && this.argv['test-worker'];\n  },\n\n  parallelModeWorkers: function () {\n    return !this.isParallelMode() && !this.singleSourceFile() && (this.settings.test_workers === true ||\n      Utils.isObject(this.settings.test_workers) && this.settings.test_workers.enabled);\n  },\n\n  /**\n   * Enables parallel execution mode\n   * @param {Array} envs\n   * @param {function} [done]\n   * @returns {CliRunner}\n   */\n  setupParallelMode : function(envs, done) {\n    this.parallelMode = true;\n    var self = this;\n\n    this.startSelenium(function() {\n      self.startChildProcesses(envs, function(code) {\n        self.stopSelenium().then(function() {\n          if (self.parallelModeWorkers()) {\n            return self.runGlobalAfter();\n          }\n\n          return true;\n        }).then(function() {\n          if (done) {\n            try {\n              done(self.childProcessOutput, code);\n            } catch (err) {\n              done(err);\n            }\n          }\n\n          if (code) {\n            process.exit(code);\n          }\n        });\n\n      });\n    });\n\n    return this;\n  },\n\n  getAvailableColors : function () {\n    var availColors = [\n      ['red', 'light_gray'],\n      ['green', 'black'],\n      ['blue', 'light_gray'],\n      ['magenta', 'light_gray']\n    ];\n    var currentIndex = availColors.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      // And swap it with the current element.\n      temporaryValue = availColors[currentIndex];\n      availColors[currentIndex] = availColors[randomIndex];\n      availColors[randomIndex] = temporaryValue;\n    }\n    return availColors;\n  },\n\n  /**\n   * Start a new child process for each environment\n   * @param {Array} envs\n   * @param {function} doneCallback\n   */\n  startChildProcesses : function(envs, doneCallback) {\n    doneCallback = doneCallback || function() {};\n\n    var availColors = this.getAvailableColors();\n\n    this.childProcessOutput = {};\n    ChildProcess.prevIndex = 0;\n\n    var args = this.getChildProcessArgs(envs);\n\n    if (envs === null) {\n      this.startTestWorkers(availColors, args, doneCallback);\n      return this;\n    }\n\n    this.startEnvChildren(envs, availColors, args, doneCallback);\n  },\n\n  startEnvChildren : function(envs, availColors, args, doneCallback) {\n    var self = this;\n    var globalExitCode = 0;\n\n    envs.forEach(function(environment, index) {\n      self.childProcessOutput[environment] = [];\n      var childArgs = args.slice();\n      childArgs.push('--env', environment);\n\n      var child = new ChildProcess(environment, index, self.childProcessOutput[environment], self.settings, childArgs);\n      child.setLabel(environment + ' environment');\n      self.runningProcesses[child.itemKey] = child;\n      self.runningProcesses[child.itemKey].run(availColors, function(output, exitCode) {\n        if (exitCode > 0) {\n          globalExitCode = exitCode;\n        }\n        if (self.processesRunning() === 0) {\n          if (!self.settings.live_output) {\n            self.printChildProcessOutput();\n          }\n          doneCallback(globalExitCode);\n        }\n      });\n    });\n  },\n\n  getChildProcessArgs : function(envs) {\n    var childProcessArgs = [];\n    var arg;\n\n    for (var i = 2; i < process.argv.length; i++) {\n      arg = process.argv[i];\n      if (envs && (arg == '-e' || arg == '--env')) {\n        i++;\n      } else {\n        childProcessArgs.push(arg);\n      }\n    }\n\n    return childProcessArgs;\n  },\n\n  startTestWorkers : function(availColors, args, doneCallback) {\n    var workerCount = this.getTestWorkersCount();\n    var source = this.getTestSource();\n    var self = this;\n    var globalExitCode = 0;\n    var globalStartTime = new Date().getTime();\n    var globalResults = {\n      errmessages : [],\n      modules : {},\n      passed : 0,\n      failed : 0,\n      errors : 0,\n      skipped : 0,\n      tests : 0\n    };\n\n    var Reporter = require('../../runner/reporter.js');\n    var globalReporter = new Reporter(globalResults, {}, globalStartTime, {start_session: this.startSession});\n\n    Runner.readPaths(source, this.test_settings, function(error, modulePaths) {\n      if (error) {\n        ErrorHandler.handle(error, null, doneCallback);\n        return;\n      }\n\n      var remaining = modulePaths.length;\n      Utils.processAsyncQueue(workerCount, modulePaths, function(modulePath, index, next) {\n        var outputLabel = Utils.getModuleKey(modulePath, self.settings.src_folders, modulePaths);\n        var childOutput = self.childProcessOutput[outputLabel] = [];\n\n        // arguments to the new child process, essentially running a single test suite\n        var childArgs = args.slice();\n        childArgs.push('--test', modulePath, '--test-worker');\n\n        var settings = clone(self.settings);\n        settings.output = settings.output && settings.detailed_output;\n\n        var child = new ChildProcess(outputLabel, index, childOutput, settings, childArgs);\n        child.setLabel(outputLabel);\n        child.on('result', function(childResult) {\n          switch (childResult.type) {\n            case 'testsuite_finished':\n              globalResults.modules[childResult.moduleKey] = childResult.results;\n              if (childResult.errmessages.length) {\n                globalResults.errmessages.concat(childResult.errmessages);\n              }\n\n              globalResults.passed += childResult.passed;\n              globalResults.failed += childResult.failed;\n              globalResults.errors += childResult.errors;\n              globalResults.skipped += childResult.skipped;\n              globalResults.tests += childResult.tests;\n\n              self.printChildProcessOutput(childResult.itemKey);\n              break;\n            case 'testsuite_started':\n\n              break;\n          }\n\n        });\n\n        self.runningProcesses[child.itemKey] = child;\n        self.runningProcesses[child.itemKey].run(availColors, function (output, exitCode) {\n          if (exitCode > 0) {\n            globalExitCode = exitCode;\n          }\n          remaining -=1;\n          if (remaining > 0) {\n            next();\n          } else {\n\n            if (!self.settings.live_output) {\n              globalReporter.printTotalResults();\n            }\n\n            doneCallback(globalExitCode);\n          }\n        });\n      });\n    });\n  },\n\n  printChildProcessOutput : function(label) {\n    var self = this;\n\n    if (label) {\n      self.childProcessOutput[label] = self.childProcessOutput[label].filter(function(item) {\n        return item !== '';\n      }).map(function(item) {\n        if (item == '\\\\n') {\n          item = '\\n';\n        }\n\n        return item;\n      });\n\n      self.childProcessOutput[label].forEach(function(output) {\n        process.stdout.write(output + '\\n');\n      });\n\n      self.childProcessOutput[label].length = 0;\n      return;\n    }\n\n    Object.keys(this.childProcessOutput).forEach(function(environment) {\n      self.printChildProcessOutput(environment);\n    });\n  },\n\n  getTestWorkersCount : function() {\n    var workers = 1;\n    if (this.settings.test_workers === true || this.settings.test_workers.workers === 'auto') {\n      workers = require('os').cpus().length;\n    } else if ('number' === typeof this.settings.test_workers.workers) {\n      workers = this.settings.test_workers.workers;\n    }\n\n    return workers;\n  },\n\n  processesRunning : function() {\n    var running = 0;\n    for (var item in this.runningProcesses) {\n      if (this.runningProcesses.hasOwnProperty(item) && this.runningProcesses[item].processRunning) {\n        running += 1;\n      }\n    }\n    return running;\n  }\n};\n\nmodule.exports = CliRunner;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/run.js":"var Walk = require('./walk.js');\nvar TestSuite = require('./testsuite.js');\nvar Logger = require('../util/logger.js');\nvar Reporter = require('./reporter.js');\nvar path = require('path');\nvar Q = require('q');\n\nvar globalResults;\nvar currentTestSuite;\nvar finishCallback;\n\nfunction processListener() {\n  process.on('exit', function (code) {\n    var exitCode = code;\n\n    if (exitCode === 0 && globalResults && (globalResults.errors > 0 || globalResults.failed > 0)) {\n      exitCode = 1;\n    }\n\n    process.exit(exitCode);\n  });\n\n  process.on('uncaughtException', function (err) {\n    if (currentTestSuite) {\n      var testCase = currentTestSuite.getCurrentTestCase();\n      if (testCase/* && testCase.running*/) {\n        testCase.catchHandler(err);\n        return;\n      }\n    }\n\n    if (finishCallback) {\n      finishCallback(err);\n    } else {\n      console.log(err);\n    }\n  });\n}\n\nfunction Runner(testSource, opts, additionalOpts, doneCb) {\n  this.testSource = testSource || [];\n  this.options = opts;\n  this.additionalOpts = additionalOpts;\n  this.doneCb = doneCb || function() {};\n  this.globalStartTime = new Date().getTime();\n  this.currentTestSuite = null;\n  globalResults = this.globalResults = {\n    passed : 0,\n    failed : 0,\n    errors : 0,\n    skipped : 0,\n    tests : 0,\n    errmessages : [],\n    modules : {}\n  };\n\n  this.setOptions();\n}\n\nRunner.setFinishCallback = function(cb) {\n  finishCallback = cb;\n};\n\nRunner.prototype.setOptions = function() {\n  this.options.parallelMode = process.env.__NIGHTWATCH_PARALLEL_MODE == '1';\n  if (this.options.parallelMode) {\n    this.options.currentEnv = process.env.__NIGHTWATCH_ENV_KEY;\n  }\n  this.options.live_output = this.additionalOpts.live_output;\n  this.options.detailed_output = this.additionalOpts.detailed_output;\n  this.options.start_session = this.additionalOpts.start_session;\n  this.options.report_prefix = '';\n  this.options.test_worker = this.additionalOpts.test_worker;\n};\n\nRunner.prototype.runTestModule = function(modulePath, fullPaths) {\n  try {\n    currentTestSuite = this.currentTestSuite = new TestSuite(modulePath, fullPaths, this.options, this.additionalOpts, this.doneCb);\n  } catch (err) {\n    this.doneCb(err);\n    return null;\n  }\n\n  var moduleKey = this.currentTestSuite.getReportKey();\n\n  this.globalResults.modules[moduleKey] = {\n    completed : {},\n    skipped : null,\n    time : null,\n    timestamp : null,\n    group : this.currentTestSuite.getGroupName()\n  };\n\n  return this.currentTestSuite\n    .on('testcase:finished', function(results, errors, time) {\n      var tests = this.globalResults.modules[moduleKey].completed[this.currentTestSuite.currentTest] = {\n        passed  : results.passed,\n        failed  : results.failed,\n        errors  : results.errors,\n        skipped : results.skipped,\n        assertions  : [].concat(results.tests),\n        timeMs : time,\n        time : (time/1000).toPrecision(4),\n        stackTrace : results.stackTrace\n      };\n\n      if (Array.isArray(errors) && errors.length) {\n        this.globalResults.errmessages = this.globalResults.errmessages.concat(errors);\n      }\n\n      this.globalResults.passed += results.passed;\n      this.globalResults.failed += results.failed;\n      this.globalResults.errors += results.errors;\n      this.globalResults.skipped += results.skipped;\n      this.globalResults.tests += results.tests.length;\n\n      this.globalResults.assertions = this.globalResults.tests;\n\n      if (this.options.output && this.options.detailed_output &&\n        (this.options.modulesNo > 1 || results.tests !== this.globalResults.tests || results.steps.length > 1)\n      ) {\n        this.currentTestSuite.printResult(time);\n      } else if (this.options.output && !this.options.detailed_output) {\n\n        var error = (results.failed > 0 || results.errors > 0) ? new Error('') : null;\n        console.log(Reporter.getTestOutput(error, this.currentTestSuite.currentTest, time));\n\n        if (error !== null) {\n          Reporter.printAssertions(tests);\n        }\n      }\n\n    }.bind(this))\n    .run()\n    .then(function onTestSuiteResolved(testResults) {\n      var testSuiteResult = this.globalResults.modules[moduleKey];\n      testSuiteResult.skipped = testResults.steps;\n      testSuiteResult.timestamp = testResults.timestamp;\n      testSuiteResult.time = (testResults.time/1000).toPrecision(4);\n      testSuiteResult.tests = Object.keys(testSuiteResult.completed).length + (testSuiteResult.skipped && testSuiteResult.skipped.length || 0);\n\n      var failures = 0;\n      var errors = testResults.errors || 0;\n      Object.keys(testSuiteResult.completed).forEach(function(item) {\n        if (testSuiteResult.completed[item].failed > 0) {\n          failures++;\n        }\n      });\n\n      testSuiteResult.errmessages = testResults.errmessages || [];\n      testSuiteResult.failures = failures;\n      testSuiteResult.errors = errors;\n      if (typeof process.send == 'function') {\n        process.send(JSON.stringify({\n          type: 'testsuite_finished',\n          itemKey: process.env.__NIGHTWATCH_ENV_LABEL,\n          moduleKey: moduleKey,\n          results: this.globalResults.modules[moduleKey],\n          errmessages: testSuiteResult.errmessages,\n          passed: this.globalResults.passed,\n          failed: this.globalResults.failed,\n          errors: this.globalResults.errors,\n          skipped: this.globalResults.skipped,\n          tests: this.globalResults.tests\n        }));\n      }\n\n      return testResults;\n    }.bind(this));\n};\n\nRunner.readPaths = function(testSource, opts, cb) {\n  var deferred = Q.defer();\n  cb = cb || function() {};\n\n  if (typeof testSource == 'string') {\n    testSource = [testSource];\n  }\n\n  var fullPaths = testSource.map(function (p) {\n    if (p.indexOf(process.cwd()) === 0 || path.resolve(p) === p) {\n      return p;\n    }\n\n    return path.join(process.cwd(), p);\n  });\n\n  if (fullPaths.length === 0) {\n    throw new Error('No source folder defined. Check configuration.');\n  }\n\n  var errorMessage = ['No tests defined! using source folder:', fullPaths];\n  if (opts.tag_filter) {\n    errorMessage.push('; using tags:', opts.tag_filter);\n  }\n\n  Walk.readPaths(fullPaths, function (err, modules) {\n    if (err) {\n      if (err.code == 'ENOENT') {\n        var error = new Error('Cannot read source folder: ' + err.path);\n        cb(error, false);\n        deferred.reject(error);\n        return;\n      }\n      cb(err, false);\n      deferred.reject(err);\n      return;\n    }\n\n    opts.modulesNo = modules.length;\n\n    if (modules.length === 0) {\n      var error2 = new Error(errorMessage.join(' '));\n      cb(error2);\n      deferred.reject(error2);\n      return;\n    }\n\n    cb(null, modules, fullPaths);\n    deferred.resolve([modules, fullPaths]);\n  }, opts);\n\n  return deferred.promise;\n};\n\nRunner.prototype.run = function runner() {\n  var deferred = Q.defer();\n  var self = this;\n\n  finishCallback = this.doneCb;\n\n  Runner.readPaths(this.testSource, this.options)\n    .spread(function(modulePaths, fullPaths) {\n\n      (function runNextModule() {\n        var modulePath = modulePaths.shift();\n        var promise = self.runTestModule(modulePath, fullPaths);\n\n        if (promise === null) {\n          deferred.resolve();\n          return;\n        }\n\n        promise.then(function(testResults) {\n          if (modulePaths.length) {\n            setImmediate(runNextModule);\n          } else {\n            var reporter = new Reporter(self.globalResults, testResults, self.globalStartTime, {\n              output_folder : self.additionalOpts.output_folder,\n              filename_prefix : self.options.report_prefix,\n              globals : self.options.globals,\n              reporter : self.additionalOpts.reporter,\n              start_session : self.options.start_session\n            });\n\n            if (self.options.output) {\n              reporter.printTotalResults(self.globalResults, testResults);\n            }\n\n            reporter.save().then(function() {\n              reporter.globalReporter(self.options.globals)(self.globalResults, function() {\n                try {\n                  self.doneCb(null, self.globalResults);\n                  deferred.resolve(self.globalResults);\n                } catch (err) {\n                  deferred.reject(err);\n                }\n              });\n            }, function(err) {\n              console.log(Logger.colors.yellow('Output folder doesn\\'t exist and cannot be created.'));\n              console.log(err.stack);\n              self.doneCb(null);\n              deferred.resolve();\n            });\n          }\n        }, function(err) {\n          self.doneCb(err, self.globalResults);\n        }).catch(function(err) {\n          deferred.reject(err);\n        });\n      })();\n    })\n    .catch(function(err) {\n      self.doneCb(err, false);\n    })\n    .catch(function(err) {\n      deferred.reject(err);\n    });\n\n  return deferred.promise;\n};\n\nprocessListener();\n\nmodule.exports = Runner;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/walk.js":"var path = require('path');\nvar fs = require('fs');\nvar minimatch = require('minimatch');\nvar fileMatcher = require('./filematcher.js');\nvar Matchers = {};\n\nfunction isFolderExcluded(resource, opts) {\n  if (!opts.exclude) {\n    return false;\n  }\n\n  if (Matchers.exclude) {\n    return Matchers.exclude.some(function(item) {\n      if (item.indexOf(resource) === -1) {\n        return false;\n      }\n\n      try {\n        return fs.statSync(item).isDirectory();\n      } catch (err) {\n        return false;\n      }\n    });\n  }\n  return false;\n}\n\nfunction addMatcher(type, filePath, opts) {\n  Matchers[type] = Matchers[type] || [];\n  var matchers = fileMatcher[type].adaptFilePath(filePath, opts[type]);\n  if (Array.isArray(matchers)) {\n    Matchers[type].push.apply(Matchers[type], matchers);\n  } else {\n    Matchers[type].push(matchers);\n  }\n\n}\n\nfunction walk(dir, done, opts) {\n  var results = [];\n  fs.readdir(dir, function(err, list) {\n    if (err) {\n      return done(err);\n    }\n    var pending = list.length;\n\n    if (pending === 0) {\n      return done(null, results);\n    }\n\n    list.forEach(function(resource) {\n      resource = path.join(dir, resource);\n\n      fs.stat(resource, function(err, stat) {\n        if (stat && stat.isDirectory()) {\n          var dirName = resource.split(path.sep).slice(-1)[0];\n          var isExcluded = isFolderExcluded(resource, opts); // prevent loading of files from an excluded folder\n          var isSkipped = opts.skipgroup && opts.skipgroup.indexOf(dirName) > -1;\n\n          if (isExcluded || isSkipped) {\n            pending = pending-1;\n          } else {\n            walk(resource, function(err, res) {\n              results = results.concat(res);\n              pending = pending-1;\n              if (!pending) {\n                done(null, results);\n              }\n            }, opts);\n          }\n        } else {\n          results.push(resource);\n          pending = pending-1;\n\n          if (!pending) {\n            done(null, results);\n          }\n        }\n      });\n    });\n  });\n}\n\nmodule.exports = {\n  readPaths : function (paths, cb, opts) {\n    Matchers.exclude = [];\n    Matchers.filter = [];\n\n    var allmodules = [];\n    var extensionPattern = /\\.js$/;\n    var modulePaths = paths.slice(0);\n\n    (function readSourcePaths() {\n      var sourcePath = modulePaths.shift();\n      fs.stat(sourcePath, function(err, stat) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (stat.isFile() && extensionPattern.test(sourcePath)) {\n          sourcePath = sourcePath.replace(extensionPattern, '');\n          if (allmodules.indexOf(sourcePath) === -1) {\n            allmodules.push(sourcePath);\n          }\n\n          if (modulePaths.length) {\n            readSourcePaths();\n          } else {\n            cb(null, allmodules);\n          }\n        } else if (stat.isDirectory()) {\n          if (opts.exclude) {\n            addMatcher('exclude', sourcePath, opts);\n          }\n\n          if (opts.filter) {\n            addMatcher('filter', sourcePath, opts);\n          }\n\n          walk(sourcePath, function (err, list) {\n            if (err) {\n              return cb(err);\n            }\n            list.sort();\n\n            var modules = list.filter(function (filePath) {\n\n              if (!extensionPattern.test(filePath)) {\n                return false;\n              }\n              if (opts.exclude && fileMatcher.exclude.match(filePath, Matchers.exclude)) {\n                return false;\n              }\n\n              if (opts.filter && !fileMatcher.filter.match(filePath, Matchers.filter)) {\n                return false;\n              }\n\n              var filename = filePath.split(path.sep).slice(-1)[0];\n              if (opts.filename_filter) {\n                return minimatch(filename, opts.filename_filter);\n              }\n\n              if (opts.tag_filter || opts.skiptags) {\n                return fileMatcher.tags.match(filePath, opts);\n              }\n\n              return true;\n            });\n\n            modules.forEach(function(item) {\n              var filename = item.replace(extensionPattern, '');\n              if (allmodules.indexOf(filename) === -1) {\n                allmodules.push(filename);\n              }\n            });\n\n            if (modulePaths.length) {\n              readSourcePaths();\n            } else {\n              cb(null, allmodules);\n            }\n          }, opts);\n        } else {\n          if (modulePaths.length) {\n            readSourcePaths();\n          } else {\n            cb(null, allmodules);\n          }\n        }\n      });\n    })();\n  }\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/filematcher.js":"var path = require('path');\nvar minimatch = require('minimatch');\n\nfunction adaptFilePath(srcPath, excludedPath) {\n  var resolved = path.resolve(excludedPath);\n\n  if (resolved.indexOf(srcPath) === 0) {\n    return resolved;\n  }\n\n  if (excludedPath.charAt(excludedPath.length-1) === path.sep) {\n    excludedPath = excludedPath.substring(0, excludedPath.length-1);\n  }\n  return path.join(srcPath, excludedPath);\n}\n\nfunction matchFilePath(filePath, pathArr) {\n  for (var i = 0; i < pathArr.length; i++) {\n    if (minimatch(filePath, pathArr[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = {\n  tags: {\n    /**\n     * @param {string} testFilePath - file path of a test\n     * @param {object} opts - test options\n     * @returns {boolean} true if specified test matches given tag\n     */\n    match : function (testFilePath, opts) {\n      var test = require(testFilePath);\n      return this.checkModuleTags(test, opts);\n    },\n\n    /**\n     * @param {object} test - test module\n     * @param {object} opts - test options\n     * @returns {boolean}\n     */\n    checkModuleTags: function (test, opts) {\n      var moduleTags = test['@tags'] || test.tags;\n      var match = true;\n\n      if (!Array.isArray(moduleTags)) {\n        return typeof opts.tag_filter == 'undefined' && typeof opts.skiptags != 'undefined';\n      }\n\n      if (opts.tag_filter || opts.skiptags){\n        moduleTags = this.convertTagsToString(moduleTags);\n\n        if (opts.tag_filter) {\n          match = this.containsTag(moduleTags, this.convertTagsToString(opts.tag_filter));\n        }\n        if (opts.skiptags) {\n          match = this.excludesTag(moduleTags, this.convertTagsToString(opts.skiptags));\n        }\n      }\n\n      return match;\n    },\n\n    convertTagsToString : function(tags) {\n      return [].concat(tags).map(function (tag) {\n        return String(tag).toLowerCase();\n      });\n    },\n\n    containsTag : function(moduleTags, tags) {\n      return moduleTags.some(function (testTag) {\n        return (tags.indexOf(testTag) > -1);\n      });\n    },\n\n    excludesTag : function(moduleTags, tags) {\n      return moduleTags.every(function (testTag) {\n        return (tags.indexOf(testTag) == -1);\n      });\n    }\n  },\n\n  exclude : {\n    adaptFilePath : function(filePath, excludedPath) {\n      if (!Array.isArray(excludedPath)) {\n        excludedPath = [excludedPath];\n      }\n      return excludedPath.map(function(item) {\n        return adaptFilePath(filePath, item);\n      });\n    },\n    match : matchFilePath\n  },\n\n  filter : {\n    adaptFilePath : adaptFilePath,\n    match : matchFilePath\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/testsuite.js":"var path = require('path');\nvar util = require('util');\nvar events = require('events');\nvar Q = require('q');\nvar ClientManager = require('./clientmanager.js');\nvar Module = require('./module.js');\nvar TestCase = require('./testcase.js');\nvar Logger = require('../util/logger.js');\nvar Utils = require('../util/utils.js');\nvar DEFAULT_ASYNC_HOOK_TIMEOUT = 10000;\n\nfunction noop() {}\n\nfunction TestSuite(modulePath, fullPaths, opts, addtOpts) {\n  events.EventEmitter.call(this);\n\n  this['@testCase'] = null;\n  this.deferred = Q.defer();\n  this.module = new Module(modulePath, opts, addtOpts);\n  this.setTestResult();\n  this.currentTest = '';\n  this.module.setReportKey(fullPaths, addtOpts.src_folders);\n  this.options = opts;\n  this.testMaxRetries = addtOpts.retries || 0;\n  this.suiteMaxRetries = addtOpts.suite_retries || 0;\n  this.suiteRetries = 0;\n  this.suiteName = this.module.getTestSuiteName() || Utils.getTestSuiteName(this.module.moduleKey);\n\n  this.setupClient();\n\n  this.expectedAsyncArgs = this.options.compatible_testcase_support ? 1 : 2;\n  this.asyncHookTimeout = this.client.globals('asyncHookTimeout') || DEFAULT_ASYNC_HOOK_TIMEOUT;\n  this.currentHookTimeoutId = null;\n  this.initHooks();\n}\n\nutil.inherits(TestSuite, events.EventEmitter);\n\nTestSuite.prototype.setupClient = function() {\n  this.updateDesiredCapabilities();\n  this.client = new ClientManager();\n  var self = this;\n  this.client.on('error', function(err) {\n    self.deferred.reject(err);\n  });\n  this.client.init(this.options);\n  this.client.api('currentEnv', this.options.currentEnv);\n  this.module.set('client', this.client.api());\n  if (this.client.endSessionOnFail() && !this.module.endSessionOnFail()) {\n    this.client.endSessionOnFail(false);\n  }\n};\n\nTestSuite.prototype.initHooks = function() {\n  var self = this;\n  var context = this.module.get();\n  var argsCount;\n\n  this.hooks = {};\n\n  var hooks = ['before', 'after', ['beforeEach', 'setUp']];\n  hooks.forEach(function(item) {\n    var key;\n    if (Array.isArray(item)) {\n      key = item[0];\n    } else {\n      key = item;\n    }\n\n    var index = self.testResults.steps.indexOf(key);\n    if (index === -1 && Array.isArray(item)) {\n      index = self.testResults.steps.indexOf(item[1]);\n    }\n\n\n    if (Array.isArray(item) && (item.length == 3)) {\n      argsCount = item[2];\n    } else {\n      argsCount = self.expectedAsyncArgs;\n    }\n\n    self.hooks[key] = (function(item, argsCount) {\n      return function() {\n        return self.makePromise(function(done) {\n          var callbackDeffered = false;\n          var called = false;\n          var originalFn = self.module.get(key);\n\n          var doneFn = function() {\n            called = true;\n            if (callbackDeffered) {\n              return;\n            }\n            return done();\n          };\n\n          self.runHookMethod(item, context, argsCount, key, doneFn, this.deferred);\n\n          if (originalFn && (originalFn.length == self.expectedAsyncArgs) && self.client.shouldRestartQueue()) {\n            callbackDeffered = true;\n            var asyncDoneFn = function(err) {\n              if (called) {\n                done();\n              } else {\n                callbackDeffered = false;\n              }\n            };\n\n            if (key == 'before' || key == 'beforeEach') {\n              self.client.start(asyncDoneFn);\n            } else if (key == 'after') {\n              self.client.restartQueue(asyncDoneFn);\n            }\n\n          }\n        });\n      };\n    })(item, argsCount);\n\n    if (index > -1) {\n      self.testResults.steps.splice(index, 1);\n      self.module.removeKey(item);\n    }\n  });\n  this.initAfterEachHook();\n};\n\nTestSuite.prototype.initAfterEachHook = function() {\n  var self = this;\n  var api = this.client.api();\n  var module = this.module.get();\n  var key = 'afterEach';\n  var hookFn;\n  var index = self.testResults.steps.indexOf(key);\n\n  if (!module[key]) {\n    // backwards compatibility\n    key = 'tearDown';\n    index = self.testResults.steps.indexOf(key);\n  }\n\n  if (module[key]) {\n    hookFn = module[key];\n    if (index > -1) {\n      // not running with --testcase\n      self.testResults.steps.splice(index, 1);\n      self.module.removeKey(key);\n    }\n  } else {\n    hookFn = function() {};\n  }\n\n  var expectedArgs = hookFn.length;\n  this.hooks.afterEach = function(results, errors) {\n    self.module\n      .set('results', results)\n      .set('errors', errors);\n    var asyncFn, asyncArgsCount;\n    if (expectedArgs <= 1) {\n      asyncArgsCount = 1;\n    } else {\n      asyncArgsCount = 2;\n    }\n    asyncFn = Utils.makeFnAsync(asyncArgsCount, hookFn, module);\n    return self.makePromise(function(done, deferred) {\n      var doneFn = self.adaptDoneCallback(done, 'afterEach', deferred);\n      self.client.publishTestResults(self.currentTest, self.module.get('results'), errors);\n\n      if (expectedArgs < 2) {\n        // user has only supplied the done callback argument (pre v0.6 behaviour), e.g.:\n        // afterEach : function(done) { ... }\n        asyncFn.call(module, doneFn);\n      } else {\n        // user has supplied both the client and the done callback argument (v0.6 behaviour), e.g.:\n        // afterEach : function(browser, done) { ... }\n        // in which case we may need to restart the queue if any selenium related actions are added\n        if (self.options.compatible_testcase_support) {\n          asyncFn.call(module, doneFn);\n        } else {\n          asyncFn.call(module, api, function() {\n            doneFn();\n          });\n        }\n\n        // this will restart the queue if needed\n        self.client.checkQueue();\n      }\n    });\n  };\n  return this;\n};\n\nTestSuite.prototype.run = function() {\n  var self = this;\n  this.print();\n  if (this.module.isDisabled()) {\n    if (this.options.output) {\n      console.log(Logger.colors.cyan(this.module.getName()), 'module is disabled, skipping...');\n    }\n    this.deferred.resolve(this.testResults);\n  } else {\n    this.setCurrentTest();\n    this.globalBeforeEach()\n      .then(function() {\n        if (self.client.terminated() && self.client.skipTestcasesOnFail()) {\n          self.testResults.errmessages = self.client.errors();\n          self.deferred.resolve(self.testResults);\n          return null;\n        }\n        return self.runTestSuiteModule();\n      })\n\n      .then(function(results) {\n        return self.globalAfterEach();\n      })\n\n      .then(function() {\n        self.deferred.resolve(self.testResults);\n      })\n      .catch(function(e) {\n        self.deferred.reject(e);\n      });\n  }\n\n  return this.deferred.promise;\n};\n\nTestSuite.prototype.getCurrentTestCase = function() {\n  return this['@testCase'];\n};\n\nTestSuite.prototype.getReportKey = function() {\n  return this.module.moduleKey;\n};\n\nTestSuite.prototype.getGroupName = function() {\n  return this.module.groupName;\n};\n\nTestSuite.prototype.printResult = function(startTime) {\n  return this.client.print(startTime);\n};\n\nTestSuite.prototype.shouldRetrySuite = function() {\n  return this.suiteMaxRetries > this.suiteRetries && (this.testResults.failed > 0 || this.testResults.errors > 0);\n};\n\nTestSuite.prototype.setTestResult = function() {\n  this.testResults = {};\n  this.testResults.steps = this.module.keys.slice(0);\n  this.clearTestResult();\n  return this;\n};\n\nTestSuite.prototype.clearTestResult = function() {\n  this.testResults.passed = 0;\n  this.testResults.failed = 0;\n  this.testResults.errors = 0;\n  this.testResults.skipped = 0;\n  this.testResults.tests = 0;\n  this.testResults.testcases = {};\n  this.testResults.timestamp = new Date().toUTCString();\n  this.testResults.time = 0;\n  return this;\n};\n\nTestSuite.prototype.clearResult = function() {\n  this.clearTestResult();\n  this.client.clearGlobalResult();\n  return this;\n};\n\nTestSuite.prototype.printRetry = function() {\n  if (this.options.output) {\n    console.log('Retrying: ',\n      Logger.colors.red('[' + this.suiteName + '] Test Suite '),\n      '(' + this.suiteRetries + '/' + this.suiteMaxRetries + '): ');\n  }\n};\n\nTestSuite.prototype.retryTestSuiteModule = function() {\n  this.client.resetTerminated();\n  this.client.setLocateStrategy();\n  this.clearResult();\n  this.suiteRetries +=1;\n  this.resetTestCases();\n  this.printRetry();\n\n  return this.globalBeforeEach().then(function() {\n    return this.runTestSuiteModule();\n  }.bind(this));\n};\n\nTestSuite.prototype.runTestSuiteModule = function() {\n  var self = this;\n  return this.before()\n    .then(function() {\n      return self.runNextTestCase();\n    })\n    .then(function(skipped) {\n      return self.after();\n    })\n    .then(function() {\n      return self.client.checkQueue();\n    })\n    .then(function() {\n      return self.shouldRetrySuite();\n    })\n    .then(function(shouldRetrySuite) {\n      if (shouldRetrySuite) {\n        return self.globalAfterEach().then(function() {\n          return self.retryTestSuiteModule();\n        });\n      }\n    })\n    .catch(function(e) {\n      self.testResults.errors++;\n      throw e;\n    });\n};\n\nTestSuite.prototype.onTestCaseFinished = function(results, errors, time) {\n  this.testResults.time += time;\n  this.testResults.testcases[this.currentTest] = this.testResults.testcases[this.currentTest] || {};\n  this.testResults.testcases[this.currentTest].time = (time/1000).toPrecision(4);\n\n  this.emit('testcase:finished', results, errors, time);\n};\n\nTestSuite.prototype.resetTestCases = function() {\n  var self = this;\n  this.module.resetKeys();\n  Object.keys(this.hooks).forEach(function(hook) {\n    self.module.removeKey(hook);\n  });\n};\n\nTestSuite.prototype.setCurrentTest = function() {\n  var moduleKey = this.getReportKey();\n  this.client.clearGlobalResult();\n\n  this.client.api('currentTest', {\n    name : this.currentTest,\n    module : moduleKey.replace(path.sep , '/'),\n    results : this.testResults,\n    group : this.getGroupName()\n  });\n  return this;\n};\n\nTestSuite.prototype.runNextTestCase = function(deferred) {\n  this.currentTest = this.module.getNextKey();\n  this.setCurrentTest();\n\n  deferred = deferred || Q.defer();\n  if (this.currentTest) {\n    this.testResults.steps.splice(this.testResults.steps.indexOf(this.currentTest), 1);\n\n    this.runTestCase(this.currentTest, deferred, 0);\n  } else {\n    deferred.resolve();\n  }\n\n  return deferred.promise;\n};\n\nTestSuite.prototype.runTestCase = function(currentTest, deferred, numRetries) {\n  var self = this;\n\n  this['@testCase'] = new TestCase(this, currentTest, numRetries, this.testMaxRetries);\n\n  if (self.client.terminated() && self.client.skipTestcasesOnFail()) {\n    deferred.resolve(self.module.keys);\n    return deferred;\n  }\n\n  this['@testCase'].print().run().then(function(response) {\n    var foundFailures = !!(response.results.failed || response.results.errors);\n\n    if (foundFailures && numRetries < self.testMaxRetries) {\n      numRetries++;\n      self.client.resetTerminated();\n      self.clearResult();\n      self.runTestCase(currentTest, deferred, numRetries);\n    } else if (foundFailures && self.suiteRetries < self.suiteMaxRetries) {\n      deferred.resolve(self.module.keys);\n    } else {\n      self.onTestCaseFinished(response.results, response.errors, response.time);\n\n      if (self.client.terminated() && self.client.skipTestcasesOnFail()) {\n        deferred.resolve(self.module.keys);\n      } else {\n        process.nextTick(function() {\n          self.runNextTestCase(deferred);\n        });\n      }\n    }\n  }, function(error) {\n    deferred.reject(error);\n  });\n\n  return deferred;\n};\n\n//////////////////////////////////////////////////////////////////////\n// Test suite hooks\n//////////////////////////////////////////////////////////////////////\nTestSuite.prototype.before = function() {\n  return this.hooks.before();\n};\n\nTestSuite.prototype.after = function() {\n  return this.hooks.after();\n};\n\nTestSuite.prototype.beforeEach = function() {\n  return this.hooks.beforeEach();\n};\n\nTestSuite.prototype.afterEach = function(results, errors) {\n  return this.hooks.afterEach(results, errors);\n};\n\n//////////////////////////////////////////////////////////////////////\n// Global hooks\n//////////////////////////////////////////////////////////////////////\nTestSuite.prototype.globalBeforeEach = function() {\n  return this.adaptGlobalHook('beforeEach');\n};\n\nTestSuite.prototype.globalAfterEach = function() {\n  return this.adaptGlobalHook('afterEach');\n};\n\nTestSuite.prototype.adaptGlobalHook = function(hookName) {\n  return this.makePromise(function(done, deffered) {\n    var callbackDeffered = false;\n    var doneFn = function(err) {\n      if (callbackDeffered) {\n        return;\n      }\n      var fn = this.adaptDoneCallback(done, 'global ' + hookName, deffered);\n      return this.onGlobalHookError(err, true, fn);\n    }.bind(this);\n\n    var argsCount;\n    var expectedCount = 1;\n\n    if (Utils.checkFunction(hookName, this.options.globals)) {\n      argsCount = this.options.globals[hookName].length;\n      expectedCount = argsCount == 2 ? 2 : 1;\n    }\n\n    var globalHook = this.adaptHookMethod(hookName, this.options.globals, expectedCount);\n    var args = [doneFn];\n    if (argsCount == 2) {\n      args.unshift(this.client.api());\n    }\n\n    globalHook.apply(this.options.globals, args);\n\n    if (this.client.shouldRestartQueue()) {\n      callbackDeffered = true;\n      if (hookName == 'before' || hookName == 'beforeEach') {\n        this.client.start(function(err) {\n          return this.onGlobalHookError(err, false, done);\n          //if (err) {\n          //  this.addErrorToResults(err);\n          //}\n          //done(err);\n        }.bind(this));\n      } else {\n        this.client.restartQueue(function() {\n          done();\n        });\n      }\n    }\n\n  });\n};\n\nTestSuite.prototype.onGlobalHookError = function(err, hookErr, done) {\n  if (err && err.message) {\n    this.testResults.errors++;\n    this.testResults.errmessages = [err.message];\n  }\n\n  return done(err, hookErr);\n};\n\nTestSuite.prototype.addErrorToResults = function(err) {\n  this.testResults.errors++;\n  this.testResults.errmessages = [err.message];\n\n  return this;\n};\n\nTestSuite.prototype.adaptDoneCallback = function(done, hookName, deferred) {\n  return Utils.setCallbackTimeout(done, hookName, this.asyncHookTimeout, function(err) {\n    deferred.reject(err);\n  }, function(timeoutId) {\n    this.currentHookTimeoutId = timeoutId;\n  }.bind(this));\n};\n\n//////////////////////////////////////////////////////////////////////\n// Utilities\n//////////////////////////////////////////////////////////////////////\nTestSuite.prototype.makePromise = function (fn) {\n  var deferred = Q.defer();\n  try {\n    fn.call(this, function(err, hookErr) {\n      // in case of an exception thrown inside a global hook, we need to reject the promise here\n      if (hookErr && Utils.isErrorObject(err)) {\n        deferred.reject(err);\n      } else {\n        deferred.resolve();\n      }\n    }, deferred);\n  } catch (e) {\n    deferred.reject(e);\n  }\n\n  return deferred.promise;\n};\n\nTestSuite.prototype.updateDesiredCapabilities = function() {\n  this.options.desiredCapabilities = this.options.desiredCapabilities || {};\n  if (this.options.sync_test_names || (typeof this.options.sync_test_names == 'undefined')) {\n    // optionally send the local test name (derived from filename)\n    // to the remote selenium server. useful for test reporting in cloud service providers\n    this.options.desiredCapabilities.name = this.suiteName;\n  }\n\n  if (this.module.desiredCapabilities()) {\n    for (var capability in this.module.desiredCapabilities()) {\n      if (this.module.desiredCapabilities().hasOwnProperty(capability)) {\n        this.options.desiredCapabilities[capability] = this.module.desiredCapabilities(capability);\n      }\n    }\n  }\n};\n\nTestSuite.prototype.print = function() {\n  if (this.options.output) {\n    var testSuiteDisplay;\n    if (this.options.start_session) {\n      testSuiteDisplay = '[' + this.suiteName + '] Test Suite';\n    } else {\n      testSuiteDisplay = this.module.getTestSuiteName() || this.module.moduleKey;\n    }\n\n    if (this.options.test_worker && !this.options.live_output) {\n      process.stdout.write('\\\\n');\n    }\n\n    var output = '\\n' + Logger.colors.cyan(testSuiteDisplay) + '\\n' + Logger.colors.purple(new Array(testSuiteDisplay.length + 5).join('='));\n    console.log(output);\n\n  }\n};\n\nTestSuite.prototype.runHookMethod = function(fn, context, asyncArgCount, hookName, doneFn, deferred) {\n  var hookFn = this.adaptHookMethod(fn, context, asyncArgCount);\n\n  doneFn = Utils.setCallbackTimeout(doneFn, hookName, this.asyncHookTimeout, function(err) {\n    this.addErrorToResults(err);\n\n    this.deferred.resolve(this.testResults);\n  }.bind(this));\n\n  if (this.options.compatible_testcase_support) {\n    return hookFn.call(context, doneFn);\n  }\n\n  return hookFn.call(context, this.client.api(), doneFn);\n};\n\nTestSuite.prototype.adaptHookMethod = function(fn, context, asyncArgCount) {\n  var hookFn;\n  if (Array.isArray(fn) && (fn.length >= 2)) {\n    hookFn = Utils.checkFunction(fn[0], context) || Utils.checkFunction(fn[1], context) || noop;\n  } else {\n    hookFn = Utils.checkFunction(fn, context) || noop;\n  }\n\n  return Utils.makeFnAsync(asyncArgCount, hookFn, context);\n};\n\nmodule.exports = TestSuite;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/clientmanager.js":"var util = require('util');\nvar http = require('http');\nvar events = require('events');\nvar Q = require('q');\nvar Nightwatch = require('../index.js');\n\nfunction ClientManager() {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n}\n\nutil.inherits(ClientManager, events.EventEmitter);\n\nClientManager.prototype.init = function(opts) {\n  try {\n    this['@client'] = Nightwatch.client(opts);\n  } catch (err) {\n    console.log(err.stack);\n    this.emit('error', err, false);\n    return;\n  }\n\n  var self = this;\n  this.options = opts;\n\n  this['@client'].once('selenium:session_create', function() {\n    var capabilities = this.api.capabilities || {};\n    var browserName = (capabilities.browserName && capabilities.browserName.toUpperCase()) || '';\n\n    self.options.report_prefix = browserName + '_' + this.api.capabilities.version + '_' + this.api.capabilities.platform + '_';\n  });\n  return this;\n};\n\nClientManager.prototype.start = function(done) {\n  var self = this;\n\n  this.resetTerminated();\n\n  this['@client'].once('nightwatch:finished', function(results, errors) {\n    self.emit('complete', results, errors);\n    if (done) {\n      if (results.failed > 0 || results.errors > 0) {\n        done(results.lastError);\n        results.lastError = null;\n      } else {\n        done();\n      }\n    }\n  });\n\n  this['@client'].once('error', function(error, data) {\n    var errorMsg = error || data;\n    if (errorMsg instanceof http.IncomingMessage) {\n      errorMsg = {\n        statusCode : error.statusCode,\n        headers : error.headers\n      };\n    }\n\n    var result = {\n      message: 'Connection refused! Is selenium server started?\\n',\n      data : errorMsg\n    };\n\n    self.emit('error', result, false);\n  });\n\n  this['@client'].start();\n\n  return this;\n};\n\nClientManager.prototype.get = function() {\n  return this['@client'];\n};\n\nClientManager.prototype.set = function(prop, value) {\n  this['@client'][prop] = value;\n  return this;\n};\n\nClientManager.prototype.publishTestResults = function(testcase, results) {\n  if (!this['@client'].api.currentTest) {\n    return this;\n  }\n\n  results = results || {};\n\n  var currentTestSuite = this['@client'].api.currentTest.results;\n\n  currentTestSuite.passed += results.passed;\n  currentTestSuite.failed += results.failed;\n  currentTestSuite.errors += results.errors;\n  currentTestSuite.skipped += results.skipped;\n  currentTestSuite.tests += results.tests.length;\n\n  currentTestSuite.testcases = currentTestSuite.testcases || {};\n  currentTestSuite.testcases[testcase] = {\n    passed : results.passed,\n    failed : results.failed,\n    errors : results.errors,\n    skipped : results.skipped,\n    tests : results.tests.length,\n    assertions : results.tests,\n    stackTrace : results.stackTrace\n  };\n\n  return this;\n};\n\nClientManager.prototype.results = function(type, value) {\n  if (typeof value == 'undefined' && typeof type == 'undefined') {\n    return this['@client'].results;\n  }\n\n  if (typeof value == 'undefined') {\n    return this['@client'].results[type] || 0;\n  }\n  this['@client'].results[type] = value;\n  return this;\n};\n\nClientManager.prototype.errors = function() {\n  return this['@client'].errors;\n};\n\nClientManager.prototype.handleException = function(err) {\n  return this['@client'].handleException(err);\n};\n\nClientManager.prototype.clearGlobalResult = function() {\n  return this['@client'].clearResult();\n};\n\nClientManager.prototype.terminated = function() {\n  return this['@client'].terminated;\n};\n\nClientManager.prototype.terminate = function() {\n  this['@client'].terminate();\n  return this;\n};\n\nClientManager.prototype.setLocateStrategy = function() {\n  this['@client'].setLocateStrategy();\n  return this;\n};\n\nClientManager.prototype.resetTerminated = function() {\n  this['@client'].resetTerminated();\n  return this;\n};\n\nClientManager.prototype.print = function(startTime) {\n  return this['@client'].printResult(startTime);\n};\n\nClientManager.prototype.api = function(key, value) {\n  if (key && (typeof value != 'undefined')) {\n    this['@client'].api[key] = value;\n  }\n  return this['@client'].api;\n};\n\nClientManager.prototype.globals = function(key, value) {\n  if (key) {\n    if (typeof value != 'undefined') {\n      this['@client'].api.globals[key] = value;\n      return this;\n    }\n\n    return this['@client'].api.globals[key];\n  }\n\n  return this['@client'].api.globals;\n};\n\nClientManager.prototype.resetQueue = function() {\n  this['@client'].queue.reset();\n  return this;\n};\n\nClientManager.prototype.restartQueue = function(onComplete) {\n  this.resetQueue();\n  this['@client'].queue.run(onComplete);\n};\n\nClientManager.prototype.shouldRestartQueue = function() {\n  return this['@client'] && this['@client'].queue.list().length > 0;\n};\n\nClientManager.prototype.checkQueue = function() {\n  var deferred = Q.defer();\n  if (this.shouldRestartQueue()) {\n    this.restartQueue(function() {\n      deferred.resolve();\n    });\n  } else {\n    deferred.resolve();\n  }\n\n  return deferred.promise;\n};\n\nClientManager.prototype.endSessionOnFail = function(value) {\n  if (typeof value == 'undefined') {\n    return this['@client'].endSessionOnFail();\n  }\n  this['@client'].endSessionOnFail(value);\n\n  return this;\n};\n\nClientManager.prototype.skipTestcasesOnFail = function() {\n  return this.api().options.skip_testcases_on_fail;\n};\n\nmodule.exports = ClientManager;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/module.js":"var path = require('path');\nvar Utils = require('../util/utils.js');\n\nfunction Module(modulePath, opts, addtOpts) {\n\n  try {\n    this['@module'] = require(modulePath);\n  } catch (err) {\n    throw err;\n  }\n\n  if (!this['@module']) {\n    throw new Error('Invalid test suite provided.');\n  }\n\n  var currentTestcase = addtOpts && addtOpts.testcase;\n\n  this['@testSuiteName'] = null;\n  this['@attributes'] = {\n    '@endSessionOnFail' : true,\n    '@disabled' : false,\n    '@desiredCapabilities' : {},\n    '@tags' : []\n  };\n\n  this.groupName = '';\n  this.setTestSuiteName();\n\n  this.keys = this.getKeys(currentTestcase);\n  if (currentTestcase && this.keys.length === 0) {\n    throw new Error('Error: \"' + currentTestcase + '\" is not a valid testcase in the current test suite.');\n  }\n  this.allKeys = this.keys.slice();\n  this.filePath = modulePath;\n\n  this.modulePathParts = this.filePath.split(path.sep);\n  this.moduleName = this.modulePathParts.pop();\n  this.options = opts;\n}\n\nModule.prototype.get = function(key) {\n  if (!key) {\n    return this['@module'];\n  }\n  return this['@module'][key];\n};\n\nModule.prototype.set = function(key, value) {\n  if (!key || !value) {\n    return this;\n  }\n  this['@module'][key] = value;\n  return this;\n};\n\nModule.prototype.getName = function() {\n  return this.moduleName;\n};\n\nModule.prototype.call = function(fnName /* arg1, arg2 ...*/) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this['@module'][fnName].apply(this['@module'], args);\n};\n\nModule.prototype.callAsync = function(fnName, api, done, expectedArgs) {\n  expectedArgs = expectedArgs || 2;\n  var fnAsync = Utils.makeFnAsync(expectedArgs, this['@module'][fnName], this['@module']);\n  fnAsync.name = fnName;\n\n  var args = [done];\n  if (expectedArgs == 2) {\n    args.unshift(api);\n  }\n\n  return fnAsync.apply(this['@module'], args);\n};\n\nModule.prototype.setReportKey = function(fullPaths, srcFolders) {\n  var diffInFolder = '', folder, parentFolder = '';\n  var filePath = this.modulePathParts.join(path.sep);\n  if (srcFolders) {\n    for (var i = 0; i < srcFolders.length; i++) {\n      folder = path.resolve(srcFolders[i]);\n      if (fullPaths.length > 1) {\n        parentFolder = folder.split(path.sep).pop();\n      }\n      if (filePath.indexOf(folder) === 0) {\n        diffInFolder = filePath.substring(folder.length + 1);\n        break;\n      }\n    }\n  }\n\n  if (diffInFolder.substr(-1) == path.sep) {\n    diffInFolder = diffInFolder.substring(0, diffInFolder.length-1);\n  }\n\n  this.groupName = diffInFolder.split(path.sep).pop(); // in case we're in a sub-folder\n  this.moduleKey = path.join(parentFolder, diffInFolder, this.moduleName);\n  return this;\n};\n\nModule.prototype.getKeys = function(currentTestcase) {\n  return Object.keys(this['@module']).filter(function(element) {\n    if (!this['@module'][element]) {\n      return false;\n    }\n\n    var isFunction = typeof this['@module'][element] == 'function';\n    if (currentTestcase) {\n      return isFunction && (element === currentTestcase);\n    }\n    return isFunction;\n  }, this);\n};\n\nModule.prototype.removeKey = function(key) {\n  var self = this;\n  if (Array.isArray(key)) {\n    key.forEach(function(item) {\n      self.removeKey(item);\n    });\n    return;\n  }\n\n  var index = this.keys.indexOf(key);\n  if (index > -1) {\n    this.keys.splice(index, 1);\n  }\n};\n\nModule.prototype.setTestSuiteName = function() {\n  var module = this['@module'];\n\n  var keys = Object.keys(module);\n  var suiteName;\n\n  var hasSubSuite = keys.some(function(item) {\n    var isAttribute = this.isAttribute(item);\n    if (isAttribute) {\n      var attrName = Module.geAttributeName(item);\n      this['@attributes'][attrName] = module[item];\n    } else if (typeof module[item] == 'object' && module[item]) {\n      suiteName = item;\n      return true;\n    }\n    return false;\n  }, this);\n\n  if (hasSubSuite && suiteName) {\n    var sections = [];\n    if (this['@testSuiteName']) {\n      sections.push(this['@testSuiteName']);\n    }\n    sections.push(suiteName);\n    this['@testSuiteName'] = sections.join(' :: ');\n    this['@module'] = module[suiteName];\n\n    return this.setTestSuiteName();\n  }\n\n  return this;\n};\n\nModule.geAttributeName = function(item) {\n  return (item.charAt(0) == '@' ? '' : '@') + item;\n};\n\nModule.prototype.isAttribute = function(item) {\n  var attrName = Module.geAttributeName(item);\n  return (attrName in this['@attributes']) && (typeof module[item] != 'function');\n};\n\nModule.prototype.getTestSuiteName = function() {\n  return this['@testSuiteName'];\n};\n\nModule.prototype.getNextKey = function() {\n  if (this.keys.length) {\n    return this.keys.shift();\n  }\n  return null;\n};\n\nModule.prototype.resetKeys = function() {\n  this.keys = this.allKeys.slice();\n};\n\nModule.prototype.endSessionOnFail = function() {\n  return this['@attributes']['@endSessionOnFail'];\n};\n\nModule.prototype.isDisabled = function() {\n  return this['@attributes']['@disabled'];\n};\n\nModule.prototype.desiredCapabilities = function(capability) {\n  if (capability && (capability in this['@attributes']['@desiredCapabilities'])) {\n    return this['@attributes']['@desiredCapabilities'][capability];\n  }\n\n  return this['@attributes']['@desiredCapabilities'];\n};\n\nmodule.exports = Module;","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/testcase.js":"var path = require('path');\nvar Q = require('q');\nvar Logger = require('../util/logger.js');\nvar Utils = require('../util/utils.js');\nvar Reporter = require('../runner/reporter.js');\nvar DEFAULT_UNITTEST_HOOK_TIMEOUT = 2000;\n\nfunction TestCase(suite, testFn, numRetries, maxRetries) {\n  this.suite = suite;\n  this.testFn = testFn;\n  this.numRetries = numRetries;\n  this.maxRetries = maxRetries;\n  this.currentDeferred = null;\n  this._deferredNext = null;\n  this.running = false;\n  this.lastTimerId = null;\n  this.asyncHookTimeout = this.suite.client.globals('asyncHookTimeout') || DEFAULT_UNITTEST_HOOK_TIMEOUT;\n}\n\nTestCase.prototype.print = function () {\n  var opts = this.suite.options;\n\n  if (opts.output && opts.start_session && opts.detailed_output) {\n    process.stdout.write('\\n');\n    if (this.numRetries > 0) {\n      console.log('Retrying (' + this.numRetries + '/' + this.maxRetries + '): ',\n        Logger.colors.red(this.testFn));\n    } else {\n      console.log((opts.parallelMode && !opts.live_output ? 'Results for: ' : 'Running: '),\n        Logger.colors.green(this.testFn));\n    }\n  }\n  return this;\n};\n\nTestCase.prototype.getResults = function () {\n  return this.suite.client.results();\n};\n\nTestCase.prototype.getErrors = function () {\n  return this.suite.client.errors();\n};\n\nTestCase.prototype.run = function () {\n  var self = this;\n  this.currentDeferred = Q.defer();\n\n  this.startTime = new Date().getTime();\n  this.results = null;\n  this.errors = null;\n  this.running = true;\n\n  this.suite\n    .beforeEach()\n    .then(function() {\n      self._deferredNext = Q.defer();\n      self.suite.client.once('complete', function(results, errors) {\n        if (self.suite.client.options.start_session) {\n          self._deferredNext.resolve({\n            results: self.getResults(),\n            errors: self.getErrors()\n          });\n        }\n      }).on('error', function(result) {\n        self._deferredNext.reject(result);\n      });\n\n      try {\n        if (self.suite.client.options.start_session) {\n          self.suite.module.call(self.testFn, self.suite.client.api());\n        } else {\n          var doneFn = self.setDoneCallbackTimer(self.doneCallback.bind(self), self.testFn, function(timeoutId) {\n            timeoutId.currentTest = self.testFn;\n            self.lastTimerId = timeoutId;\n          });\n\n          self.doneFn = self.suite.module.callAsync(self.testFn, self.suite.client.api(), doneFn, self.suite.expectedAsyncArgs);\n        }\n      } catch (err) {\n        self.catchHandler(err);\n        return self._deferredNext.promise;\n      }\n\n      self.suite.client.start();\n\n      return self._deferredNext.promise;\n    })\n    .then(function onSuccess(response) {\n      return self.suite.afterEach(response.results, response.errors);\n    }, function onError(error) {\n      self.currentDeferred.reject(error);\n    })\n    .then(function() {\n      var time = new Date().getTime() - self.startTime;\n      self.currentDeferred.resolve({\n        results: self.getResults(),\n        errors: self.getErrors(),\n        time : time\n      });\n\n      self.running = false;\n    })\n    .catch(function(error) {\n      self.currentDeferred.reject(error);\n      self.running = false;\n    });\n\n  return self.currentDeferred.promise;\n};\n\nTestCase.prototype.setDoneCallbackTimer = function(done, fnName, onTimerStarted) {\n  return Utils.setCallbackTimeout(done, fnName, this.asyncHookTimeout, function(err) {\n    throw err;\n  }, onTimerStarted);\n};\n\nTestCase.prototype.doneCallback = function(err) {\n  var self = this;\n\n  if (this.lastTimerId) {\n    clearTimeout(this.lastTimerId);\n    this.lastTimerId = null;\n  }\n\n  if (this.suite.currentHookTimeoutId) {\n    clearTimeout(this.suite.currentHookTimeoutId);\n    this.suite.currentHookTimeoutId = null;\n  }\n\n  setImmediate(function() {\n    if (self._deferredNext) {\n      self._deferredNext.resolve({\n        results : self.getResults(),\n        errors : self.getErrors()\n      });\n    }\n  });\n\n  if (Utils.isErrorObject(err)) {\n    this.setFailed(err);\n  }\n\n  if (!this.suite.options.output || !this.currentDeferred) {\n    return;\n  }\n\n  if (!this.suite.options.start_session) {\n    this.currentDeferred.promise.then(function(results) {\n      console.log(Reporter.getTestOutput(err, this.testFn, results.time));\n    }.bind(this));\n  }\n\n  if (err && this.suite.options.start_session) {\n    this.suite.client.terminate();\n  }\n};\n\nTestCase.prototype.setFailed = function(err) {\n  this.suite.client.handleException(err);\n};\n\nTestCase.prototype.catchHandler = function(err) {\n  this.doneCallback(err);\n};\n\nmodule.exports = TestCase;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/reporter.js":"var fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar mkpath = require('mkpath');\nvar Logger = require('../util/logger.js');\nvar colors = Logger.colors;\nvar format = util.format;\nvar Utils = require('../util/utils.js');\nvar Q = require('q');\n\nvar Reporter = module.exports = function(globalResults, testResults, globalStartTime, options) {\n  this.globalResults = globalResults;\n  this.testResults = testResults;\n  this.globalStartTime = globalStartTime;\n  this.options = options;\n  this.reporter = options.reporter || 'junit';\n};\n\nvar printf = function() {\n  console.log(format.apply(null, arguments));\n};\n\n/**\n * @static\n * @param err\n * @param testname\n * @param time\n * @return {string}\n */\nReporter.getTestOutput = function (err, testname, time) {\n  var symbol;\n  if (Utils.isErrorObject(err)) {\n    symbol = Logger.colors.red(Utils.symbols.fail);\n    testname = Logger.colors.red(testname);\n  } else {\n    symbol = Logger.colors.green(Utils.symbols.ok);\n  }\n\n  var args = [\n    '%s %s', symbol, testname\n  ];\n\n  if (time > 20) {\n    args[0] += ' %s';\n    args.push(Logger.colors.yellow(Utils.format('(%s)', Utils.formatElapsedTime(time))));\n  }\n\n  return Utils.format.apply(null, args);\n};\n\nReporter.printAssertions = function(test) {\n  test.assertions.forEach(function(a) {\n    if (a.failure !== false) {\n      var message = a.stackTrace.split('\\n');\n      message.unshift(a.fullMsg);\n      Utils.showStackTrace(message.join('\\n'));\n    }\n  });\n\n  if (test.stackTrace) {\n    Utils.showStackTrace(test.stackTrace);\n  }\n};\n\nReporter.prototype.get = function() {\n  var fileName = __dirname + '/reporters/' + this.reporter + '.js';\n\n  if (fs.existsSync(fileName)) {\n    return require(fileName);\n  }\n\n  fileName = path.resolve(this.reporter);\n\n  if (fs.existsSync(fileName)) {\n    var reporter = require(fileName);\n    if (typeof reporter.write == 'function') {\n      return reporter;\n    }\n    throw new Error('The reporter module must have a public `write` method defined.');\n  }\n\n  throw new Error('The reporter file name cannot be resolved. Using path: ' + fileName);\n};\n\n/**\n * @param {object} globals\n * @returns {function}\n */\nReporter.prototype.globalReporter = function(globals) {\n  var reporterFn = Utils.checkFunction('reporter', globals) || function() {};\n  return Utils.makeFnAsync(2, reporterFn, globals);\n};\n\nReporter.prototype.isDisabled = function() {\n  return this.options.output_folder === false;\n};\n\nReporter.prototype.createFolder = function(cb) {\n  if (this.isDisabled()) {\n    cb(null);\n  } else {\n    mkpath(this.options.output_folder, cb);\n  }\n};\n\nReporter.prototype.save = function() {\n  var self = this;\n  var deferred = Q.defer();\n  this.createFolder(function(err) {\n    if (self.isDisabled()) {\n      deferred.resolve();\n    } else {\n      if (err) {\n        deferred.reject(err);\n        return;\n      }\n\n      var reporter = self.get();\n\n      reporter.write(self.globalResults, self.options, function(err) {\n        if (err) {\n          console.log(colors.yellow(format('Warning: Failed to save report file to folder: %s', self.options.output_folder)));\n          console.log(err.stack);\n        }\n        deferred.resolve(err);\n      });\n    }\n  });\n\n  return deferred.promise;\n};\n\nReporter.prototype.printTotalResults = function() {\n  var elapsedTime = new Date().getTime() - this.globalStartTime;\n  process.stdout.write('\\n');\n\n  if (this.testsFailed()) {\n    var countMessage = this.getTestsFailedMessage();\n\n    console.log(colors.light_red(' _________________________________________________'));\n    console.log(\n      format('\\n %s', colors.light_red('TEST FAILURE:')),\n      countMessage,\n      format('(%s)', Utils.formatElapsedTime(elapsedTime))\n    );\n\n\n    this.printFailureSummary();\n    console.log('');\n  } else {\n    if (!this.shouldShowSummary()) {\n      return;\n    }\n\n    var message = this.getTestsPassedMessage();\n    printf('%s (%s)', message, Utils.formatElapsedTime(elapsedTime));\n  }\n};\n\nReporter.prototype.testsFailed = function() {\n  return Object.keys(this.globalResults.modules).some(function(moduleKey) {\n    return this.globalResults.modules[moduleKey].failures > 0 || this.globalResults.modules[moduleKey].errors > 0;\n  }.bind(this));\n};\n\nReporter.prototype.shouldShowSummary = function() {\n  var modules = Object.keys(this.globalResults.modules);\n  if (modules.length > 1) {\n    return true;\n  }\n\n  if (modules.length <= 0) {\n    return false;\n  }\n\n  return  Object.keys(this.globalResults.modules[modules[0]].completed).length > 1;\n};\n\nReporter.prototype.hasAssertionCount = function() {\n  return Object.keys(this.globalResults.modules).length > 0 &&\n    (this.globalResults.failed > 0 || this.globalResults.passed > 0);\n};\n\nReporter.prototype.getTestsPassedMessage = function() {\n  var hasCount = this.hasAssertionCount();\n  var message;\n  var count;\n\n  if (hasCount) {\n    count = this.globalResults.passed;\n    message = colors.green(format('OK. %s %s passed.', count, (count > 1 ? ' total assertions' : ' assertion')));\n  } else {\n    count = this.getTotalTestsCount();\n    message = format('%s tests passed.', colors.green('OK. ' + count));\n  }\n\n  return message;\n};\n\nReporter.prototype.getTotalTestsCount = function() {\n\n  var module;\n\n  return Object.keys(this.globalResults.modules).reduce(function(count, moduleKey) {\n    module = this.globalResults.modules[moduleKey];\n    return count + module.tests - module.skipped.length;\n  }.bind(this), 0);\n};\n\nReporter.prototype.getTestsFailedMessage = function() {\n  var hasCount = this.hasAssertionCount();\n  if (!hasCount && this.testResults.errmessages === 0) {\n    return '';\n  }\n  var errorsMsg = '';\n  var failedMsg = 'assertions';\n  var passedMsg = format('%s passed', colors.green(this.globalResults.passed));\n\n  if (!this.options.start_session) {\n    failedMsg = 'tests';\n    var passedCount = Math.max(0, this.getTotalTestsCount() - this.globalResults.failed);\n    passedMsg = format('%s passed', colors.green(passedCount));\n  }\n\n  var skipped = '';\n  if (this.testResults.skipped) {\n    skipped = format(' and %s skipped', colors.cyan(this.testResults.skipped));\n  }\n\n  if (this.globalResults.errors) {\n    var suffix = this.globalResults.errors > 1 ? 's' : '';\n    errorsMsg += format('%s error%s during execution, ', colors.red(this.globalResults.errors), suffix);\n  }\n\n  return format('%s %s %s failed, %s%s.', errorsMsg, colors.red(this.globalResults.failed), failedMsg, passedMsg, skipped);\n};\n\nReporter.prototype.printFailureSummary = function() {\n  Object.keys(this.globalResults.modules).forEach(function(moduleKey) {\n    var testSuite = this.globalResults.modules[moduleKey];\n    if (testSuite.failures > 0 || testSuite.errors > 0) {\n\n      console.log('\\n' + colors.red(format(' %s %s', Utils.symbols.fail, moduleKey)));\n\n      Object.keys(testSuite.completed).forEach(function(testcase) {\n        var test = testSuite.completed[testcase];\n        if (test.failed > 0 || test.errors > 0) {\n          printf('\\n   - %s %s', testcase, colors.yellow('(' + Utils.formatElapsedTime(test.timeMs) + ')'));\n\n          if (test.assertions.length > 0 && this.options.start_session) {\n            Reporter.printAssertions(test);\n          } else if (test.stackTrace) {\n            Utils.showStackTrace(test.stackTrace);\n          }\n        }\n      }.bind(this));\n\n      if (Array.isArray(testSuite.errmessages)) {\n        testSuite.errmessages.forEach(function(err) {\n          console.log('');\n          Utils.showStackTrace(err);\n          console.log('');\n        });\n      }\n\n\n      if (testSuite.skipped.length > 0) {\n        console.log(colors.cyan('   SKIPPED:'));\n        testSuite.skipped.forEach(function(testcase) {\n          printf('   - %s', testcase);\n        });\n      }\n    }\n  }.bind(this));\n\n  if (Array.isArray(this.globalResults.errmessages)) {\n    this.globalResults.errmessages.forEach(function(err) {\n      console.log('');\n      Utils.showStackTrace(err);\n      console.log('');\n    }.bind(this));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/selenium.js":"/**\n * Module dependencies\n */\nvar path = require('path');\nvar fs = require('fs');\nvar child_process = require('child_process');\nvar util = require('util');\nvar Logger = require('../util/logger.js');\n\nvar SENTINEL = ['Started org.openqa.jetty.jetty.Server', 'INFO - Selenium Server is up and running'];\nvar DEFAULT_PORT = 4444;\nvar DEFAULT_HOST = '127.0.0.1';\nvar DEFAULT_LOG_FILE = 'selenium-debug.log';\n\nfunction SeleniumServer(settings, callback) {\n  this.settings = settings;\n  this.onStarted = callback;\n\n  this.port = this.settings.selenium.port || DEFAULT_PORT;\n  this.host = this.settings.selenium.host;\n  this.output = '';\n  this.error_out = '';\n  this.process = null;\n}\n\nSeleniumServer.prototype.setCliArgs = function() {\n  this.cliOpts = [\n    '-jar', this.settings.selenium.server_path,\n    '-port', this.port\n  ];\n\n  if (this.host && this.host != DEFAULT_HOST) {\n    this.cliOpts.push('-host', this.host);\n    Logger.warn('\\n\\n[!] The host argument has been removed from Selenium 3 and will throw an exception.\\n');\n  }\n\n  if (typeof this.settings.selenium.cli_args == 'object') {\n    var cli_args = this.settings.selenium.cli_args;\n    for (var keyName in cli_args) {\n      if (cli_args[keyName]) {\n        var property = '';\n        if (keyName.indexOf('-D') !== 0) {\n          property += '-D';\n        }\n        property += keyName + '=' + cli_args[keyName];\n        this.cliOpts.unshift(property);\n      }\n    }\n  }\n};\n\nSeleniumServer.prototype.start = function() {\n  if (this.settings.output) {\n    process.stdout.write(Logger.colors.light_purple('Starting selenium server' + (this.settings.parallelMode ? ' in parallel mode' : '') +'... '));\n  }\n\n  this.setCliArgs();\n  this.process = child_process.spawn('java', this.cliOpts, {\n    stdio: ['ignore', 'pipe', 'pipe']\n  });\n\n  this.process.host = this.host;\n  this.process.port = this.port;\n  this.exitHandlerFn = this.exitHandler.bind(this);\n\n  this.process.on('error', this.onError.bind(this));\n  this.process.on('exit', this.exitHandlerFn);\n  this.process.on('close', this.closeHandler.bind(this));\n\n  this.process.stdout.on('data', this.onStdoutData.bind(this));\n  this.process.stderr.on('data', this.onStderrData.bind(this));\n};\n\nSeleniumServer.prototype.stop = function(callback) {\n  if (!this.process || this.process.killed) {\n    Logger.warn('Selenium process is not started.');\n    callback(false);\n    return;\n  }\n  try {\n    this.process.kill();\n    this.writeLogFile(callback);\n  } catch (e) {\n    Logger.warn('Selenium process could not be stopped.');\n    console.log(e);\n    callback();\n  }\n};\n\nSeleniumServer.prototype.exitHandler = function (code) {\n  this.onStarted('Could not start Selenium.', null, this.error_out, code);\n};\n\nSeleniumServer.prototype.closeHandler = function() {\n  Logger.info('Selenium process finished.');\n};\n\nSeleniumServer.prototype.writeLogFile = function(callback) {\n  if (this.settings.selenium.log_path === false) {\n    callback();\n    return;\n  }\n\n  if (typeof this.settings.selenium.log_path == 'undefined') {\n    this.settings.selenium.log_path = '';\n  }\n\n  var filePath = path.resolve(path.join(this.settings.selenium.log_path, DEFAULT_LOG_FILE));\n\n  fs.writeFile(filePath, this.output, function(err) {\n    if (err) {\n      console.log(Logger.colors.light_red('\\nError writing log file to:'), err.path);\n    }\n    callback();\n  });\n};\n\nSeleniumServer.prototype.onError = function(err) {\n  if (err.code == 'ENOENT') {\n    console.log(Logger.colors.red('\\nAn error occurred while trying to start Selenium. ' +\n      'Check if JAVA is installed on your machine.'));\n    console.log(util.inspect(err, false, 1, true));\n  }\n};\n\nSeleniumServer.prototype.onStderrData = function(data) {\n  this.error_out += data.toString();\n  this.checkProcessStarted(data);\n};\n\nSeleniumServer.prototype.onStdoutData = function(data) {\n  this.checkProcessStarted(data);\n};\n\nSeleniumServer.prototype.checkProcessStarted = function(data) {\n  var output = data.toString();\n  this.output += output;\n  var isStarted = SENTINEL.some(function(item) {\n    return output.indexOf(item) != -1;\n  });\n\n  if (isStarted) {\n    var exitHandler = this.exitHandlerFn;\n\n    this.process.removeListener('exit', exitHandler);\n    process.stdout.write(Logger.colors.light_purple('started - PID: ' ) + ' ' +\n      this.process.pid + '\\n' + (this.settings.parallelMode ? '\\n' : ''));\n    this.onStarted(null, this.process);\n  }\n};\n\nmodule.exports = new (function() {\n  var server;\n\n  this.startServer = function (settings, callback) {\n    if (!settings.selenium || !settings.selenium.start_process || !settings.selenium.server_path) {\n      callback();\n      return;\n    }\n\n    server = new SeleniumServer(settings, callback);\n    server.start();\n  };\n\n  this.stopServer = function (callback) {\n    callback = callback || function() {};\n\n    if (!server) {\n      console.log('Selenium server is not running.');\n      callback();\n      return;\n    }\n\n    server.stop(callback);\n  };\n})();\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/cli/child-process.js":"var child_process = require('child_process');\nvar util = require('util');\nvar events = require('events');\n\nvar Logger = require('../../util/logger.js');\n\nfunction ChildProcess(environment, index, env_output, settings, args) {\n  events.EventEmitter.call(this);\n\n  this.env_output = env_output || [];\n  this.mainModule = process.mainModule.filename;\n  this.index = index;\n  this.itemKey = this.getChildProcessEnvKey(environment);\n  this.startDelay = settings.parallel_process_delay || ChildProcess.defaultStartDelay;\n  this.environment = environment;\n  this.settings = settings;\n  this.child = null;\n  this.globalExitCode = 0;\n  this.processRunning = false;\n  this.env_label = '';\n  this.args = args || [];\n}\n\nutil.inherits(ChildProcess, events.EventEmitter);\n\nChildProcess.prevIndex = 0;\nChildProcess.defaultStartDelay = 10;\n\nChildProcess.prototype.setLabel = function(label) {\n  this.env_itemKey = label;\n  this.env_label = this.settings.disable_colors ?\n    (' ' + label + ' ') : Logger.colors.yellow(' ' + label + ' ', Logger.colors.background.black);\n  return this;\n};\n\nChildProcess.prototype.run = function(colors, done) {\n  this.availColors = colors;\n\n  var cliArgs = this.getArgs();\n  var env = {};\n  Object.keys(process.env).forEach(function(key) {\n    env[key] = process.env[key];\n  });\n\n  var self = this;\n\n  setTimeout(function() {\n    env.__NIGHTWATCH_PARALLEL_MODE = 1;\n    env.__NIGHTWATCH_ENV = self.environment;\n    env.__NIGHTWATCH_ENV_KEY = self.itemKey;\n    env.__NIGHTWATCH_ENV_LABEL = self.env_itemKey;\n\n    self.child = child_process.spawn(process.execPath, cliArgs, {\n      cwd: process.cwd(),\n      encoding: 'utf8',\n      env: env,\n      stdio: [null, null, null, 'ipc']\n    });\n\n    self.child.on('message', function(data) {\n      self.emit('result', JSON.parse(data));\n    });\n\n    self.processRunning = true;\n\n    if (self.settings.output) {\n      console.log('Started child process for:' + self.env_label);\n    }\n\n    self.child.stdout.on('data', function (data) {\n      self.writeToStdout(data);\n    });\n\n    self.child.stderr.on('data', function (data) {\n      self.writeToStdout(data);\n    });\n\n    self.child.on('exit', function (code) {\n      if (self.settings.output) {\n        console.log('\\n  >>' + self.env_label + 'finished. ', '\\n');\n      }\n\n      if (code) {\n        self.globalExitCode = 2;\n      }\n      self.processRunning = false;\n      done(self.env_output, code);\n    });\n\n\n  }, this.index * this.startDelay);\n};\n\nChildProcess.prototype.getChildProcessEnvKey = function(env) {\n  return env + '_' + (this.index+1);\n};\n\n/**\n * Returns an array of cli arguments to be passed to the child process,\n * based on the args passed to the main process\n * @returns {Array}\n */\nChildProcess.prototype.getArgs = function() {\n  var args = [this.mainModule];\n  args.push.apply(args, this.args);\n  args.push('--parallel-mode');\n\n  return args;\n};\n\n\nChildProcess.prototype.writeToStdout = function(data) {\n  data = data.toString().trim();\n\n  var color_pair = this.availColors[this.index%4];\n  var output = '';\n\n  if (ChildProcess.prevIndex !== this.index) {\n    ChildProcess.prevIndex = this.index;\n    if (this.settings.live_output) {\n      output += '\\n';\n    }\n  }\n\n  if (this.settings.output) {\n    if (this.settings.disable_colors) {\n      output += ' ' + this.environment + ' ';\n    } else {\n      output += Logger.colors[color_pair[1]](' ' + this.environment + ' ',\n        Logger.colors.background[color_pair[0]]);\n    }\n    output += '  ';\n  }\n\n  output += data;\n\n  if (this.settings.live_output) {\n    process.stdout.write(output + '\\n');\n  } else {\n    this.env_output.push(output);\n  }\n};\n\nmodule.exports = ChildProcess;","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/cli/errorhandler.js":"var Logger = require('../../util/logger.js');\nvar Utils = require('../../util/utils.js');\n\nvar ErrorHandler = module.exports = {\n  handle : function(err, results, finished) {\n    finished = finished || function() {};\n\n    if (results && results.errors) {\n      console.log(results.errmessages.join('\\n'));\n    }\n\n    if (err) {\n      Logger.enable();\n      if (!err.message) {\n        err.message = 'There was an error while running the test.';\n      }\n\n      ErrorHandler.logError(err);\n\n      finished(false);\n\n      process.exit(1);\n    } else {\n      var result = true;\n      if (results.failed || results.errors) {\n        result = false;\n      }\n      finished(result);\n    }\n  },\n\n  logWarning : function(message) {\n    console.warn(Logger.colors.brown(message));\n  },\n\n  logError : function(err) {\n    if (!err) {\n      return;\n    }\n    var util = require('util');\n    console.error('');\n    var stackTrace = err && err.stack;\n\n    if (!stackTrace) {\n      var data;\n      if (err.message) {\n        data = err.data;\n        err = err.message;\n      }\n\n      if (typeof err == 'string') {\n        process.stderr.write(Logger.colors.red(err));\n        if (data) {\n          if (typeof data == 'object' && Object.keys(data).length > 0) {\n            data = util.inspect(data);\n          }\n          process.stderr.write(Logger.colors.stack_trace(data) + '\\n');\n        }\n\n        process.stderr.write('\\n');\n      } else {\n        console.error(err);\n      }\n      return;\n    }\n\n    Utils.showStackTraceWithHeadline('There was an error while starting the test runner:\\n', err.stack + '\\n', true);\n  }\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands.js":"var events = require('events');\n\nmodule.exports = function(client) {\n  return {\n    /**\n     * Change focus to another window. The window to change focus to may be specified by its server assigned window handle, or by the value of its name attribute.\n     *\n     * To find out the window handle use `window_handles` protocol action\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.window_handles(function(result) {\n     *      var handle = result.value[0];\n     *      browser.switchWindow(handle);\n     *    });\n     *  };\n     * ```\n     *\n     * @method switchWindow\n     * @param {string} handleOrName The server assigned window handle or the name attribute.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see window\n     * @since v0.3.0\n     * @api commands\n     */\n    switchWindow : function(handleOrName, callback) {\n      var self = this;\n      this.window('POST', handleOrName, function(result) {\n        if (typeof callback === 'function') {\n          callback.call(self, result);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * Resizes the current window.\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.resizeWindow(1000, 800);\n     *  };\n     * ```\n     *\n     * @method resizeWindow\n     * @param {number} width The new window width.\n     * @param {number} height The new window height.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see windowSize\n     * @since v0.3.0\n     * @api commands\n     */\n    resizeWindow : function(width, height, callback) {\n      var self = this;\n      return this.windowSize('current', width, height, function(result) {\n        if (typeof callback === 'function') {\n          callback.call(self, result);\n        }\n      });\n    },\n\n    /**\n     * Sets the current window position.\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.setWindowPosition(0, 0);\n     *  };\n     * ```\n     *\n     * @method setWindowPosition\n     * @param {number} offsetX The new window offset x-position.\n     * @param {number} offsetY The new window offset y-position.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see windowPosition\n     * @since v0.8.18\n     * @api commands\n     */\n    setWindowPosition : function(offsetX, offsetY, callback) {\n      var self = this;\n      return this.windowPosition('current', offsetX, offsetY, function(result) {\n        if (typeof callback === 'function') {\n          callback.call(self, result);\n        }\n      });\n    },\n\n    /**\n     * Maximizes the current window.\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.maximizeWindow();\n     *  };\n     * ```\n     *\n     * @method maximizeWindow\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see windowMaximize\n     * @since v0.5.13\n     * @api commands\n     */\n    maximizeWindow: function(callback) {\n      var self = this;\n      return this.windowMaximize('current', function(result) {\n        if (typeof callback === 'function') {\n          callback.call(self, result);\n        }\n      });\n    },\n\n    /**\n     * Take a screenshot of the current page and saves it as the given filename.\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.saveScreenshot('/path/to/fileName.png');\n     *  };\n     * ```\n     *\n     * @method saveScreenshot\n     * @param {string} fileName The complete path to the file name where the screenshot should be saved.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see screenshot\n     * @api commands\n     */\n    saveScreenshot : function(fileName, callback) {\n      var self = this;\n      return this.screenshot(client.api.options.log_screenshot_data, function(result) {\n        client.saveScreenshotToFile(fileName, result.value, function(err) {\n          if (typeof callback === 'function') {\n            callback.call(self, result, err);\n          }\n        });\n      });\n    },\n\n    /**\n     * Returns the title of the current page. Uses title protocol command.\n     *\n     * ```\n     *  this.demoTest = function (browser) {\n     *    browser.getTitle(function(title) {\n     *      this.assert.equal(typeof title, 'string');\n     *      this.assert.equal(title, 'Nightwatch.js');\n     *    });\n     *  };\n     * ```\n     *\n     * @method getTitle\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see title\n     * @returns {string} The page title.\n     * @api commands\n     */\n    getTitle : function(callback) {\n      var self = this;\n      return this.title(function(result) {\n        callback.call(self, result.value);\n      });\n    },\n\n    /**\n     * Close the current window. This can be useful when you're working with multiple windows open (e.g. an OAuth login).\n     * Uses `window` protocol command.\n     *\n     * ```\n     * this.demoTest = function (client) {\n     *   client.closeWindow();\n     * };\n     * ```\n     *\n     * @method closeWindow\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @see window\n     * @since v0.3.0\n     * @api commands\n     */\n    closeWindow : function(callback) {\n      var self = this;\n      return this.window('DELETE', function(result) {\n        if (typeof callback === 'function') {\n          callback.call(self, result);\n        }\n      });\n    },\n\n    /**\n     * This command is an alias to url and also a convenience method when called without any arguments in the sense that it performs a call to .url() with passing the value of `launch_url` field from the settings file.\n     * Uses `url` protocol command.\n     *\n     * ```\n     * this.demoTest = function (client) {\n     *   client.init();\n     * };\n     * ```\n     *\n     * @method init\n     * @param {string} [url] Url to navigate to.\n     * @see url\n     * @since v0.4.0\n     * @api commands\n     */\n    init : function(url) {\n      if (url) {\n        return this.url(url);\n      }\n\n      if (!this.launchUrl) {\n        return this;\n      }\n      return this.url(this.launchUrl);\n    },\n\n    /**\n     * Convenience method that adds the specified hash (i.e. url fragment) to the current value of the `launch_url` as set in `nightwatch.json`.\n     *\n     * ```\n     * this.demoTest = function (client) {\n     *   client.urlHash('#hashvalue');\n     *   // or\n     *   client.urlHash('hashvalue');\n     * };\n     * ```\n     *\n     * @method urlHash\n     * @param {string} hash The hash to add/replace to the current url (i.e. the value set in the launch_url property in nightwatch.json).\n     * @see url\n     * @since v0.4.0\n     * @api commands\n     */\n    urlHash : function(hash) {\n      if (hash.charAt(0) === '#') {\n        hash = hash.substring(1);\n      }\n      return this.url(this.launchUrl + '#' + hash);\n    },\n\n    /**\n     * Retrieve all cookies visible to the current page. The cookies are returned as an array of cookie JSON object, as defined [here](https://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object).\n     *\n     * Uses `cookie` protocol command.\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.getCookies(function callback(result) {\n     *     this.assert.equal(result.value.length, 1);\n     *     this.assert.equals(result.value[0].name, 'test_cookie');\n     *   });\n     * }\n     * ```\n     *\n     * @method getCookies\n     * @param {function} callback The callback function which will receive the response as an argument.\n     * @api commands\n     * @since v0.4.0\n     * @see cookie\n     * @returns {Array.<object>} A list of cookies.\n     */\n    getCookies : function(callback) {\n      return this.cookie('GET', callback);\n    },\n\n    /**\n     * Retrieve a single cookie visible to the current page. The cookie is returned as a cookie JSON object, as defined [here](https://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object).\n     *\n     * Uses `cookie` protocol command.\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.getCookie(name, function callback(result) {\n     *     this.assert.equal(result.value, '123456');\n     *     this.assert.equals(result.name, 'test_cookie');\n     *   });\n     * }\n     * ```\n     *\n     * @method getCookie\n     * @param {string} name The cookie name.\n     * @param {function} callback The callback function which will receive the response as an argument.\n     * @api commands\n     * @since v0.4.0\n     * @see cookie\n     * @returns {object|null} The cookie object as a selenium cookie JSON object or null if the cookie wasn't found.\n     */\n    getCookie : function(name, callback) {\n      var self = this;\n      return this.cookie('GET', function(result) {\n        if (!result.value || result.value.length === 0) {\n          callback.call(self, null);\n          return;\n        }\n\n        var cookie = null;\n        for (var i = 0; i < result.value.length; i++) {\n          if (result.value[i].name === name) {\n            cookie = result.value[i];\n            break;\n          }\n        }\n\n        callback.call(self, cookie);\n      });\n    },\n\n    /**\n     * Set a cookie, specified as a cookie JSON object, as defined [here](https://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object).\n     *\n     * Uses `cookie` protocol command.\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.setCookie({\n     *     name     : \"test_cookie\",\n     *     value    : \"test_value\",\n     *     path     : \"/\", (Optional)\n     *     domain   : \"example.org\", (Optional)\n     *     secure   : false, (Optional)\n     *     httpOnly : false, // (Optional)\n     *     expiry   : 1395002765 // (Optional) time in seconds since midnight, January 1, 1970 UTC\n     *   });\n     * }\n     * ```\n     *\n     * @method setCookie\n     * @param {object} cookie The cookie object.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @since v0.4.0\n     * @see cookie\n     */\n    setCookie : function(cookie, callback) {\n      return this.cookie('POST', cookie, callback);\n    },\n\n    /**\n     * Delete the cookie with the given name. This command is a no-op if there is no such cookie visible to the current page.\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.deleteCookie(\"test_cookie\", function() {\n     *     // do something more in here\n     *   });\n     * }\n     * ```\n     *\n     * @method deleteCookie\n     * @param cookieName The name of the cookie to delete.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @since v0.4.0\n     * @see cookie\n     */\n    deleteCookie : function(cookieName, callback) {\n      return this.cookie('DELETE', cookieName, callback);\n    },\n\n    /**\n     * Delete all cookies visible to the current page.\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.deleteCookies(function() {\n     *     // do something more in here\n     *   });\n     * }\n     * ```\n     *\n     * @method deleteCookies\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @since v0.4.0\n     * @see cookie\n     */\n    deleteCookies : function(callback) {\n      return this.cookie('DELETE', callback);\n    },\n\n    /**\n     * Utility command to load an external script into the page specified by url.\n     *\n     * ```\n     * this.demoTest = function(client) {\n     *   this.injectScript('http://example.org/js/utility.js', function() {\n     *     // we're all done here.\n     *   });\n     * };\n     * ```\n     *\n     * @method injectScript\n     * @param {string} scriptUrl The script file url\n     * @param {string} [id] Dom element id to be set on the script tag.\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @since v0.4.0\n     * @returns {HTMLScriptElement} The newly created script tag.\n     */\n    injectScript : function(scriptUrl, id, callback) {\n      var args = [scriptUrl];\n      if (arguments.length == 2 && typeof arguments[1] == 'function') {\n        callback = arguments[1];\n      } else if (typeof id == 'string') {\n        args.push(id);\n      }\n\n      return this.execute(function(u,i) {/* jshint browser:true */return (function(d){var e=d.createElement('script');var m=d.getElementsByTagName('head')[0];e.src=u;if(i){e.id=i;}m.appendChild(e);return e;})(document);}, args, callback);\n    },\n    \n    /**\n     * Gets the available log types\n     *\n     * ```\n     * this.demoTest = function(client) {\n     *   this.getLogTypes(function(typesArray) {\n     *     \n     *   });\n     * };\n     * ```\n     *\n     * @method getLogTypes\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @see logTypes\n     */\n    getLogTypes: function(callback) {\n      var self = this;\n      return this.sessionLogTypes(function(response) {\n        if (callback) {\n          callback.call(self, response.value);\n        }\n      });\n    },\n    \n    /**\n     * Gets a log from selenium\n     *\n     * ```\n     * this.demoTest = function(client) {\n     *   this.getLog('browser', function(logEntriesArray) {\n     *     console.log('Log length: ' + logEntriesArray.length);\n     *     logEntriesArray.forEach(function(log) {\n     *        console.log('[' + log.level + '] ' + log.timestamp + ' : ' + log.message);\n     *      });\n     *   });\n     * };\n     * ```\n     *\n     * @method getLog\n     * @param {string|function} typeString Log type to request\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @see log\n     */\n    getLog: function(typeString, callback) {\n      var self = this;\n      if (typeof typeString !== 'string') {\n        if (typeof typeString === 'function') {\n          callback = typeString;\n        }\n        typeString = 'browser';\n      }\n      return this.sessionLog(typeString, function (response) {\n        if (callback) {\n          callback.call(self, response.value);\n        }\n      });\n    },\n      \n    /**\n     * Utility command to test if the log type is available\n     *\n     * ```\n     * this.demoTest = function(browser) {\n     *   browser.isLogAvailable('browser', function(isAvailable) {\n     *     // do something more in here\n     *   });\n     * }\n     * ```\n     *\n     * @method isLogAvailable\n     * @param {string|function} typeString Type of log to test\n     * @param {function} [callback] Optional callback function to be called when the command finishes.\n     * @api commands\n     * @see getLogTypes\n     */\n    isLogAvailable: function(typeString, callback) {\n      var self = this;\n      if (typeof typeString !== 'string') {\n        if (typeof typeString === 'function') {\n          callback = typeString;\n        }\n        typeString = 'browser';\n      }\n      return this.getLogTypes(function (types) {\n        var isAvailable;\n        try {\n          isAvailable = Array.isArray(types) && types.indexOf(typeString) >= 0;\n        } catch (err) {\n          isAvailable = false;\n        }\n\n        if (callback) {\n          callback.call(self, isAvailable);\n        } \n      });\n    }\n\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('../util/logger.js');\nvar Utils = require('../util/utils.js');\n\nmodule.exports = function(client) {\n  var Protocol = require('./protocol.js')(client);\n  var returnValue = {};\n  var elementCommands = {};\n\n  /**\n   * Simulates a click event on the given DOM element. Uses `elementIdClick` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.click(\"#main ul li a.first\");\n   * };\n   * ```\n   *\n   * @method click\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdClick\n   * @api commands\n   */\n  elementCommands.click = 'elementIdClick';\n\n  /**\n   * Clear a textarea or a text input element's value. Uses `elementIdValue` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.clearValue('input[type=text]');\n   * };\n   * ```\n   *\n   * @method clearValue\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdClear\n   * @api commands\n   */\n  elementCommands.clearValue = 'elementIdClear';\n\n  /**\n   * Retrieve the value of an attribute for a given DOM element. Uses `elementIdAttribute` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.getAttribute(\"#main ul li a.first\", \"href\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, \"#home\");\n   *   });\n   * };\n   * ```\n   *\n   * @method getAttribute\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {string} attribute The attribute name to inspect.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdAttribute\n   * @returns {*} The value of the attribute\n   * @api commands\n   */\n  elementCommands.getAttribute = ['elementIdAttribute', 1];\n\n  /**\n   * Retrieve the value of a css property for a given DOM element. Uses `elementIdCssProperty` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.getCssProperty(\"#main ul li a.first\", \"display\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, 'inline');\n   *   });\n   * };\n   * ```\n   *\n   * @method getCssProperty\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {string} cssProperty The CSS property to inspect.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdCssProperty\n   * @returns {*} The value of the css property\n   * @api commands\n   */\n  elementCommands.getCssProperty = ['elementIdCssProperty', 1];\n\n  /**\n   * Determine an element's size in pixels. Uses `elementIdSize` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.getElementSize(\"#main ul li a.first\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value.width, 500);\n   *     this.assert.equal(result.value.height, 20);\n   *  });\n   * };\n   * ```\n   *\n   * @method getElementSize\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdSize\n   * @returns {{width: number, height: number}} The width and height of the element in pixels\n   * @api commands\n   */\n  elementCommands.getElementSize = 'elementIdSize';\n\n  /**\n   * Determine an element's location on the page. The point (0, 0) refers to the upper-left corner of the page.\n   *\n   * The element's coordinates are returned as a JSON object with x and y properties. Uses `elementIdLocation` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.getLocation(\"#main ul li a.first\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value.x, 200);\n   *     this.assert.equal(result.value.y, 200);\n   *   });\n   * };\n   * ```\n   *\n   * @method getLocation\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdLocation\n   * @returns {x:number, y:number} The X and Y coordinates for the element on the page.\n   * @api commands\n   */\n  elementCommands.getLocation = 'elementIdLocation';\n\n  /**\n   * Determine an element's location on the screen once it has been scrolled into view. Uses `elementIdLocationInView` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.getLocationInView(\"#main ul li a.first\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value.x, 200);\n   *     this.assert.equal(result.value.y, 200);\n   *   });\n   * };\n   * ```\n   *\n   * @method getLocationInView\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdLocationInView\n   * @returns {x: number, y: number} The X and Y coordinates for the element on the page.\n   * @api commands\n   */\n  elementCommands.getLocationInView = 'elementIdLocationInView';\n\n  /**\n   * Query for an element's tag name. Uses `elementIdName` protocol command.\n   *\n   * ```\n   * this.demoTest = function (client) {\n   *   client.getTagName(\"#main ul li .first\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, \"a\");\n   *   });\n   * };\n   * ```\n   *\n   * @method getTagName\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdName\n   * @returns {number} The element's tag name, as a lowercase string.\n   * @api commands\n   */\n  elementCommands.getTagName = 'elementIdName';\n\n  /**\n   * Returns the visible text for the element. Uses `elementIdText` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.getText(\"#main ul li a.first\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, \"nightwatchjs.org\");\n   *   });\n   * };\n   * ```\n   *\n   * @method getText\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdText\n   * @returns {string} The element's visible text.\n   * @api commands\n   */\n  elementCommands.getText = 'elementIdText';\n\n  /**\n   * Returns a form element current value. Uses `elementIdValue` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.getValue(\"form.login input[type=text]\", function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, \"enter username\");\n   *   });\n   * };\n   * ```\n   *\n   * @method getValue\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdValue\n   * @returns {string} The element's value.\n   * @api commands\n   */\n  elementCommands.getValue = 'elementIdValue';\n\n  /**\n   * Determine if an element is currently displayed. Uses `elementIdDisplayed` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.isVisible('#main', function(result) {\n   *     this.assert.equal(typeof result, \"object\");\n   *     this.assert.equal(result.status, 0);\n   *     this.assert.equal(result.value, true);\n   *   });\n   * };\n   * ```\n   *\n   * @method isVisible\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdDisplayed\n   * @api commands\n   */\n  elementCommands.isVisible = 'elementIdDisplayed';\n\n  /**\n   * Move the mouse by an offset of the specified element. Uses `moveTo` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.moveToElement('#main', 10, 10);\n   * };\n   * ```\n   *\n   * @method moveToElement\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {number} xoffset X offset to move to, relative to the top-left corner of the element.\n   * @param {number} yoffset Y offset to move to, relative to the top-left corner of the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see moveTo\n   * @api commands\n   */\n  elementCommands.moveToElement = ['moveTo', 2];\n\n  /**\n   * Sends some text to an element. Can be used to set the value of a form element or to send a sequence of key strokes to an element. Any UTF-8 character may be specified.\n   *\n   * An object map with available keys and their respective UTF-8 characters, as defined on [W3C WebDriver draft spec](http://www.w3.org/TR/webdriver/#character-types), is loaded onto the main Nightwatch instance as `client.Keys`.\n   *\n   * ```\n   * // send some simple text to an input\n   * this.demoTest = function (browser) {\n   *   browser.setValue('input[type=text]', 'nightwatch');\n   * };\n   * //\n   * // send some text to an input and hit enter.\n   * this.demoTest = function (browser) {\n   *   browser.setValue('input[type=text]', ['nightwatch', browser.Keys.ENTER]);\n   * };\n   * ```\n   *\n   * @link /session/:sessionId/element/:id/value\n   * @method setValue\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {string|array} value The text to send to the element or key strokes.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see elementIdValue\n   * @api commands\n   */\n  elementCommands.setValue = ['elementIdValue', 1];\n\n  /**\n   * Submit a FORM element. The submit command may also be applied to any element that is a descendant of a FORM element. Uses `submit` protocol command.\n   *\n   * ```\n   * this.demoTest = function (browser) {\n   *   browser.submitForm('form.login');\n   * };\n   * ```\n   *\n   * @method submitForm\n   * @param {string} selector The CSS/Xpath selector used to locate the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @see submit\n   * @api commands\n   */\n  elementCommands.submitForm = 'submit';\n\n  function addElementCommand(protocolAction, extraArgs) {\n    extraArgs = extraArgs || 0;\n    var expectedArgs = 3 + extraArgs;\n    return function commandActionFn() {\n      var originalStackTrace = commandActionFn.stackTrace;\n      var noopFn = function() {};\n      var args  = Array.prototype.slice.call(arguments, 0);\n      if (typeof args[args.length-1] !== 'function') {\n        args.push(noopFn);\n      }\n\n      var defaultUsing = client.locateStrategy || 'css selector';\n      if (expectedArgs - args.length === 1) {\n        args.unshift(defaultUsing);\n      }\n\n      if (args.length < expectedArgs - 1 || args.length > expectedArgs) {\n        throw new Error(protocolAction + ' method expects ' + (expectedArgs - 1) + ' or ' + expectedArgs + ' arguments - ' + args.length + ' given.');\n      }\n\n      var using = args.shift();\n      var value = args.shift();\n      var callback = args.pop();\n\n      return new CommandAction(using, value, protocolAction, args, callback, originalStackTrace);\n    };\n  }\n\n  function CommandAction(using, value, protocolAction, args, callback, originalStackTrace) {\n    events.EventEmitter.call(this);\n\n    var $this = this;\n    var el = Protocol.element(using, value, function(result) {\n      if (result.status !== 0) {\n        callback.call(client.api, result);\n        var errorMessage = 'ERROR: Unable to locate element: \"' + value + '\" using: ' + using;\n        var stack = originalStackTrace.split('\\n');\n\n        stack.shift();\n        Utils.showStackTraceWithHeadline(errorMessage, stack);\n\n        client.results.errors++;\n        client.errors.push(errorMessage + '\\n' + stack.join('\\n'));\n\n        $this.emit('complete', el, $this);\n      } else {\n        result = result.value.ELEMENT;\n\n        args.push(function(r) {\n          callback.call(client.api, r);\n        });\n\n        args.unshift(result);\n\n        var c = Protocol[protocolAction].apply(Protocol, args).once('complete', function() {\n          $this.emit('complete', c, $this);\n        });\n      }\n    });\n  }\n\n  util.inherits(CommandAction, events.EventEmitter);\n\n  Object.keys(elementCommands).forEach(function(commandName) {\n    var args = elementCommands[commandName];\n    if (!Array.isArray(args)) {\n      args = [args];\n    }\n\n    returnValue[commandName] = addElementCommand.apply(client.api, args);\n  });\n\n  // alias\n  returnValue.sendKeys = returnValue.setValue;\n\n  return returnValue;\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect.js":"var util = require('util');\r\nvar events = require('events');\r\nvar chai = require('chai-nightwatch');\r\nvar expect = chai.expect;\r\nvar ChaiAssertion = chai.Assertion;\r\nvar Q = require('q');\r\nvar flag = chai.flag;\r\n\r\nmodule.exports = function(client) {\r\n  var Protocol = require('./protocol.js')(client);\r\n  var PresentAssertion = require('./expect/present.js');\r\n  var AttributeAssertion = require('./expect/attribute.js');\r\n  var CssAssertion = require('./expect/css.js');\r\n  var TextAssertion = require('./expect/text.js');\r\n  var EnabledAssertion = require('./expect/enabled.js');\r\n  var VisibleAssertion = require('./expect/visible.js');\r\n  var SelectedAssertion = require('./expect/selected.js');\r\n  var TypeAssertion = require('./expect/type.js');\r\n  var ValueAssertion = require('./expect/value.js');\r\n  var Expect = {};\r\n\r\n  ChaiAssertion.addMethod('before', function(ms) {\r\n    flag(this, 'waitFor', ms);\r\n    flag(this, 'before', true);\r\n  });\r\n\r\n  ChaiAssertion.addMethod('after', function(ms) {\r\n    flag(this, 'after', true);\r\n    flag(this, 'waitFor', ms);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('present', function() {\r\n    createAssertion(PresentAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('enabled', function() {\r\n    createAssertion(EnabledAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('text', function() {\r\n    createAssertion(TextAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('value', function() {\r\n    createAssertion(ValueAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('visible', function() {\r\n    createAssertion(VisibleAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addProperty('selected', function() {\r\n    createAssertion(SelectedAssertion, this);\r\n  });\r\n\r\n  ChaiAssertion.addMethod('attribute', function(attribute, msg) {\r\n    createAssertion(AttributeAssertion, this, [attribute, msg]);\r\n  });\r\n\r\n  ChaiAssertion.addMethod('css', function(property, msg) {\r\n    createAssertion(CssAssertion, this, [property, msg]);\r\n  });\r\n\r\n  function typeAssertion(type, msg) {\r\n    createAssertion(TypeAssertion, this, [type, msg]);\r\n  }\r\n\r\n  ChaiAssertion.addMethod('a', typeAssertion);\r\n  ChaiAssertion.addMethod('an', typeAssertion);\r\n\r\n  function createAssertion(AssertionClass, chaiAssert, args) {\r\n    function F() {\r\n      this.setAssertion(chaiAssert)\r\n        .setClient(client)\r\n        .setProtocol(Protocol)\r\n        .init();\r\n\r\n      return AssertionClass.apply(this, args);\r\n    }\r\n    F.prototype = AssertionClass.prototype;\r\n    chaiAssert.assertion = new F();\r\n  }\r\n\r\n  function Element(selector, using) {\r\n    this.selector = selector;\r\n    this.using = using;\r\n    this.startTime = null;\r\n    this.emitter = null;\r\n    this.createPromise();\r\n  }\r\n  util.inherits(Element, events.EventEmitter);\r\n\r\n  Element.prototype.getElementsCommand = function(callback) {\r\n    this.locator = this.using || client.locateStrategy || 'css selector';\r\n    return Protocol.elements(this.locator, this.selector, callback);\r\n  };\r\n\r\n  Element.prototype.promise = function() {\r\n    return this.deferred.promise;\r\n  };\r\n\r\n  Element.prototype.createPromise = function() {\r\n    this.deferred = Q.defer();\r\n    return this.deferred.promise;\r\n  };\r\n\r\n  Element.prototype.locate = function(emitter) {\r\n    if (emitter) {\r\n      this.emitter = emitter;\r\n      this.startTime = new Date().getTime();\r\n    }\r\n\r\n    this.getElementsCommand(function(result) {\r\n      if (result.status !== 0 || !result.value || result.value.length === 0) {\r\n        this.deferred.reject(result);\r\n      } else {\r\n        this.deferred.resolve(result.value[0]);\r\n      }\r\n    }.bind(this));\r\n  };\r\n\r\n  Expect.element = function(selector, using) {\r\n    var element = new Element(selector, using);\r\n    var promise = element.promise();\r\n    var expect  = chai.expect(promise);\r\n\r\n    flag(expect, 'selector', selector);\r\n    flag(expect, 'promise', promise);\r\n    flag(expect, 'element', element);\r\n\r\n    return {\r\n      element : element,\r\n      expect : expect\r\n    };\r\n  };\r\n\r\n  return Expect;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/protocol.js":"var elementByRecursion = require('./element-commands/_elementByRecursion.js');\nvar elementsByRecursion = require('./element-commands/_elementsByRecursion.js');\n\nmodule.exports = function(Nightwatch) {\n\n  var MOUSE_BUTTON_LEFT = 'left',\n      MOUSE_BUTTON_MIDDLE = 'middle',\n      MOUSE_BUTTON_RIGHT = 'right',\n      DIRECTION_UP = 'up',\n      DIRECTION_DOWN = 'down';\n\n  var Actions = {};\n\n  //////////////////////////////////////////////////////////////////\n  // Session related\n  //////////////////////////////////////////////////////////////////\n  /**\n   * Get info about, delete or create a new session. Defaults to the current session.\n   *\n   * ```\n   *  this.demoTest = function (browser) {\n   *    browser.session(function(result) {\n   *      console.log(result.value);\n   *    });\n   *\n   *    browser.session('delete', function(result) {\n   *      console.log(result.value);\n   *    });\n   *\n   *    browser.session('delete', '12345-abc', function(result) {\n   *      console.log(result.value);\n   *    });\n   *  };\n   * ```\n   *\n   * @link /session\n   * @param {string} [action] The http verb to use, can be \"get\", \"post\" or \"delete\". If only the callback is passed, get is assumed as default.\n   * @param {string} [sessionId] The id of the session to get info about or delete.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.session  = function(action, sessionId, callback) {\n    var options = {\n      path : '/session'\n    };\n\n    if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      sessionId = Nightwatch.sessionId;\n      action = 'get';\n    } else {\n      action = action.toLowerCase();\n      if (typeof arguments[1] === 'function') {\n        callback = arguments[1];\n        sessionId = Nightwatch.sessionId;\n      }\n    }\n\n    switch (action) {\n      case 'delete':\n        options.method = 'DELETE';\n        break;\n      case 'post':\n        options.method = 'POST';\n        break;\n      case 'get':\n        options.method = 'GET';\n        break;\n      default:\n        sessionId = arguments[0];\n        action = 'get';\n        options.method = 'GET';\n    }\n\n    if (action != 'post') {\n      options.path += '/' + sessionId;\n    }\n\n    return sendRequest(options, callback);\n  };\n\n  /**\n   * Returns a list of the currently active sessions.\n   *\n   * @link /sessions\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.sessions  = function(callback) {\n    var options = {\n      path : '/sessions',\n      method : 'GET'\n    };\n    return sendRequest(options, callback);\n  };\n\n  /**\n   * Configure the amount of time that a particular type of operation can execute for before they are aborted and a |Timeout| error is returned to the client.\n   *\n   * @link /session/:sessionId/timeouts\n   * @param {string} type The type of operation to set the timeout for. Valid values are: \"script\" for script timeouts, \"implicit\" for modifying the implicit wait timeout and \"page load\" for setting a page load timeout.\n   * @param {number} ms The amount of time, in milliseconds, that time-limited commands are permitted to run.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.timeouts  = function(type, ms, callback) {\n    var timeoutValues = ['script', 'implicit', 'page load'];\n    if (timeoutValues.indexOf(type) === -1) {\n      throw new Error('Invalid timeouts type value: ' + type + '. Possible values are: ' + timeoutValues.join(','));\n    }\n    if (typeof ms != 'number') {\n      throw new Error('Second argument must be number.');\n    }\n    return postRequest('/timeouts', {\n      type : type,\n      ms : ms\n    }, callback);\n  };\n\n  /**\n   * Set the amount of time, in milliseconds, that asynchronous scripts executed by /session/:sessionId/execute_async are permitted to run before they are aborted and a |Timeout| error is returned to the client.\n   *\n   * @link /session/:sessionId/timeouts/async_script\n   * @param {number} ms The amount of time, in milliseconds, that time-limited commands are permitted to run.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.timeoutsAsyncScript  = function(ms, callback) {\n    if (typeof ms != 'number') {\n      throw new Error('First argument must be number.');\n    }\n    return postRequest('/timeouts/async_script', {\n      ms : ms\n    }, callback);\n  };\n\n  /**\n   * Set the amount of time the driver should wait when searching for elements. If this command is never sent, the driver will default to an implicit wait of 0ms.\n   *\n   * @link /session/:sessionId/timeouts/implicit_wait\n   * @param {number} ms The amount of time, in milliseconds, that time-limited commands are permitted to run.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.timeoutsImplicitWait  = function(ms, callback) {\n    if (typeof ms != 'number') {\n      throw new Error('First argument must be number.');\n    }\n    return postRequest('/timeouts/implicit_wait', {\n      ms : ms\n    }, callback);\n  };\n\n  //////////////////////////////////////////////////////////////////\n  // Element related\n  //////////////////////////////////////////////////////////////////\n  /**\n   * Search for an element on the page, starting from the document root. The located element will be returned as a WebElement JSON object.\n   *\n   * @link /session/:sessionId/element\n   * @param {string} using The locator strategy to use.\n   * @param {string} value The search target.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.element = function(using, value, callback) {\n    if (using == 'recursion') {\n      return new elementByRecursion(Nightwatch).command(value, callback);\n    }\n\n    return element(using, value, callback);\n  };\n\n  /*!\n   * element protocol action\n   *\n   * @param {string} using\n   * @param {string} value\n   * @param {function} callback\n   * @private\n   */\n  function element(using, value, callback) {\n    var strategies = ['class name', 'css selector', 'id', 'name', 'link text',\n      'partial link text', 'tag name', 'xpath'];\n    using = using.toLocaleLowerCase();\n\n    if (strategies.indexOf(using) === -1) {\n      throw new Error('Provided locating strategy is not supported: ' +\n        using + '. It must be one of the following:\\n' +\n        strategies.join(', '));\n    }\n\n    return postRequest('/element', {\n      using: using,\n      value: value\n    }, callback);\n  }\n\n  /**\n   * Search for an element on the page, starting from the identified element. The located element will be returned as a WebElement JSON object.\n   *\n   * @link /session/:sessionId/element/:id/element\n   * @param {string} id ID of the element to route the command to.\n   * @param {string} using The locator strategy to use.\n   * @param {string} value The search target.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdElement = function(id, using, value, callback) {\n    var strategies = ['class name', 'css selector', 'id', 'name', 'link text',\n      'partial link text', 'tag name', 'xpath'];\n    using = using.toLocaleLowerCase();\n\n    if (strategies.indexOf(using) === -1) {\n      throw new Error('Provided locating strategy is not supported: ' +\n        using + '. It must be one of the following:\\n' +\n        strategies.join(', '));\n    }\n\n    return postRequest('/element/' + id + '/element', {\n      using: using,\n      value: value\n    }, callback);\n  };\n\n  /**\n   * Search for multiple elements on the page, starting from the document root. The located elements will be returned as a WebElement JSON objects.\n   * Valid strings to use as locator strategies are: \"class name\", \"css selector\", \"id\", \"name\", \"link text\", \"partial link text\", \"tag name\", \"xpath\"\n   *\n   * @link /session/:sessionId/elements\n   * @param {string} using The locator strategy to use.\n   * @param {string} value The search target.\n   * @param {function} callback Callback function to be invoked with the result when the command finishes.\n   * @api protocol\n   */\n  Actions.elements = function(using, value, callback) {\n    if (using == 'recursion') {\n      return new elementsByRecursion(Nightwatch).command(value, callback);\n    }\n\n    return elements(using, value, callback);\n  };\n\n  /*!\n   * elements protocol action\n   *\n   * @param {string} using\n   * @param {string} value\n   * @param {function} callback\n   * @private\n   */\n  function elements(using, value, callback) {\n    var check = /class name|css selector|id|name|link text|partial link text|tag name|xpath/gi;\n    if (!check.test(using)) {\n      throw new Error('Please provide any of the following using strings as the first parameter: ' +\n        'class name, css selector, id, name, link text, partial link text, tag name, or xpath. Given: ' + using);\n    }\n\n    return postRequest('/elements', {\n      using: using,\n      value: value\n    }, callback);\n  }\n\n  /**\n   * Search for multiple elements on the page, starting from the identified element. The located element will be returned as a WebElement JSON objects.\n   *\n   * @link /session/:sessionId/element/:id/elements\n   * @param {string} id ID of the element to route the command to.\n   * @param {string} using The locator strategy to use.\n   * @param {string} value The search target.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdElements = function(id, using, value, callback) {\n    var strategies = ['class name', 'css selector', 'id', 'name', 'link text',\n      'partial link text', 'tag name', 'xpath'];\n    using = using.toLocaleLowerCase();\n\n    if (strategies.indexOf(using) === -1) {\n      throw new Error('Provided locating strategy is not supported: ' +\n        using + '. It must be one of the following:\\n' +\n        strategies.join(', '));\n    }\n\n    return postRequest('/element/' + id + '/elements', {\n      using: using,\n      value: value\n    }, callback);\n  };\n\n  /**\n   * Get the element on the page that currently has focus.\n   *\n   * @link /session/:sessionId/element/active\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementActive = function(callback) {\n    return postRequest('/element/active', {}, callback);\n  };\n\n  /**\n   * Get the value of an element's attribute.\n   *\n   * @link /session/:sessionId/element/:id/attribute/:name\n   * @param {string} id ID of the element to route the command to.\n   * @param {string} attributeName The attribute name\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdAttribute = function(id, attributeName, callback) {\n    return getRequest('/element/' + id + '/attribute/' + attributeName, callback);\n  };\n\n  /**\n   * Click on an element.\n   *\n   * @link /session/:sessionId/element/:id/click\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdClick = function(id, callback) {\n    return postRequest('/element/' + id + '/click', '', callback);\n  };\n\n  /**\n   * Query the value of an element's computed CSS property.\n   *\n   *\n   * The CSS property to query should be specified using the CSS property name, not the JavaScript property name (e.g. background-color instead of backgroundColor).\n   *\n   * @link /session/:sessionId/element/:id/css/:propertyName\n   * @param {string} id ID of the element to route the command to.\n   * @param {string} cssPropertyName\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdCssProperty = function(id, cssPropertyName, callback) {\n    return getRequest('/element/' + id + '/css/' + cssPropertyName, callback);\n  };\n\n  /**\n   * Determine if an element is currently displayed.\n   *\n   * @link /session/:sessionId/element/:id/displayed\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdDisplayed = function(id, callback) {\n    return getRequest('/element/' + id + '/displayed', callback);\n  };\n\n  /**\n   * Determine an element's location on the screen once it has been scrolled into view.\n   *\n   * @link /session/:sessionId/element/:id/location_in_view\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdLocationInView = function(id, callback) {\n    return getRequest('/element/' + id + '/location_in_view', callback);\n  };\n\n  /**\n   * Determine an element's location on the page. The point (0, 0) refers to the upper-left corner of the page.\n   *\n   * The element's coordinates are returned as a JSON object with x and y properties.\n   *\n   * @link /session/:sessionId/element/:id/location\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   * @returns {x:number, y:number} The X and Y coordinates for the element on the page.\n   */\n  Actions.elementIdLocation = function(id, callback) {\n    return getRequest('/element/' + id + '/location', callback);\n  };\n\n\n  /**\n   * Query for an element's tag name.\n   *\n   * @link /session/:sessionId/element/:id/name\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdName = function(id, callback) {\n    return getRequest('/element/' + id + '/name', callback);\n  };\n\n  /**\n   * Clear a TEXTAREA or text INPUT element's value.\n   *\n   * @link /session/:sessionId/element/:id/clear\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdClear = function(id, callback) {\n    return postRequest('/element/' + id + '/clear', callback);\n  };\n\n  /**\n   * Determine if an OPTION element, or an INPUT element of type checkbox or radio button is currently selected.\n   *\n   * @link /session/:sessionId/element/:id/selected\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdSelected = function(id, callback) {\n    return getRequest('/element/' + id + '/selected', callback);\n  };\n\n  /**\n   * Determine if an element is currently enabled.\n   *\n   * @link /session/:sessionId/element/:id/enabled\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdEnabled = function(id, callback) {\n    return getRequest('/element/' + id + '/enabled', callback);\n  };\n\n  /**\n   * Test if two element IDs refer to the same DOM element.\n   *\n   * @link /session/:sessionId/element/:id/equals/:other\n   * @param {string} id ID of the element to route the command to.\n   * @param {string} otherId ID of the element to compare against.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdEquals = function(id, otherId, callback) {\n    return getRequest('/element/' + id + '/equals/' + otherId, callback);\n  };\n\n  /**\n   * Determine an element's size in pixels. The size will be returned as a JSON object with width and height properties.\n   *\n   * @link /session/:sessionId/element/:id/size\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdSize = function(id, callback) {\n    return getRequest('/element/' + id + '/size', callback);\n  };\n\n  /**\n   * Returns the visible text for the element.\n   *\n   * @link /session/:sessionId/element/:id/text\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdText = function(id, callback) {\n    return getRequest('/element/' + id + '/text', callback);\n  };\n\n\n  /**\n   * Send a sequence of key strokes to an element or returns the current value of the element.\n   *\n   * @link /session/:sessionId/element/:id/value\n   * @param {string} id ID of the element to route the command to.\n   * @param {string|array|none} [value] Value to send to element in case of a POST\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.elementIdValue = function(id, value, callback) {\n    if (arguments.length === 2 && typeof arguments[1] === 'function') {\n      callback = arguments[1];\n      return getRequest('/element/' + id + '/attribute/value', callback);\n    }\n\n    if (Array.isArray(value)) {\n      value = value.join('');\n    } else {\n      value = String(value);\n    }\n\n    return postRequest('/element/' + id + '/value', {\n      value: value.split('')\n    }, callback);\n  };\n\n  /**\n   * Submit a FORM element. The submit command may also be applied to any element that is a descendant of a FORM element.\n   *\n   * @link /session/:sessionId/element/:id/submit\n   * @param {string} id ID of the element to route the command to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.submit = function(id, callback) {\n    return postRequest('/element/' + id + '/submit', '', callback);\n  };\n\n  /**\n   * Get the current page source.\n   *\n   * @link /session/:sessionId/source\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.source = function(callback) {\n    return getRequest('/source', callback);\n  };\n\n\n\n  //////////////////////////////////////////////////////////////////\n  // Context related\n  //////////////////////////////////////////////////////////////////\n\n  /**\n   * Get a list of the available contexts.\n   *\n   * Used by Appium when testing hybrid mobile web apps. More info here: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/hybrid.md.\n   *\n   * @param {function} callback Callback function to be called when the command finishes.\n   * @returns {Array} an array of strings representing available contexts, e.g 'WEBVIEW', or 'NATIVE'\n   * @api protocol\n   */\n  Actions.contexts = function(callback) {\n    return getRequest('/contexts', callback);\n  };\n\n /**\n  *\n  * Get current context.\n  *\n  * @param {function} callback Callback function to be called when the command finishes.\n  * @returns {string|null} a string representing the current context or `null`, representing \"no context\"\n  * @api protocol\n  */\n  Actions.currentContext = function(callback) {\n    return getRequest('/context', callback);\n  };\n\n  /**\n   * Sets the context.\n   *\n   * @param {string} context context name to switch to - a string representing an available context.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.setContext = function (context, callback) {\n    var data = {\n      name: context\n    };\n    return postRequest('/context', data, callback);\n  };\n\n  //////////////////////////////////////////////////////////////////\n  // Orientation\n  //////////////////////////////////////////////////////////////////\n\n  /**\n   * Get the current browser orientation.\n   *\n   * @param {function} callback Callback function to be called when the command finishes.\n   * @returns {string} The current browser orientation: {LANDSCAPE|PORTRAIT}\n   * @api protocol\n   */\n  Actions.getOrientation  = function(callback) {\n    return getRequest('/orientation', callback);\n  };\n\n  /**\n   * Sets the browser orientation.\n   *\n   * @param {string} orientation The new browser orientation: {LANDSCAPE|PORTRAIT}\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.setOrientation = function (orientation, callback) {\n    orientation = orientation.toUpperCase();\n    var accepted = ['LANDSCAPE', 'PORTRAIT'];\n    if (accepted.indexOf(orientation) == -1) {\n      throw new Error('Invalid orientation value specified. Accepted values are: ' + accepted.join(', '));\n    }\n\n    return postRequest('/orientation', {\n      orientation : orientation\n    }, callback);\n  };\n\n  //////////////////////////////////////////////////////////////////\n  // Mouse related\n  //////////////////////////////////////////////////////////////////\n\n  /**\n   * Move the mouse by an offset of the specificed element. If no element is specified, the move is relative to the current mouse cursor. If an element is provided but no offset, the mouse will be moved to the center of the element.\n   *\n   * If the element is not visible, it will be scrolled into view.\n   *\n   * @link /session/:sessionId/moveto\n   * @param {string} element Opaque ID assigned to the element to move to. If not specified or is null, the offset is relative to current position of the mouse.\n   * @param {number} xoffset X offset to move to, relative to the top-left corner of the element. If not specified, the mouse will move to the middle of the element.\n   * @param {number} yoffset Y offset to move to, relative to the top-left corner of the element. If not specified, the mouse will move to the middle of the element.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.moveTo = function(element, xoffset, yoffset, callback) {\n    var data = {};\n    if (typeof element == 'string') {\n      data.element = element;\n    }\n    if (typeof xoffset == 'number') {\n      data.xoffset = xoffset;\n    }\n    if (typeof yoffset == 'number') {\n      data.yoffset = yoffset;\n    }\n    return postRequest('/moveto', data, callback);\n  };\n\n  /**\n   * Double-clicks at the current mouse coordinates (set by moveto).\n   *\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.doubleClick = function(callback) {\n    return postRequest('/doubleclick', callback);\n  };\n\n  /**\n   * Click at the current mouse coordinates (set by moveto).\n   *\n   * The button can be (0, 1, 2) or ('left', 'middle', 'right'). It defaults to left mouse button, and if you don't pass in a button but do pass in a callback, it will handle it correctly.\n   *\n   * @link /session/:sessionId/click\n   * @param {string|number} button The mouse button\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.mouseButtonClick = function(button, callback) {\n    var buttonIndex;\n    if (arguments.length === 0) {\n      button = 0;\n    } else {\n      if (typeof(button) === 'function') {\n        callback = button;\n        button = 0;\n      }\n\n      if (typeof button === 'string') {\n        buttonIndex = [\n          MOUSE_BUTTON_LEFT,\n          MOUSE_BUTTON_MIDDLE,\n          MOUSE_BUTTON_RIGHT\n        ].indexOf(button.toLowerCase());\n\n        if (buttonIndex !== -1) {\n          button = buttonIndex;\n        }\n      }\n    }\n\n    return postRequest('/click', {button: button}, callback);\n  };\n\n  /**\n   * Click and hold the left mouse button (at the coordinates set by the last moveto command). Note that the next mouse-related command that should follow is `mouseButtonUp` . Any other mouse command (such as click or another call to buttondown) will yield undefined behaviour.\n   *\n   * Can be used for implementing drag-and-drop. The button can be (0, 1, 2) or ('left', 'middle', 'right'). It defaults to left mouse button, and if you don't pass in a button but do pass in a callback, it will handle it correctly.\n   *\n   * @link /session/:sessionId/buttondown\n   * @param {string|number} button The mouse button\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.mouseButtonDown = function(button, callback) {\n    return mouseButtonHandler(DIRECTION_DOWN, button, callback);\n  };\n\n  /**\n   * Releases the mouse button previously held (where the mouse is currently at). Must be called once for every `mouseButtonDown` command issued.\n   *\n   * Can be used for implementing drag-and-drop. The button can be (0, 1, 2) or ('left', 'middle', 'right'). It defaults to left mouse button, and if you don't pass in a button but do pass in a callback, it will handle it correctly.\n   *\n   * @link /session/:sessionId/buttonup\n   * @param {string|number} button The mouse button\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.mouseButtonUp = function(button, callback) {\n    return mouseButtonHandler(DIRECTION_UP, button, callback);\n  };\n\n  /*!\n   * Helper function for mouseButton actions\n   *\n   * @param {string} direction\n   * @param {string|number} button\n   * @param {function} callback\n   * @private\n   */\n  function mouseButtonHandler(direction, button, callback) {\n    var buttonIndex;\n    if (typeof(button) === 'function') {\n      callback = button;\n      button = 0;\n    }\n\n    if (typeof button === 'string') {\n      buttonIndex = [\n        MOUSE_BUTTON_LEFT,\n        MOUSE_BUTTON_MIDDLE,\n        MOUSE_BUTTON_RIGHT\n      ].indexOf(button.toLowerCase());\n\n      if (buttonIndex !== -1) {\n        button = buttonIndex;\n      }\n    }\n\n    return postRequest('/button' + direction, {button: button}, callback);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Window specific commands\n  /////////////////////////////////////////////////////////////////////////////\n  /*!\n   * Helper function for execute and execute_async\n   *\n   * @param {string} path\n   * @param {string|function} script\n   * @param {Array} args\n   * @param {function} callback\n   * @private\n   */\n  function executeHandler(path, script, args, callback) {\n    var fn;\n\n    if (typeof script === 'function') {\n      fn = 'var passedArgs = Array.prototype.slice.call(arguments,0); return ' +\n        script.toString() + '.apply(window, passedArgs);';\n    } else {\n      fn = script;\n    }\n\n    if (arguments.length === 2) {\n      args = [];\n    } else if ((arguments.length === 3) && (typeof arguments[2] === 'function')) {\n      callback = arguments[2];\n      args = [];\n    }\n\n    return postRequest(path, {\n      script: fn,\n      args: args\n    }, callback);\n  }\n\n  /**\n   * Inject a snippet of JavaScript into the page for execution in the context of the currently selected frame. The executed script is assumed to be synchronous and the result of evaluating the script is returned to the client.\n   * The script argument defines the script to execute in the form of a function body. The value returned by that function will be returned to the client.\n   *\n   * The function will be invoked with the  provided args array and the values may be accessed via the arguments object in the order specified.\n   *\n   * ```\n   *  this.demoTest = function (browser) {\n   *    browser.execute(function(data) {\n   *      // resize operation\n   *      return true;\n   *    }, [imagedata], function(result) {\n   *      ...\n   *    });\n   *  };\n   * ```\n   *\n   * @link /session/:sessionId/execute\n   * @param {string|function} body The function body to be injected.\n   * @param {Array} args An array of arguments which will be passed to the function.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   * @returns {*} The script result.\n   */\n  Actions.execute = function(body, args, callback) {\n    var executeArgs = Array.prototype.slice.call(arguments, 0);\n    executeArgs.unshift('/execute');\n\n    return executeHandler.apply(null, executeArgs);\n  };\n\n  /**\n   * Inject a snippet of JavaScript into the page for execution in the context of the currently selected frame. The executed script is assumed to be asynchronous and the result of evaluating the script is returned to the client.\n   *\n   * Asynchronous script commands may not span page loads. If an unload event is fired while waiting for a script result, an error should be returned to the client.\n   *\n   * ```\n   *  this.demoTest = function (browser) {\n   *    browser.executeAsync(function(data, done) {\n   *      someAsyncOperation(function() {\n   *        done(true);\n   *      });\n   *    }, [imagedata], function(result) {\n   *      // ...\n   *    });\n   *  };\n   * ```\n   *\n   * @link /session/:sessionId/execute_async\n   * @param {string|function} script The function body to be injected.\n   * @param {Array} args An array of arguments which will be passed to the function.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   * @returns {*} The script result.\n   */\n  Actions.executeAsync = function(script, args, callback) {\n    args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('/execute_async');\n\n    return executeHandler.apply(null, args);\n  };\n\n  /*!\n   * @deprecated\n   */\n  Actions.execute_async = Actions.executeAsync;\n\n  /**\n   * Change focus to another frame on the page. If the frame id is missing or null, the server should switch to the page's default content.\n   *\n   * @link /session/:sessionId/frame\n   * @param {string|number|null} [frameId] Identifier for the frame to change focus to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.frame = function(frameId, callback) {\n    if (arguments.length === 1 && typeof frameId === 'function') {\n      callback = frameId;\n      return postRequest('/frame', callback);\n    }\n\n    return postRequest('/frame', {\n      id: frameId\n    }, callback);\n  };\n\n  /**\n   * Change focus to the parent context. If the current context is the top level browsing context, the context remains unchanged.\n   *\n   * @link /session/:sessionId/frame/parent\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @since v0.4.8\n   * @api protocol\n   */\n  Actions.frameParent = function(callback) {\n    return postRequest('/frame/parent', callback);\n  };\n\n  /**\n   * Change focus to another window or close the current window.\n   *\n   * @link /session/:sessionId/window\n   * @param {string} method The HTTP method to use\n   * @param {string} handleOrName The window to change focus to.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @since v0.3.0\n   * @api protocol\n   */\n  Actions.window = function(method, handleOrName, callback) {\n    method = method.toUpperCase();\n\n    switch (method) {\n      case 'POST':\n        if (arguments.length < 2) {\n          throw new Error('POST requests to /window must include a name parameter also.');\n        }\n\n        return postRequest('/window', {\n          name : handleOrName\n        }, callback);\n\n      case 'DELETE':\n        return deleteRequest('/window', arguments[1]);\n      default:\n        throw new Error('This method expects first argument to be either POST or DELETE.');\n    }\n  };\n\n  /**\n   * Retrieve the current window handle.\n   *\n   * @link /session/:sessionId/window_handle\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.windowHandle =  function(callback) {\n    return getRequest('/window_handle', callback);\n  };\n\n\n  /**\n   * Retrieve the current window handle.\n   *\n   * @link /session/:sessionId/window/:windowHandle/maximize\n   * @param {string} [handleOrName] windowHandle URL parameter; if it is \"current\", the currently active window will be maximized.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.windowMaximize = function(handleOrName, callback) {\n    return postRequest('/window/'+ handleOrName + '/maximize', callback);\n  };\n\n  /*!\n   * @deprecated\n   */\n  Actions.window_handle = Actions.windowHandle;\n\n  /**\n   * Retrieve the list of all window handles available to the session.\n   *\n   * @link /session/:sessionId/window_handles\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.windowHandles = function(callback) {\n    return getRequest('/window_handles', callback);\n  };\n\n  /*!\n   * @deprecated\n   */\n  Actions.window_handles = Actions.windowHandles;\n\n  /**\n   * Change or get the size of the specified window. If the second argument is a function it will be used as a callback and the call will perform a get request to retrieve the existing window size.\n   *\n   * @link /session/:sessionId/window/:windowHandle/size\n   * @param {string} windowHandle\n   * @param {number} width\n   * @param {number} height\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.windowSize = function(windowHandle, width, height, callback) {\n    if (typeof windowHandle !== 'string') {\n      throw new Error('First argument must be a window handle string.');\n    }\n\n    var path = '/window/' + windowHandle + '/size';\n    if (arguments.length === 2 && typeof arguments[1] === 'function') {\n      return getRequest(path, arguments[1]);\n    }\n\n    width = Number(width);\n    height = Number(height);\n\n    if (typeof width !== 'number' || isNaN(width)) {\n      throw new Error('Width and height arguments must be passed as numbers.');\n    }\n\n    if (typeof height !== 'number' || isNaN(height)) {\n      throw new Error('Width and height arguments must be passed as numbers.');\n    }\n\n    return postRequest(path, {\n      width : width,\n      height : height\n    }, callback);\n  };\n\n  /**\n   * Change or get the position of the specified window. If the second argument is a function it will be used as a callback and the call will perform a get request to retrieve the existing window position.\n   *\n   * @link /session/:sessionId/window/:windowHandle/position\n   * @param {string} windowHandle\n   * @param {number} offsetX\n   * @param {number} offsetY\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.windowPosition = function(windowHandle, offsetX, offsetY, callback) {\n    if (typeof windowHandle !== 'string') {\n      throw new Error('First argument must be a window handle string.');\n    }\n\n    var path = '/window/' + windowHandle + '/position';\n    if (arguments.length === 2 && typeof arguments[1] === 'function') {\n      return getRequest(path, arguments[1]);\n    }\n\n    offsetX = Number(offsetX);\n    offsetY = Number(offsetY);\n\n    if (typeof offsetX !== 'number' || isNaN(offsetX)) {\n      throw new Error('Offset arguments must be passed as numbers.');\n    }\n\n    if (typeof offsetY !== 'number' || isNaN(offsetY)) {\n      throw new Error('Offset arguments must be passed as numbers.');\n    }\n\n    return postRequest(path, {\n      x : offsetX,\n      y : offsetY\n    }, callback);\n  };\n\n  /**\n   * Refresh the current page.\n   *\n   * @link /session/:sessionId/refresh\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.refresh = function(callback) {\n    return postRequest('/refresh', callback);\n  };\n\n  /**\n   * Navigate backwards in the browser history, if possible.\n   *\n   * @link /session/:sessionId/back\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.back = function(callback) {\n    return postRequest('/back', callback);\n  };\n\n  /**\n   * Navigate forwards in the browser history, if possible.\n   *\n   * @link /session/:sessionId/back\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.forward = function(callback) {\n    return postRequest('/forward', callback);\n  };\n\n  /**\n   * Take a screenshot of the current page.\n   *\n   * @link /session/:sessionId/screenshot\n   * @param {boolean} log_screenshot_data Whether or not the screenshot data should appear in the logs when running with --verbose\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.screenshot = function(log_screenshot_data, callback) {\n    return getRequest('/screenshot', callback).on('beforeResult', function(result) {\n      result = result || {};\n      if (!log_screenshot_data) {\n        result.suppressBase64Data = true;\n      }\n    });\n  };\n\n  /**\n   * Retrieve the URL of the current page or navigate to a new URL.\n   *\n   * @link /session/:sessionId/url\n   * @param {string|function} [url] If missing, it will return the URL of the current page as an argument to the supplied callback\n   * @param {Function} [callback]\n   * @api protocol\n   */\n  Actions.url = function(url, callback) {\n    if (typeof url == 'string') {\n      return postRequest('/url', {\n        url : url\n      }, callback);\n    }\n\n    if (typeof url == 'function') {\n      callback = url;\n    }\n\n    return getRequest('/url', callback);\n  };\n\n  /**\n   * Query the server's current status.\n   *\n   * @link /status\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.status = function(callback) {\n    return sendRequest({\n      method : 'GET',\n      path   : '/status'\n    }, callback);\n  };\n\n  /**\n   * Get the current page title.\n   *\n   * @link /session/:sessionId/title\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.title = function(callback) {\n    return getRequest('/title', callback);\n  };\n\n  /**\n   * Send a sequence of key strokes to the active element. The sequence is defined in the same format as the `sendKeys` command.\n   * An object map with available keys and their respective UTF-8 characters, as defined on [W3C WebDriver draft spec](http://www.w3.org/TR/webdriver/#character-types), is loaded onto the main Nightwatch instance as `client.Keys`.\n   *\n   * Rather than the `setValue`, the modifiers are not released at the end of the call. The state of the modifier keys is kept between calls, so mouse interactions can be performed while modifier keys are depressed.\n   *\n   * @link /session/:sessionId/keys\n   * @param {Array} keysToSend The keys sequence to be sent.\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.keys = function(keysToSend, callback) {\n    if (!Array.isArray(keysToSend)) {\n      keysToSend = [keysToSend];\n    }\n    return postRequest('/keys', {\n      value: keysToSend\n    }, callback);\n  };\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Cookies\n  /////////////////////////////////////////////////////////////////////////////\n  /**\n   * Retrieve or delete all cookies visible to the current page or set a cookie.\n   *\n   * @link /session/:sessionId/cookie\n   * @param {string} method Http method\n   * @param {function|object} [callbackOrCookie] Optional callback function to be called when the command finishes.\n   * @since v0.4.0\n   * @api protocol\n   */\n  Actions.cookie = function(method, callbackOrCookie) {\n    switch (method) {\n      case 'GET':\n        return getRequest('/cookie', callbackOrCookie);\n      case 'POST':\n        if (arguments.length < 2) {\n          throw new Error('POST requests to /cookie must include a cookie object parameter also.');\n        }\n        return postRequest('/cookie', {\n          cookie : callbackOrCookie\n        }, arguments[2]);\n      case 'DELETE':\n        if (typeof callbackOrCookie === 'undefined' || typeof callbackOrCookie === 'function') {\n          return deleteRequest('/cookie', callbackOrCookie);\n        }\n        return deleteRequest('/cookie/' + callbackOrCookie, arguments[2]);\n      default:\n        throw new Error('This method expects first argument to be either GET, POST or DELETE.');\n    }\n  };\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Alert handling\n  /////////////////////////////////////////////////////////////////////////////\n  /**\n   * Accepts the currently displayed alert dialog. Usually, this is equivalent to clicking on the 'OK' button in the dialog.\n   *\n   * @link /session/:sessionId/accept_alert\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.acceptAlert = function(callback) {\n    return postRequest('/accept_alert', callback);\n  };\n\n  /*!\n   * @deprecated\n   */\n  Actions.accept_alert = Actions.acceptAlert;\n\n  /**\n   * Dismisses the currently displayed alert dialog. For confirm() and prompt() dialogs, this is equivalent to clicking the 'Cancel' button.\n   *\n   * For alert() dialogs, this is equivalent to clicking the 'OK' button.\n   *\n   * @link /session/:sessionId/dismiss_alert\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.dismissAlert = function(callback) {\n    return postRequest('/dismiss_alert', callback);\n  };\n\n  /**\n   * Sends keystrokes to a JavaScript prompt() dialog.\n   *\n   * @link /session/:sessionId/alert_text\n   * @param {string} value Keystrokes to send to the prompt() dialog\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @api protocol\n   */\n  Actions.setAlertText = function(value, callback) {\n    return postRequest('/alert_text', {text: value}, callback);\n  };\n\n  /**\n   * Gets the text of the currently displayed JavaScript alert(), confirm(), or prompt() dialog.\n   *\n   * @link /session/:sessionId/alert_text\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @returns {string} The text of the currently displayed alert.\n   * @api protocol\n   */\n  Actions.getAlertText = function(callback) {\n    return getRequest('/alert_text', callback);\n  };\n\n  /*!\n   * @deprecated\n   */\n  Actions.dismiss_alert = Actions.dismissAlert;\n\n\n  /**\n   * Gets the text of the log type specified\n   *\n   * @link /session/:sessionId/log\n   * @param {string} typeString Type of log to request\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @returns {Array} Array of the text entries of the log.\n   * @api protocol\n   */\n  Actions.sessionLog = function(typeString, callback) {\n    return postRequest('/log', {type: typeString}, callback);\n  };\n\n  /**\n   * Gets an array of strings for which log types are available.\n   *\n   * @link /session/:sessionId/log/types\n   * @param {function} [callback] Optional callback function to be called when the command finishes.\n   * @returns {Array} Available log types\n   * @api protocol\n   */\n  Actions.sessionLogTypes = function(callback) {\n    return getRequest('/log/types', callback);\n  };\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Helpers\n  /////////////////////////////////////////////////////////////////////////////\n  function getRequest(path, callback) {\n    var options = {\n      path : '/session/' + Nightwatch.sessionId + path,\n      method : 'GET'\n    };\n    return sendRequest(options, callback);\n  }\n\n  function deleteRequest(path, callback) {\n    var options = {\n      path : '/session/' + Nightwatch.sessionId + path,\n      method : 'DELETE'\n    };\n    return sendRequest(options, callback);\n  }\n\n  function postRequest(path, data, callback) {\n    if (arguments.length === 2 && typeof data === 'function') {\n      callback = data;\n      data = '';\n    }\n    var options = {\n      path : '/session/' + Nightwatch.sessionId + path,\n      method : 'POST',\n      data : data || ''\n    };\n    return sendRequest(options, callback);\n  }\n\n  function sendRequest(options, callback) {\n    callback = callback || function() {};\n    return Nightwatch.runProtocolAction(options, callback).send();\n  }\n\n  return Actions;\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/_elementByRecursion.js":"var util = require('util');\nvar events = require('events');\n\n/**\n * Search for an element on the page, starting with the first element of the array, and where each element in the passed array is nested under the previous one. The located element will be returned as a WebElement JSON object.\n *\n * @param {Array} elements An array of ancestor element objects containing selector and locateStrategy properties\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api protocol\n */\n\nfunction ElementByRecursion(client) {\n  events.EventEmitter.call(this);\n  this.protocol = require('../protocol.js')(client);\n}\n\nutil.inherits(ElementByRecursion, events.EventEmitter);\n\nElementByRecursion.prototype.command = function(elements, callback) {\n  var self = this;\n  var allElements = elements.slice();\n\n  var topElement = allElements.shift();\n  var el = this.protocol.element(topElement.locateStrategy, topElement.selector, function checkResult(result) {\n    if (result.status !== 0) {\n      callback(result);\n      self.emit('complete', el, self);\n    } else {\n      var nextElement = allElements.shift();\n      var parentId = result.value.ELEMENT;\n      if (nextElement) {\n        self.protocol.elementIdElement(parentId, nextElement.locateStrategy, nextElement.selector, checkResult);\n      } else {\n        callback(result);\n        self.emit('complete', el, self);\n      }\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = ElementByRecursion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/_elementsByRecursion.js":"var util = require('util');\nvar events = require('events');\nvar Q = require('q');\n\n/**\n * Search for multiple elements on the page, starting with the first element of the array, and where each element in the passed array is nested under the previous one. The located element will be returned as a WebElement JSON objects.\n *\n * @param {Array} elements An array of ancestor element objects containing selector and locateStrategy properties\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api protocol\n */\n\nfunction ElementsByRecursion(client) {\n  events.EventEmitter.call(this);\n  this.protocol = require('../protocol.js')(client);\n}\n\nutil.inherits(ElementsByRecursion, events.EventEmitter);\n\nElementsByRecursion.prototype.command = function(elements, callback) {\n  var self = this;\n\n  function deferredElementIdElements(el, using, value) {\n    var deferred = Q.defer();\n    var req = self.protocol.elementIdElements(el, using, value, function(result) {\n      deferred.resolve(result);\n    });\n    req.on('error', function() {\n      deferred.reject();\n    });\n    return deferred.promise;\n  }\n\n  function createResult(result, foundElements) {\n    return {\n      status: 0,\n      sessionId: result.sessionId,\n      value: foundElements.map(function(e) {\n        return {\n          ELEMENT: e\n        };\n      }),\n      class: result.class,\n      hCode: result.hCode\n    };\n  }\n\n  function aggregateResults(results) {\n    var result;\n    var foundElements = [];\n    for (var i = 0; i < results.length; i++) {\n      result = results[i];\n      if (result.status === 0 && result.value && result.value.length) {\n        result.value.forEach(function(e) {\n          if (foundElements.indexOf(e.ELEMENT) <= -1) {\n            // In case we have multiple matches on the same element, only add once\n            foundElements.push(e.ELEMENT);\n          }\n        });\n      }\n    }\n    return createResult(result, foundElements);\n  }\n\n  var allElements = elements.slice();\n  var topElement = allElements.shift();\n\n  var el = this.protocol.elements(topElement.locateStrategy, topElement.selector, function checkResult() {\n    var result = aggregateResults(arguments);\n    if (result.value.length === 0) {\n      callback(result);\n      self.emit('complete', el, self);\n      return;\n    }\n\n    var nextElement = allElements.shift();\n    if (nextElement) {\n      var promises = [];\n      result.value.forEach(function(el) {\n        var p = deferredElementIdElements(el.ELEMENT, nextElement.locateStrategy, nextElement.selector, checkResult);\n        promises.push(p);\n      });\n\n      Q.all(promises).spread(checkResult);\n    } else {\n      callback(result);\n      self.emit('complete', el, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = ElementsByRecursion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/element.js":"/**\n * Class that all elements subclass from\n *\n * @param {Object} options Element options defined in page object\n * @constructor\n */\nfunction Element(options) {\n  this.parent = options.parent;\n\n  if (!options.selector) {\n    throw new Error('No selector property for element \"' + options.name +\n      '\" Instead found properties: ' + Object.keys(options));\n  }\n\n  this.name = options.name;\n  this.selector = options.selector;\n  this.locateStrategy = options.locateStrategy || 'css selector';\n}\n\nElement.prototype.toString = function() {\n  return 'Element[name=@' + this.name + ']';\n};\n\nmodule.exports = Element;","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/page-object/section.js":"var PageUtils = require('./page-utils.js');\nvar CommandWrapper = require('./command-wrapper.js');\n\n/**\n * Class that all sections subclass from\n *\n * @param {Object} options Section options defined in page object\n * @constructor\n */\nfunction Section(options) {\n  this.parent = options.parent;\n  this.client = this.parent.client;\n\n  if(!options.selector) {\n    throw new Error('No selector property for section \"' + options.name +\n      '\" Instead found properties: ' + Object.keys(options));\n  }\n\n  this.name = options.name;\n  this.selector = options.selector;\n  this.locateStrategy = options.locateStrategy || 'css selector';\n  this.api = this.parent.api;\n  this.commandLoader = this.parent.commandLoader;\n\n  PageUtils\n    .createProps(this, options.props || {})\n    .createElements(this, options.elements || {})\n    .createSections(this, options.sections || {})\n    .addCommands(this, options.commands || []);\n\n  CommandWrapper.addWrappedCommands(this, this.commandLoader);\n}\n\nSection.prototype.toString = function() {\n  return 'Section[name=' + this.name + ']';\n};\n\nmodule.exports = Section;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/attributeContains.js":"/**\n * Checks if the given attribute of an element contains the expected value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.attributeContains('#someElement', 'href', 'google.com');\n *    };\n * ```\n *\n * @method attributeContains\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} attribute The attribute name\n * @param {string} expected The expected contained value of the attribute to check.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, attribute, expected, msg) {\n  var DEFAULT_MSG = 'Testing if attribute %s of <%s> contains \"%s\".';\n  var MSG_ELEMENT_NOT_FOUND = DEFAULT_MSG + ' ' + 'Element could not be located.';\n  var MSG_ATTR_NOT_FOUND = DEFAULT_MSG + ' ' + 'Element does not have a ' + attribute + ' attribute.';\n\n  this.message = msg || util.format(DEFAULT_MSG, attribute, selector, expected);\n\n  this.expected = function() {\n    return expected;\n  };\n\n  this.pass = function(value) {\n    return value.indexOf(expected) > -1;\n  };\n\n  this.failure = function(result) {\n    var failed = (result === false) ||\n      // no such element\n      result && (result.status === -1 || result.value === null);\n\n    if (failed) {\n      var defaultMsg = MSG_ELEMENT_NOT_FOUND;\n      if (result && result.value === null) {\n        defaultMsg = MSG_ATTR_NOT_FOUND;\n      }\n      this.message = msg || util.format(defaultMsg, attribute, selector, expected);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getAttribute(selector, attribute, callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/attributeEquals.js":"/**\n * Checks if the given attribute of an element has the expected value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.attributeEquals('body', 'data-attr', 'some value');\n *    };\n * ```\n *\n * @method attributeEquals\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} attribute The attribute name\n * @param {string} expected The expected value of the attribute to check.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, attribute, expected, msg) {\n  var DEFAULT_MSG = 'Testing if attribute %s of <%s> equals \"%s\".';\n  var MSG_ELEMENT_NOT_FOUND = DEFAULT_MSG + ' ' + 'Element could not be located.';\n  var MSG_ATTR_NOT_FOUND = DEFAULT_MSG + ' ' + 'Element does not have a ' + attribute + ' attribute.';\n\n  this.message = msg || util.format(DEFAULT_MSG, attribute, selector, expected);\n\n  this.expected = function() {\n    return expected;\n  };\n\n  this.pass = function(value) {\n    return value === expected;\n  };\n\n  this.failure = function(result) {\n    var failed = (result === false) ||\n      // no such element\n      result && (result.status === -1 || result.value === null);\n\n    if (failed) {\n      var defaultMsg = MSG_ELEMENT_NOT_FOUND;\n      if (result && result.value === null) {\n        defaultMsg = MSG_ATTR_NOT_FOUND;\n      }\n      this.message = msg || util.format(defaultMsg, attribute, selector, expected);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getAttribute(selector, attribute, callback);\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/containsText.js":"/**\n * Checks if the given element contains the specified text.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.containsText('#main', 'The Night Watch');\n *    };\n * ```\n *\n * @method containsText\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} expectedText The text to look for.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, expectedText, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> contains text: \"%s\". ' +\n    'Element could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> contains text: \"%s\".', selector, expectedText);\n\n  this.expected = function() {\n    return expectedText;\n  };\n\n  this.pass = function(value) {\n    return value.indexOf(expectedText) > -1;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector, expectedText);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getText(selector, callback);\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/cssClassNotPresent.js":"/**\n * Checks if the given element does not have the specified CSS class.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.cssClassNotPresent('#main', 'container');\n *    };\n * ```\n *\n * @method cssClassNotPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} className The CSS class to look for.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, className, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> does not have css class: \"%s\". ' +\n    'Element could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> does not have css class: \"%s\".', selector, className);\n\n  this.expected = function() {\n    return 'without ' + className;\n  };\n\n  this.pass = function(value) {\n    var classes = value.split(' ');\n    return classes.indexOf(className) === -1;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector, className);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getAttribute(selector, 'class', callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/cssClassPresent.js":"/**\n * Checks if the given element has the specified CSS class.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.cssClassPresent('#main', 'container');\n *    };\n * ```\n *\n * @method cssClassPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} className The CSS class to look for.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, className, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> has css class: \"%s\". ' +\n    'Element could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> has css class: \"%s\".', selector, className);\n\n  this.expected = function() {\n    return 'has ' + className;\n  };\n\n  this.pass = function(value) {\n    var classes = value.split(' ');\n    return classes.indexOf(className) > -1;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector, className);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getAttribute(selector, 'class', callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/cssProperty.js":"/**\n * Checks if the specified css property of a given element has the expected value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.cssProperty('#main', 'display', 'block');\n *    };\n * ```\n *\n * @method cssProperty\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} cssProperty The CSS property.\n * @param {string} expected The expected value of the css property to check.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, cssProperty, expected, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> has css property %s. ' +\n    'Element or attribute could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> has css property \"%s: %s\".', selector, cssProperty, expected);\n  this.expected = expected;\n\n  this.pass = function(value) {\n    return value === expected;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector, cssProperty);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getCssProperty(selector, cssProperty, callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/elementNotPresent.js":"/**\n * Checks if the given element exists in the DOM.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.elementNotPresent(\".should_not_exist\");\n *    };\n * ```\n *\n * @method elementNotPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, msg) {\n\n  this.message = msg || util.format('Testing if element <%s> is not present.', selector);\n  this.expected = 'not present';\n\n  this.pass = function(value) {\n    return value === 'not present';\n  };\n\n  this.value = function(result) {\n    return (result.status !== 0 || result.value.length === 0) ? 'not present' : 'present';\n  };\n\n  this.command = function(callback) {\n    return this.api.elements(this.client.locateStrategy, selector, callback);\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/elementPresent.js":"/**\n * Checks if the given element exists in the DOM.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.elementPresent(\"#main\");\n *    };\n * ```\n *\n * @method elementPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, msg) {\n  this.message = msg || util.format('Testing if element <%s> is present.', selector);\n  this.expected = 'present';\n\n  this.pass = function(value) {\n    return value == 'present';\n  };\n\n  this.value = function(result) {\n    return (result.status !== 0 || result.value.length === 0) ? 'not present' : 'present';\n  };\n\n  this.command = function(callback) {\n    return this.api.elements(this.client.locateStrategy, selector, callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/hidden.js":"/**\n * Checks if the given element is not visible on the page.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.hidden(\".should_not_be_visible\");\n *    };\n * ```\n *\n * @method hidden\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> is hidden. ' +\n    'Element could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> is hidden.', selector);\n  this.expected = true;\n\n  this.pass = function(value) {\n    return value === this.expected;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return !result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.isVisible(selector, callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/title.js":"/**\n * Checks if the page title equals the given value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.title(\"Nightwatch.js\");\n *    };\n * ```\n *\n * @method title\n * @param {string} expected The expected page title.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(expected, msg) {\n\n  this.message = msg || util.format('Testing if the page title equals \"%s\".', expected);\n  this.expected = expected;\n\n  this.pass = function(value) {\n    return value === this.expected;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    this.api.title(callback);\n    return this;\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/urlContains.js":"/**\n * Checks if the current URL contains the given value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.urlContains('google');\n *    };\n * ```\n *\n * @method urlContains\n * @param {string} expected The value expected to exist within the current URL.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(expected, msg) {\n\n  this.message = msg || util.format('Testing if the URL contains \"%s\".', expected);\n  this.expected = expected;\n\n  this.pass = function(value) {\n    return value.indexOf(this.expected) > -1;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    this.api.url(callback);\n    return this;\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/urlEquals.js":"/**\n * Checks if the current url equals the given value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.urlEquals('http://www.google.com');\n *    };\n * ```\n *\n * @method urlEquals\n * @param {string} expected The expected url.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(expected, msg) {\n\n  this.message = msg || util.format('Testing if the URL equals \"%s\".', expected);\n  this.expected = expected;\n\n  this.pass = function(value) {\n    return value === this.expected;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    this.api.url(callback);\n    return this;\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/valueContains.js":"/**\n * Checks if the given form element's value contains the expected value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.valueContains(\"form.login input[type=text]\", \"username\");\n *    };\n * ```\n *\n * @method valueContains\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} expectedText The expected text.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, expected, msg) {\n  var DEFAULT_MSG = 'Testing if value of <%s> contains: \"%s\".';\n  var MSG_ELEMENT_NOT_FOUND = DEFAULT_MSG + ' ' + 'Element could not be located.';\n  var VALUE_ATTR_NOT_FOUND = DEFAULT_MSG + ' ' +  'Element does not have a value attribute.';\n\n  this.message = msg || util.format(DEFAULT_MSG, selector, expected);\n  this.expected = true;\n\n  this.pass = function(value) {\n    return value.indexOf(expected) > -1;\n  };\n\n  this.failure = function(result) {\n    var failed = (result === false) ||\n      // no such element\n      result && (result.status === -1 || result.value === null);\n\n    if (failed) {\n      var defaultMsg = MSG_ELEMENT_NOT_FOUND;\n      if (result && result.value === null) {\n        defaultMsg = VALUE_ATTR_NOT_FOUND;\n      }\n      this.message = msg || util.format(defaultMsg, selector, expected);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getValue(selector, callback);\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/value.js":"/**\n * Checks if the given form element's value equals the expected value.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.value(\"form.login input[type=text]\", \"username\");\n *    };\n * ```\n *\n * @method value\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} expectedText The expected text.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, expected, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if value of <%s> equals: \"%s\". ' +\n    'Element or attribute could not be located.';\n\n  this.message = msg || util.format('Testing if value of <%s> equals: \"%s\".', selector, expected);\n  this.expected = expected;\n\n  this.pass = function(value) {\n    return value === this.expected;\n  };\n\n  this.failure = function(result) {\n    var failed = (result === false) ||\n      // no such element\n      result && result.status === -1 ||\n      // element doesn't have a value attribute\n      result && result.value === null;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector, expected);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.getValue(selector, callback);\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/assertions/visible.js":"/**\n * Checks if the given element is visible on the page.\n *\n * ```\n *    this.demoTest = function (client) {\n *      browser.assert.visible(\".should_be_visible\");\n *    };\n * ```\n *\n * @method visible\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api assertions\n */\n\nvar util = require('util');\nexports.assertion = function(selector, msg) {\n\n  var MSG_ELEMENT_NOT_FOUND = 'Testing if element <%s> is visible. ' +\n    'Element could not be located.';\n\n  this.message = msg || util.format('Testing if element <%s> is visible.', selector);\n  this.expected = true;\n\n  this.pass = function(value) {\n    return value === this.expected;\n  };\n\n  this.failure = function(result) {\n    var failed = result === false || result && result.status === -1;\n    if (failed) {\n      this.message = msg || util.format(MSG_ELEMENT_NOT_FOUND, selector);\n    }\n    return failed;\n  };\n\n  this.value = function(result) {\n    return result.value;\n  };\n\n  this.command = function(callback) {\n    return this.api.isVisible(selector, callback);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/end.js":"var util = require('util');\nvar events = require('events');\nvar Utils = require('../../util/utils.js');\nvar Logger = require('../../util/logger.js');\n\n/**\n * Ends the session. Uses session protocol command.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.end();\n * };\n * ```\n *\n * @method end\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @see session\n * @api commands\n */\nfunction End() {\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(End, events.EventEmitter);\n\nEnd.prototype.command = function(callback) {\n  var self = this;\n  var client = this.client;\n\n  if (client.sessionId) {\n    if (this.testFailuresExist() && this.shouldTakeScreenshot()) {\n      var fileNamePath = Utils.getScreenshotFileName(client.api.currentTest, false, client.options.screenshots.path);\n      Logger.info('We have failures in \"' + client.api.currentTest.name + '\". Taking screenshot...');\n\n      client.api.saveScreenshot(fileNamePath, function(result, err) {\n        if (err || result.status !== 0)  {\n          Logger.warn('Error saving screenshot...', err || result);\n        }\n      });\n    }\n\n    client.api.session('delete', function(result) {\n      client.sessionId = client.api.sessionId = null;\n      self.complete(callback, result);\n    });\n  } else {\n    setImmediate(function() {\n      self.complete(callback, null);\n    });\n  }\n\n  return this.client.api;\n};\n\nEnd.prototype.testFailuresExist = function() {\n  return this.client.results.errors > 0 || this.client.results.failed > 0;\n};\n\nEnd.prototype.shouldTakeScreenshot = function() {\n  return this.client.options.screenshots.enabled && this.client.options.screenshots.on_failure;\n};\n\nEnd.prototype.complete = function(callback, result) {\n  if (typeof callback === 'function') {\n    callback.call(this, result);\n  }\n  this.emit('complete');\n};\n\nmodule.exports = End;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/_locateStrategy.js":"var util = require('util');\nvar events = require('events');\n\nfunction Command() {\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(Command, events.EventEmitter);\n\nCommand.prototype.command = function(callback) {\n  var self = this;\n\n  this.client.locateStrategy = this.strategy;\n  process.nextTick(function() {\n    if (typeof callback == 'function') {\n      callback.call(self.client.api);\n    }\n    self.emit('complete');\n  });\n\n  return this;\n};\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/pause.js":"var util = require('util');\nvar events = require('events');\n\n/**\n * Suspends the test for the given time in milliseconds. If the milliseconds argument is missing it will suspend the test indefinitely\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.pause(1000);\n *   // or suspend indefinitely\n *   browser.pause();\n * };\n * ```\n *\n * @method pause\n * @param {number} ms The number of milliseconds to wait.\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api commands\n */\n\nfunction Pause() {\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(Pause, events.EventEmitter);\n\nPause.prototype.command = function(ms, cb) {\n  var self = this;\n  // If we don't pass the milliseconds, the client will\n  // be suspended indefinitely\n  if (!ms) {\n    return this;\n  }\n  setTimeout(function() {\n    // if we have a callback, call it right before the complete event\n    if (cb) {\n      cb.call(self.client.api);\n    }\n\n    self.emit('complete');\n  }, ms);\n\n  return this;\n};\n\nmodule.exports = Pause;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/perform.js":"/**\n * A simple perform command which allows access to the \"api\" in a callback.\n * Can be useful if you want to read variables set by other commands.\n *\n * ```\n * this.demoTest = function (browser) {\n *   var elementValue;\n *   browser\n *     .getValue('.some-element', function(result) {\n *       elementValue = result.value;\n *     })\n *     // other stuff going on ...\n *\n *     // self-completing callback\n *     .perform(function() {\n *       console.log('elementValue', elementValue);\n *       // without any defined parameters, perform\n *       // completes immediately (synchronously)\n *     })\n *\n *     // asynchronous completion\n *     .perform(function(done) {\n *       console.log('elementValue', elementValue);\n *       // potentially other async stuff going on\n *       // on finished, call the done callback\n *       done();\n *     })\n *\n *     // asynchronous completion including api (client)\n *     .perform(function(client, done) {\n *       console.log('elementValue', elementValue);\n *       // similar to before, but now with client\n *       // potentially other async stuff going on\n *       // on finished, call the done callback\n *       done();\n *     });\n * };\n * ```\n *\n * @method perform\n * @param {function} callback The function to run as part of the queue. Its signature can have up to two parameters. No parameters: callback runs and perform completes immediately at the end of the execution of the callback. One parameter: allows for asynchronous execution within the callback providing a done callback function for completion as the first argument. Two parameters: allows for asynchronous execution with the \"api\" object passed in as the first argument, followed by the done callback.\n * @api commands\n */\n\nvar util = require('util');\nvar events = require('events');\n\nfunction Perform() {\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(Perform, events.EventEmitter);\n\nPerform.prototype.command = function(callback) {\n  var self = this;\n  var doneCallback;\n  if (callback.length === 0) {\n    callback.call(self, self.client.api);\n    doneCallback = function() {\n      self.emit('complete');\n    };\n  } else {\n    doneCallback = function() {\n      var args = [function() {\n        self.emit('complete');\n      }];\n\n      if (callback.length > 1) {\n        args.unshift(self.client.api);\n      }\n\n      callback.apply(self, args);\n    };\n  }\n\n  process.nextTick(doneCallback);\n\n  return this;\n};\n\nmodule.exports = Perform;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/useCss.js":"var util = require('util');\nvar locateStrategy = require('./_locateStrategy.js');\n\n/**\n * Sets the locate strategy for selectors to `css selector`, therefore every following selector needs to be specified as css.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser\n *     .useCss() // we're back to CSS now\n *     .setValue('input[type=text]', 'nightwatch');\n * };\n * ```\n *\n * @method useCss\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api commands\n */\n\nfunction Command() {\n  this.strategy = 'css selector';\n  locateStrategy.call(this);\n}\n\nutil.inherits(Command, locateStrategy);\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/useRecursion.js":"var util = require('util');\nvar locateStrategy = require('./_locateStrategy.js');\n\n/**\n * Sets the locate strategy for selectors to `recursion`, therefore every following selector needs to be an array of element objects\n * This is used internally for sections of page objects which require element nesting\n *\n * @method useRecursion\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api commands\n */\n\nfunction Command() {\n  this.strategy = 'recursion';\n  locateStrategy.call(this);\n}\n\nutil.inherits(Command, locateStrategy);\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/client-commands/useXpath.js":"var util = require('util');\nvar locateStrategy = require('./_locateStrategy.js');\n\n/**\n * Sets the locate strategy for selectors to xpath, therefore every following selector needs to be specified as xpath.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser\n *     .useXpath() // every selector now must be xpath\n *     .click(\"//tr[@data-recordid]/span[text()='Search Text']\");\n * };\n * ```\n *\n * @method useXpath\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @api commands\n */\n\nfunction Command() {\n  this.strategy = 'xpath';\n  locateStrategy.call(this);\n}\n\nutil.inherits(Command, locateStrategy);\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/_waitForElement.js":"var util = require('util');\nvar events = require('events');\nvar Logger = require('../../util/logger.js');\nvar Utils = require('../../util/utils.js');\n\n/*!\n * Base class for waitForElement commands. It provides a command\n * method and element* methods to be overwritten by subclasses\n *\n * @constructor\n */\nfunction WaitForElement() {\n  events.EventEmitter.call(this);\n  this.startTimer = null;\n  this.cb = null;\n  this.ms = null;\n  this.element = null;\n  this.abortOnFailure = typeof this.client.api.globals.abortOnAssertionFailure == 'undefined' || this.client.api.globals.abortOnAssertionFailure;\n  this.selector = null;\n  this.locateStrategy = this.client.locateStrategy || 'css selector';\n  this.rescheduleInterval = this.client.api.globals.waitForConditionPollInterval || this.client.options.waitForConditionPollInterval || 500; //ms\n  this.throwOnMultipleElementsReturned = this.client.api.globals.throwOnMultipleElementsReturned || this.client.options.throwOnMultipleElementsReturned || false;\n  this.protocol = require('../protocol.js')(this.client);\n}\n\nutil.inherits(WaitForElement, events.EventEmitter);\n\n/*!\n * The public command function which will be called by the test runner. Arguments can be passed in a variety of ways.\n *\n * The custom message always is last and the callback is always before the message or last if a message is not passed.\n *\n * The second argument is always the time in milliseconds. The third argument can be either of:\n * - abortOnFailure: this can overwrite the default behaviour of aborting the test if the condition is not met within the specified time\n * - rescheduleInterval: this can overwrite the default polling interval (currently 500ms)\n * The above can be supplied also together, in which case the rescheduleInterval is specified before the abortOnFailure.\n *\n * Some of the multiple usage possibilities:\n * ---------------------------------------------------------------------------\n * - with no arguments; in this case a global default timeout is expected\n *  waitForElement('body');\n *\n * - with a global default timeout and a callback\n *  waitForElement('body', function() {});\n *\n * - with a global default timeout, a callback and a custom message\n *  waitForElement('body', function() {}, 'test message');\n *\n * - with only the timeout\n *  waitForElement('body', 500);\n *\n * - with a timeout and a custom message\n *  waitForElement('body', 500, 'test message);\n *\n * - with a timeout and a callback\n *  waitForElement('body', 500, function() { .. });\n *\n * - with a timeout and a custom abortOnFailure\n *  waitForElement('body', 500, true);\n *\n * - with a timeout, a custom abortOnFailure and a custom message\n *  waitForElement('body', 500, true, 'test message');\n *\n * - with a timeout, a custom abortOnFailure and a callback\n *  waitForElement('body', 500, true, function() { .. });\n *\n * - with a timeout, a custom abortOnFailure, a callback and a custom message\n *  waitForElement('body', 500, true, function() { .. }, 'test message');\n *\n * - with a timeout, a custom reschedule interval and a callback\n *  waitForElement('body', 500, 100, function() { .. });\n *\n * - with a timeout, a custom rescheduleInterval and a custom abortOnFailure\n *  waitForElement('body', 500, 100, false);\n *\n *\n * @param {string} selector\n * @param {number|function|string} milliseconds\n * @param {function|boolean|string|number} callbackOrAbort\n * @returns {WaitForElement}\n */\nWaitForElement.prototype.command = function commandFn(selector, milliseconds, callbackOrAbort) {\n  this.startTimer = new Date().getTime();\n  this.ms = this.setMilliseconds(milliseconds);\n  this._stackTrace = commandFn.stackTrace;\n\n  if (typeof arguments[1] === 'function') {\n    ////////////////////////////////////////////////\n    // The command was called with an implied global timeout:\n    //\n    // waitForElement('body', function() {});\n    // waitForElement('body', function() {}, 'custom message');\n    ////////////////////////////////////////////////\n    this.cb = arguments[1];\n  } else if (typeof arguments[2] === 'boolean') {\n    ////////////////////////////////////////////////\n    // The command was called with a custom abortOnFailure:\n    //\n    // waitForElement('body', 500, false);\n    ////////////////////////////////////////////////\n    this.abortOnFailure = arguments[2];\n\n    // The optional callback is the 4th argument now\n    this.cb = arguments[3] || function() {};\n  } else if (typeof arguments[2] === 'number') {\n    ////////////////////////////////////////////////\n    // The command was called with a custom rescheduleInterval:\n    //\n    // waitForElement('body', 500, 100);\n    ////////////////////////////////////////////////\n    this.rescheduleInterval = arguments[2];\n\n    if (typeof arguments[3] === 'boolean') {\n      ////////////////////////////////////////////////\n      // The command was called with a custom rescheduleInterval and custom abortOnFailure:\n      //\n      // waitForElement('body', 500, 100, false);\n      ////////////////////////////////////////////////\n      this.abortOnFailure = arguments[3];\n\n      // The optional callback is the 5th argument now\n      this.cb = arguments[4] || function() {};\n    } else {\n      // The optional callback is the 4th argument now\n      this.cb = arguments[3] || function() {};\n    }\n  } else {\n    // The optional callback is the 3th argument now\n    this.cb = (typeof callbackOrAbort === 'function' && callbackOrAbort) || function() {};\n  }\n\n  // support for a custom message\n  this.message = null;\n  if (arguments.length > 1) {\n    var lastArgument = arguments[arguments.length - 1];\n    if (typeof lastArgument === 'string') {\n      this.message = lastArgument;\n    }\n  }\n\n  this.selector = selector;\n  this.checkElement();\n  return this;\n};\n\n/*!\n * @override\n */\nWaitForElement.prototype.elementFound = function(result, now) {};\n\n/*!\n * @override\n */\nWaitForElement.prototype.elementNotFound = function(result, now) {};\n\n/*!\n * @override\n */\nWaitForElement.prototype.elementVisible = function(result, now) {};\n\n/*!\n * @override\n */\nWaitForElement.prototype.elementNotVisible = function(result, now) {};\n\n/*!\n * Reschedule the checkElement\n */\nWaitForElement.prototype.reschedule = function(method) {\n  var self = this;\n  method = method || 'checkElement';\n\n  setTimeout(function() {\n    self[method]();\n  }, this.rescheduleInterval);\n};\n\nWaitForElement.prototype.complete = function() {\n  var args = Array.prototype.slice.call(arguments, 0);\n  args.push(this);\n  this.cb.apply(this.client.api, args);\n  this.emit('complete');\n  return this;\n};\n\nWaitForElement.prototype.pass = function(result, defaultMsg, timeMs) {\n  this.message = this.formatMessage(defaultMsg, timeMs);\n  this.client.assertion(true, null, null, this.message, this.abortOnFailure);\n  return this.complete(result);\n};\n\nWaitForElement.prototype.fail = function(result, actual, expected, defaultMsg) {\n  this.message = this.formatMessage(defaultMsg);\n  this.client.assertion(false, actual, expected, this.message, this.abortOnFailure, this._stackTrace);\n  return this.complete(result);\n};\n\n/*!\n * Will start checking if the element exists and if not re-schedule the check\n * until the timeout expires or the condition has been met\n */\nWaitForElement.prototype.checkElement = function() {\n  var self = this;\n  this.getProtocolCommand(function(result) {\n    var now = new Date().getTime();\n\n    if (result.value && result.value.length > 0) {\n      if (result.value.length > 1) {\n        var message = 'WaitForElement found ' + result.value.length + ' elements for selector \"' + self.selector + '\".';\n        if (self.throwOnMultipleElementsReturned) {\n          throw new Error(message);\n        } else if (self.client.options.output) {\n          console.log(Logger.colors.green('  Warn: ' + message + ' Only the first one will be checked.'));\n        }\n      }\n\n      self.element = result.value[0].ELEMENT;\n      return self.elementFound(result, now);\n    }\n\n    return self.elementNotFound(result, now);\n  });\n};\n\nWaitForElement.prototype.getProtocolCommand = function(callback) {\n  return this.protocol.elements(this.locateStrategy, this.selector, callback);\n};\n\n/*!\n * Will start checking if the element is visible and if not re-schedule the check\n * until the timeout expires or the condition has been met\n */\nWaitForElement.prototype.isVisible = function() {\n  var self = this;\n  this.protocol.elementIdDisplayed(this.element, function(result) {\n    var now = new Date().getTime();\n    if (result.status === 0 && result.value === true) {\n      // element was visible\n      return self.elementVisible(result, now);\n    }\n\n    if (result.status === -1 && result.errorStatus === 10) {\n      return self.checkElement();\n    }\n\n    return self.elementNotVisible(result, now);\n  });\n};\n\n/**\n * @param {string} defaultMsg\n * @param {number} [timeMs]\n * @returns {string}\n */\nWaitForElement.prototype.formatMessage = function (defaultMsg, timeMs) {\n  return Utils.format(this.message || defaultMsg, this.selector, timeMs || this.ms);\n};\n\n/**\n * Set the time in milliseconds to wait for the condition, accepting a given value or a globally defined default\n *\n * @param {number} [timeoutMs]\n * @throws Will throw an error if the global default is undefined or a non-number\n * @returns {number}\n */\nWaitForElement.prototype.setMilliseconds = function (timeoutMs) {\n  if (timeoutMs && typeof timeoutMs === 'number') {\n    return timeoutMs;\n  }\n\n  var globalTimeout = this.client.api.globals.waitForConditionTimeout;\n  if (typeof globalTimeout !== 'number') {\n    throw new Error('waitForElement expects second parameter to have a global default ' +\n      '(waitForConditionTimeout) to be specified if not passed as the second parameter ');\n  }\n\n  return globalTimeout;\n};\n\nmodule.exports = WaitForElement;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/waitForElementNotPresent.js":"var util = require('util');\nvar WaitForElement = require('./_waitForElement.js');\n\n/**\n * Opposite of `waitForElementPresent`. Waits a given time in milliseconds for an element to be not present (i.e. removed) in the page before performing any other commands or assertions.\n *\n * If the element is still present after the specified amount of time, the test fails.\n *\n * You can change the polling interval by defining a `waitForConditionPollInterval` property (in milliseconds) in as a global property in your `nightwatch.json` or in your external globals file.\n *\n * Similarly, a default timeout can be specified as a global `waitForConditionTimeout` property (in milliseconds).\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.waitForElementNotPresent('#dialog', 1000);\n * };\n * ```\n *\n * @method waitForElementNotPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {number} time The number of milliseconds to wait. The runner performs repeated checks every 500 ms.\n * @param {boolean} [abortOnFailure] By the default if the element is not found the test will fail. Set this to false if you wish for the test to continue even if the assertion fails. To set this globally you can define a property `abortOnAssertionFailure` in your globals.\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @param {string} [message] Optional message to be shown in the output; the message supports two placeholders: %s for current selector and %d for the time (e.g. Element %s was not in the page for %d ms).\n * @see waitForElementPresent\n * @since v0.4.0\n * @api commands\n */\nfunction WaitForElementNotPresent() {\n  WaitForElement.call(this);\n  this.expectedValue = 'not found';\n}\n\nutil.inherits(WaitForElementNotPresent, WaitForElement);\n\nWaitForElementNotPresent.prototype.elementFound = function(result, now) {\n  if (now - this.startTimer < this.ms) {\n    // element is still there, schedule another check\n    this.reschedule();\n    return this;\n  }\n\n  var defaultMsg = 'Timed out while waiting for element <%s> to be removed for %d milliseconds.';\n  return this.fail(result, 'found', this.expectedValue, defaultMsg);\n};\n\nWaitForElementNotPresent.prototype.elementNotFound = function(result, now) {\n  var defaultMsg = 'Element <%s> was not present after %d milliseconds.';\n\n  return this.pass(result, defaultMsg, now - this.startTimer);\n};\n\nmodule.exports = WaitForElementNotPresent;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/waitForElementNotVisible.js":"var util = require('util');\nvar WaitForElementPresent = require('./waitForElementPresent.js');\n\n/**\n * Opposite of `waitForElementVisible`. Waits a given time in milliseconds for an element to be not visible (i.e. hidden but existing) in the page before performing any other commands or assertions.\n *\n * If the element fails to be hidden in the specified amount of time, the test fails.\n *\n * You can change the polling interval by defining a `waitForConditionPollInterval` property (in milliseconds) in as a global property in your `nightwatch.json` or in your external globals file.\n *\n * Similarly, a default timeout can be specified as a global `waitForConditionTimeout` property (in milliseconds).\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.waitForElementNotVisible('#dialog', 1000);\n * };\n * ```\n *\n * @method waitForElementNotVisible\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {number} time The number of milliseconds to wait. The runner performs repeated checks every 500 ms.\n * @param {boolean} [abortOnFailure] By the default if the element is not found the test will fail. Set this to false if you wish for the test to continue even if the assertion fails. To set this globally you can define a property `abortOnAssertionFailure` in your globals.\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @param {string} [message] Optional message to be shown in the output; the message supports two placeholders: %s for current selector and %d for the time (e.g. Element %s was not in the page for %d ms).\n * @since v0.4.0\n * @see waitForElementVisible\n * @api commands\n */\nfunction WaitForElementNotVisible() {\n  WaitForElementPresent.call(this);\n  this.expectedValue = 'not visible';\n}\n\nutil.inherits(WaitForElementNotVisible, WaitForElementPresent);\n\nWaitForElementNotVisible.prototype.elementFound = function() {\n  return this.isVisible();\n};\n\nWaitForElementNotVisible.prototype.elementVisible = function(result, now) {\n  if (now - this.startTimer < this.ms) {\n    // element wasn't visible, schedule another check\n    this.reschedule('isVisible');\n    return this;\n  }\n\n  var defaultMsg = 'Timed out while waiting for element <%s> to not be visible for %d milliseconds.';\n  return this.fail(result, 'visible', this.expectedValue, defaultMsg);\n};\n\nWaitForElementNotVisible.prototype.elementNotVisible = function(result, now) {\n  var defaultMsg = 'Element <%s> was not visible after %d milliseconds.';\n  return this.pass(result, defaultMsg, now - this.startTimer);\n};\n\nmodule.exports = WaitForElementNotVisible;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/waitForElementPresent.js":"var util = require('util');\nvar WaitForElement = require('./_waitForElement.js');\n\n/**\n * Waits a given time in milliseconds for an element to be present in the page before performing any other commands or assertions.\n *\n * If the element fails to be present in the specified amount of time, the test fails. You can change this by setting `abortOnFailure` to `false`.\n *\n * You can change the polling interval by defining a `waitForConditionPollInterval` property (in milliseconds) in as a global property in your `nightwatch.json` or in your external globals file.\n *\n * Similarly, a default timeout can be specified as a global `waitForConditionTimeout` property (in milliseconds).\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.waitForElementPresent('body', 1000);\n *   // continue if failed\n *   browser.waitForElementPresent('body', 1000, false);\n *   // with callback\n *   browser.waitForElementPresent('body', 1000, function() {\n *     // do something while we're here\n *   });\n *   // custom Spanish message\n *   browser.waitForElementPresent('body', 1000, 'elemento %s no era presente en %d ms');\n *   // many combinations possible - the message is always the last argument\n *   browser.waitForElementPresent('body', 1000, false, function() {}, 'elemento %s no era presente en %d ms');\n * };\n * ```\n *\n * @method waitForElementPresent\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {number} time The number of milliseconds to wait. The runner performs repeated checks every 500 ms.\n * @param {boolean} [abortOnFailure] By the default if the element is not found the test will fail. Set this to false if you wish for the test to continue even if the assertion fails. To set this globally you can define a property `abortOnAssertionFailure` in your globals.\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @param {string} [message] Optional message to be shown in the output; the message supports two placeholders: %s for current selector and %d for the time (e.g. Element %s was not in the page for %d ms).\n * @api commands\n */\nfunction WaitForElementPresent() {\n  WaitForElement.call(this);\n  this.expectedValue = 'found';\n}\n\nutil.inherits(WaitForElementPresent, WaitForElement);\n\nWaitForElementPresent.prototype.elementFound = function(result, now) {\n  var defaultMsg = 'Element <%s> was present after %d milliseconds.';\n  return this.pass(result, defaultMsg, now - this.startTimer);\n};\n\nWaitForElementPresent.prototype.elementNotFound = function(result, now) {\n  if (now - this.startTimer < this.ms) {\n    // element wasn't found, schedule another check\n    this.reschedule();\n    return this;\n  }\n\n  var defaultMsg = 'Timed out while waiting for element <%s> to be present for %d milliseconds.';\n  return this.fail({value:false}, 'not found', this.expectedValue, defaultMsg);\n};\n\nmodule.exports = WaitForElementPresent;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/element-commands/waitForElementVisible.js":"var util = require('util');\nvar WaitForElementPresent = require('./waitForElementPresent.js');\n\n/**\n * Waits a given time in milliseconds for an element to be visible in the page before performing any other commands or assertions.\n *\n * If the element fails to be present and visible in the specified amount of time, the test fails. You can change this by setting `abortOnFailure` to `false`.\n *\n * You can change the polling interval by defining a `waitForConditionPollInterval` property (in milliseconds) in as a global property in your `nightwatch.json` or in your external globals file.\n *\n * Similarly, a default timeout can be specified as a global `waitForConditionTimeout` property (in milliseconds).\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.waitForElementVisible('body', 1000);\n *   // continue if failed\n *   browser.waitForElementVisible('body', 1000, false);\n *   // with callback\n *   browser.waitForElementVisible('body', 1000, function() {\n *     // do something while we're here\n *   });\n *   // custom Spanish message\n *   browser.waitForElementVisible('body', 1000, 'elemento %s no era visible en %d ms');\n *   // many combinations possible - the message is always the last argument\n *   browser.waitForElementVisible('body', 1000, false, function() {}, 'elemento %s no era visible en %d ms');\n * };\n * ```\n *\n * @method waitForElementVisible\n * @param {string} selector The selector (CSS / Xpath) used to locate the element.\n * @param {number} time The number of milliseconds to wait. The runner performs repeated checks every 500 ms.\n * @param {boolean} [abortOnFailure] By the default if the element is not found the test will fail. Set this to false if you wish for the test to continue even if the assertion fails. To set this globally you can define a property `abortOnAssertionFailure` in your globals.\n * @param {function} [callback] Optional callback function to be called when the command finishes.\n * @param {string} [message] Optional message to be shown in the output; the message supports two placeholders: %s for current selector and %d for the time (e.g. Element %s was not in the page for %d ms).\n * @api commands\n */\nfunction WaitForElementVisible() {\n  WaitForElementPresent.call(this);\n  this.expectedValue = 'visible';\n}\n\nutil.inherits(WaitForElementVisible, WaitForElementPresent);\n\nWaitForElementVisible.prototype.elementFound = function(result, now) {\n  return this.isVisible();\n};\n\nWaitForElementVisible.prototype.elementVisible = function(result, now) {\n  var defaultMsg = 'Element <%s> was visible after %d milliseconds.';\n  return this.pass(result, defaultMsg, now - this.startTimer);\n};\n\nWaitForElementVisible.prototype.elementNotVisible = function(result, now) {\n  if (now - this.startTimer < this.ms) {\n    // element wasn't visible, schedule another check\n    this.reschedule('isVisible');\n    return this;\n  }\n\n  var defaultMsg = 'Timed out while waiting for element <%s> to be visible for %d milliseconds.';\n  return this.fail(result, 'not visible', this.expectedValue, defaultMsg);\n};\n\nmodule.exports = WaitForElementVisible;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/attribute.js":"/**\n * Checks if a given attribute of an element exists and optionally if it has the expected value.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('body').to.have.attribute('data-attr');\n *   browser.expect.element('body').to.not.have.attribute('data-attr');\n *   browser.expect.element('body').to.not.have.attribute('data-attr', 'Testing if body does not have data-attr');\n *   browser.expect.element('body').to.have.attribute('data-attr').before(100);\n *   browser.expect.element('body').to.have.attribute('data-attr')\n *     .equals('some attribute');\n *   browser.expect.element('body').to.have.attribute('data-attr')\n *     .not.equals('other attribute');\n *   browser.expect.element('body').to.have.attribute('data-attr')\n *     .which.contains('something');\n *   browser.expect.element('body').to.have.attribute('data-attr')\n *     .which.matches(/^something\\ else/);\n * };\n * ```\n *\n * @method attribute\n * @param {string} attribute The attribute name\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @display .attribute(name)\n * @since v0.7\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction AttributeAssertion(attribute, msg) {\n  this.flag('attributeFlag', true);\n  this.attribute = attribute;\n  this.customMessage = msg;\n  this.message = msg || 'Expected element <%s> to ' + (this.negate ? 'not have' : 'have') + ' attribute \"' + attribute + '\"';\n\n  BaseAssertion.call(this);\n\n  this.start();\n}\n\nutil.inherits(AttributeAssertion, BaseAssertion);\n\nAttributeAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdAttribute(this.elementResult.ELEMENT, this.attribute, function(result) {\n    if (result.value !== null && result.status === 0) {\n      callback(result);\n    } else {\n      this.attributeNotFound();\n    }\n  }.bind(this));\n};\n\nAttributeAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n  if (!this.hasCondition()) {\n    this.passed = this.negate ? false : true;\n    this.expected = this.negate ? 'not found' : 'found';\n    this.actual = 'found';\n  }\n\n  if (this.waitForMs && this.passed) {\n    var message = 'attribute was present';\n    if (this.hasCondition()) {\n      message = 'condition was met';\n    }\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - ' + message + ' in ' + this.elapsedTime + 'ms');\n  }\n};\n\nAttributeAssertion.prototype.attributeNotFound = function() {\n  this.processFlags();\n  this.passed = this.hasCondition() ? false : this.negate;\n\n  if (!this.passed && this.shouldRetry()) {\n    this.scheduleRetry();\n  } else {\n    if (!this.hasCondition()) {\n      this.expected = this.negate ? 'not found' : 'found';\n      this.actual = 'not found';\n    }\n\n    if (!this.negate) {\n      this.messageParts.push(' - attribute was not found');\n    }\n    this.done();\n  }\n};\n\nAttributeAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n};\n\nmodule.exports = AttributeAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/_baseAssertion.js":"/**\n * Abstract assertion class that will subclass all defined Chai assertions\n *\n * All assertions must implement the following api:\n *\n * - @type {function}\n *   executeCommand\n * - @type {string}\n *   elementFound\n * - @type {function}\n *   elementNotFound\n * - @type {function}\n *   retryCommand\n * - @type {string}\n *   expected\n * - @type {string}\n *   actual\n * - @type {string}\n *   message\n * - @type {boolean}\n *   passed\n *\n * @constructor\n */\nvar util = require('util');\nvar events = require('events');\nvar Assertion = require('../../core/assertion.js');\nvar chai = require('chai-nightwatch');\nvar flag = chai.flag;\nvar Utils = require('../../util/utils.js');\n\nfunction BaseAssertion() {\n}\n\nBaseAssertion.ASSERT_FLAGS = [\n  'be',\n  'that',\n  'have',\n  'which',\n  'equal',\n  'contains',\n  'matches',\n  'before',\n  'after',\n  'waitFor'\n];\n\n/**\n * @override\n */\nBaseAssertion.prototype.executeCommand = function(callback) {};\n\nBaseAssertion.prototype.setAssertion = function(assertion) {\n  this.assertion = assertion;\n  return this;\n};\n\nBaseAssertion.prototype.flag = function(key, value) {\n  if (typeof value == 'undefined') {\n    return flag(this.assertion, key);\n  }\n\n  flag(this.assertion, key, value);\n  return this;\n};\n\nBaseAssertion.prototype.setClient = function(client) {\n  this.client = client;\n  return this;\n};\n\nBaseAssertion.prototype.setProtocol = function(protocol) {\n  this.protocol = protocol;\n  return this;\n};\n\nBaseAssertion.prototype.init = function() {\n  this.promise  = this.flag('promise');\n  this.element  = this.flag('element');\n  this.selector = this.flag('selector');\n\n  this.setNegate();\n\n  this.waitForMs      = this.client.api.globals.waitForConditionTimeout || null;\n  if (this.waitForMs) {\n    this.flag('waitFor', this.waitForMs);\n  }\n  this.retryInterval  = this.client.api.globals.waitForConditionPollInterval || 500;\n  this.retries        = 0;\n  this.messageParts   = [];\n  this.abortOnFailure = typeof this.client.api.globals.abortOnAssertionFailure == 'undefined' || this.client.api.globals.abortOnAssertionFailure;\n  this.passed         = false;\n  this.expected       = null;\n  this.elementResult  = null;\n  this.flags          = [];\n};\n\nBaseAssertion.prototype.start = function() {\n  this.promise.then(this.onPromiseResolved.bind(this), this.onPromiseRejected.bind(this));\n};\n\nBaseAssertion.prototype.onPromiseResolved = function(elementResult) {\n  if (elementResult) {\n    this.elementResult = elementResult;\n  }\n\n  this.executeCommand(function(result) {\n    this.resultValue = result.value;\n    this.resultStatus = result.status;\n    this.resultErrorStatus = result.errorStatus;\n\n    this.processFlags();\n    this.elementFound();\n\n    if (!this.passed && this.shouldRetry()) {\n      this.scheduleRetry();\n    } else {\n      this.done();\n    }\n  }.bind(this));\n};\n\nBaseAssertion.prototype.onPromiseRejected = function(response) {\n  this.processFlags();\n\n  if (this.shouldRetry() && !this.negate) {\n    this.scheduleRetry();\n    return;\n  }\n\n  this.messageParts.push(' - element was not found');\n  this.actual = 'not present';\n  this.expected = 'present';\n\n  this.elementNotFound();\n  this.done();\n};\n\nBaseAssertion.prototype.processFlags = function() {\n  BaseAssertion.ASSERT_FLAGS.forEach(function(entry) {\n    var value = this.flag(entry);\n    if ((typeof value != 'undefined') && (typeof this['@' + entry + 'Flag'] == 'function')) {\n      this.flags.push([entry, value]);\n      this['@' + entry + 'Flag'](value);\n    }\n  }.bind(this));\n};\n\nBaseAssertion.prototype.hasFlag = function(type) {\n  return this.flags.some(function(flag) {\n    return flag[0] === type;\n  });\n};\n\n/**\n * @override\n */\nBaseAssertion.prototype.elementFound = function() {};\n\n/**\n * @override\n */\nBaseAssertion.prototype.elementNotFound = function() {};\n\nBaseAssertion.prototype.done = function() {\n  this.formatMessage();\n  var stackTrace = this.flag('element')._stackTrace;\n\n  Assertion.assert(\n    this.passed,\n    this.actual,\n    this.expected,\n    this.message,\n    this.abortOnFailure,\n    stackTrace\n  );\n\n  this.element.emitter.emit('complete');\n};\n\nBaseAssertion.prototype.getResult = function(value, fn) {\n  var result = fn.call(this);\n  this.setNegate();\n  return this.negate ? !result : result;\n};\n\nBaseAssertion.prototype.shouldRetryLocateElement = function() {\n  return (!this.elementResult || this.resultStatus === 10 || this.resultErrorStatus === 10);\n};\n\nBaseAssertion.prototype.shouldRetry = function() {\n  if (!this.waitForMs) {\n    return false;\n  }\n\n  this.elapsedTime = this.getElapsedTime();\n  return (this.elapsedTime < this.waitForMs);\n};\n\nBaseAssertion.prototype.getElapsedTime = function() {\n  var timeNow = new Date().getTime();\n  return timeNow - this.element.startTime;\n};\n\nBaseAssertion.prototype.scheduleRetry = function() {\n  this.retries++;\n  setTimeout(this.retryCommand.bind(this), this.retryInterval);\n};\n\nBaseAssertion.prototype.formatMessage = function() {\n  this.message = Utils.format(this.message || this.message, this.selector);\n  this.message += this.messageParts.join('');\n};\n\nBaseAssertion.prototype['@containsFlag'] = function(value) {\n  var verb = (this.hasFlag('that') || this.hasFlag('which')) ? 'contains' : 'contain';\n  this.conditionFlag(value, function() {\n    return this.resultValue ? this.resultValue.indexOf(value) > -1 : false;\n  }, [\n    'not ' + verb,\n    verb\n  ]);\n\n  return this;\n};\n\nBaseAssertion.prototype['@equalFlag'] = function(value) {\n  var verb;\n  if (this.hasFlag('have')) {\n    verb = (this.hasFlag('that') || this.hasFlag('which')) ? 'equals' : 'equal to';\n  } else {\n    verb = 'equal';\n  }\n  this.conditionFlag(value, function() {\n    return this.resultValue == value;\n  }, [\n    'not ' + verb,\n    verb\n  ]);\n\n  return this;\n};\n\nBaseAssertion.prototype['@matchesFlag'] = function(re) {\n  var adverb = this.hasFlag('that') || this.hasFlag('which');\n  var verb = adverb ? 'matches' : 'match';\n  this.conditionFlag(re, function() {\n    return re.test(this.resultValue);\n  }, [\n    (adverb ? 'does ' : '') + 'not match',\n    verb\n  ]);\n\n  return this;\n};\n\nBaseAssertion.prototype.conditionFlag = function(value, conditionFn, arrverb) {\n  this.passed = this.getResult(value, conditionFn);\n  var verb = this.negate ? arrverb[0]: arrverb[1];\n  this.expected = verb + ' \\'' + value + '\\'';\n  this.actual = this.resultValue;\n\n  if (this.retries > 0) {\n    return;\n  }\n\n  var needsSpace = this.messageParts.length === 0 ? true : this.messageParts[this.messageParts.length-1].slice(-1) != ' ';\n  if (needsSpace) {\n    verb = ' ' + verb;\n  }\n  if (!this.customMessage) {\n    this.messageParts.push(\n      verb,\n      ': \"', value, '\"'\n    );\n  }\n};\n\nBaseAssertion.prototype.setNegate = function() {\n  this.negate = this.flag('negate') || false;\n  return this;\n};\n\nBaseAssertion.prototype['@beforeFlag'] = function(value) {};\n\nBaseAssertion.prototype['@afterFlag'] = function(value) {};\n\nBaseAssertion.prototype['@haveFlag'] = function(value) {};\nBaseAssertion.prototype['@waitForFlag'] = function(value) {\n  if (this.waitForMs !== value) {\n    this.waitForMs = value;\n    if (!this.customMessage) {\n      this.messageParts.push(this.checkWaitForMsg(this.waitForMs));\n    }\n  }\n};\n\nBaseAssertion.prototype['@thatFlag'] = function() {\n  if (this.retries > 0) {\n    return;\n  }\n  if (!this.customMessage) {\n    this.messageParts.push(' that ');\n  }\n  return this;\n};\n\nBaseAssertion.prototype['@whichFlag'] = function() {\n  if (this.retries > 0) {\n    return;\n  }\n  if (!this.customMessage) {\n    this.messageParts.push(' which ');\n  }\n  return this;\n};\n\nBaseAssertion.prototype['@beFlag'] = function() {};\n\nBaseAssertion.prototype.hasCondition = function() {\n  return (this.hasFlag('contains') || this.hasFlag('equal') || this.hasFlag('matches'));\n};\n\nBaseAssertion.prototype.checkWaitForMsg = function(waitFor) {\n  var preposition = this.flag('before') && 'in' ||\n    this.flag('after') && 'after' ||\n    'in';\n  return ' ' + preposition +' ' + waitFor + 'ms';\n};\n\nBaseAssertion.prototype.retryCommand = function() {\n  if (this.shouldRetryLocateElement()) {\n    this.promise = this.element.createPromise();\n    this.promise.then(this.onPromiseResolved.bind(this), this.onPromiseRejected.bind(this));\n    this.element.locate();\n  } else {\n    this.onPromiseResolved();\n  }\n};\n\nmodule.exports = BaseAssertion;","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/css.js":"/**\n * Checks a given css property of an element exists and optionally if it has the expected value.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#main').to.have.css('display');\n *   browser.expect.element('#main').to.have.css('display', 'Testing for display');\n *   browser.expect.element('#main').to.not.have.css('display');\n *   browser.expect.element('#main').to.have.css('display').before(100);\n *   browser.expect.element('#main').to.have.css('display').which.equals('block');\n *   browser.expect.element('#main').to.have.css('display').which.contains('some value');\n *   browser.expect.element('#main').to.have.css('display').which.matches(/some\\ value/);\n * };\n * ```\n *\n * @method css\n * @param {string} property The css property name\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.*\n * @display .css(property)\n * @since v0.7\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction CssAssertion(property, msg) {\n  this.cssProperty = property;\n  this.flag('cssFlag', true);\n\n  BaseAssertion.call(this);\n  this.customMessage = typeof msg != 'undefined';\n  this.message = msg || 'Expected element <%s> to ' + (this.negate ? 'not have' : 'have') + ' css property \"' + property + '\"';\n  this.start();\n}\n\nutil.inherits(CssAssertion, BaseAssertion);\n\nCssAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdCssProperty(this.elementResult.ELEMENT, this.cssProperty, callback);\n};\n\nCssAssertion.prototype['@haveFlag'] = function() {\n  this.passed = this.negate ? (this.resultValue === '') : (this.resultValue !== '');\n  this.expected = this.negate ? 'not present' : 'present';\n  this.actual = this.resultValue === '' ? 'not present' : 'present';\n};\n\nCssAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n\n  if (this.passed && this.waitForMs) {\n    var message = 'property was present';\n\n    if (this.hasCondition()) {\n      message = 'condition was met';\n    }\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - ' + message + ' in ' + this.elapsedTime + 'ms');\n  }\n};\n\nCssAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n};\n\nmodule.exports = CssAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/enabled.js":"/**\n * Property that checks if an element is currently enabled.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#weblogin').to.be.enabled;\n *   browser.expect.element('#main').to.not.be.enabled;\n *   browser.expect.element('#main').to.be.enabled.before(100);\n * };\n * ```\n *\n * @method enabled\n * @display .enabled\n * @since v0.7\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction EnabledAssertion() {\n  BaseAssertion.call(this);\n\n  this.message = 'Expected element <%s> to ' + (this.negate ? 'not be enabled' : 'be enabled');\n  this.start();\n}\n\nutil.inherits(EnabledAssertion, BaseAssertion);\n\nEnabledAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdEnabled(this.elementResult.ELEMENT, callback);\n};\n\nEnabledAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n\n  this.passed = this.negate ? !this.resultValue : this.resultValue;\n  this.expected = this.negate ? 'not enabled' : 'enabled';\n  this.actual = this.resultValue ? 'enabled' : 'not enabled';\n\n  if (this.passed && this.waitForMs) {\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - condition was met in ' + this.elapsedTime + 'ms');\n  }\n};\n\nEnabledAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n  this.expected = this.negate ? 'not enabled' : 'enabled';\n  this.actual = 'not found';\n};\n\nmodule.exports = EnabledAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/present.js":"/**\n * Property that checks if an element is present in the DOM.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#main').to.be.present;\n *   browser.expect.element('#main').to.not.be.present;\n *   browser.expect.element('#main').to.be.present.before(100);\n * };\n * ```\n *\n * @method present\n * @display .present\n * @since v0.7\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction PresentAssertion() {\n  this.flag('present', true);\n\n  BaseAssertion.call(this);\n\n  this.message = 'Expected element <%s> to ' + (this.negate ? 'not be present' : 'be present');\n  this.start();\n}\n\nutil.inherits(PresentAssertion, BaseAssertion);\n\nPresentAssertion.prototype.executeCommand = function(callback) {\n  return callback(this.elementResult);\n};\n\nPresentAssertion.prototype.elementFound = function() {\n  this.passed = !this.negate;\n\n  if (!this.passed && this.shouldRetry()) {\n    return;\n  }\n\n  if (this.waitForMs) {\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - element was present in ' + this.elapsedTime + 'ms');\n  }\n  if (this.negate) {\n    this.actual = 'present';\n    this.expected = 'not present';\n  }\n};\n\nPresentAssertion.prototype.elementNotFound = function() {\n  this.passed = this.negate;\n\n  if (!this.passed && this.shouldRetry()) {\n    return;\n  }\n\n  if (this.waitForMs && this.negate) {\n    this.messageParts.push(this.checkWaitForMsg(this.elapsedTime) + '.');\n  }\n};\n\nPresentAssertion.prototype.retryCommand = function() {\n  this.promise = this.element.createPromise();\n  this.element.deferred.promise.then(this.onPromiseResolved.bind(this), this.onPromiseRejected.bind(this));\n  this.element.locate();\n};\n\nmodule.exports = PresentAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/selected.js":"/**\n * Property that checks if an OPTION element, or an INPUT element of type checkbox or radio button is currently selected.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#main').to.be.selected;\n *   browser.expect.element('#main').to.not.be.selected;\n *   browser.expect.element('#main').to.be.selected.before(100);\n * };\n * ```\n *\n * @method selected\n * @display .selected\n * @since v0.7\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction SelectedAssertion() {\n  BaseAssertion.call(this);\n\n  this.message = 'Expected element <%s> to ' + (this.negate ? 'not be selected' : 'be selected');\n  this.start();\n}\n\nutil.inherits(SelectedAssertion, BaseAssertion);\n\nSelectedAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdSelected(this.elementResult.ELEMENT, callback);\n};\n\nSelectedAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n\n  this.passed = this.negate ? !this.resultValue : this.resultValue;\n  this.expected = this.negate ? 'not selected' : 'selected';\n  this.actual = this.resultValue ? 'selected' : 'not selected';\n\n  if (this.passed && this.waitForMs) {\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - condition was met in ' + this.elapsedTime + 'ms');\n  }\n};\n\nSelectedAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n  this.expected = this.negate ? 'not selected' : 'selected';\n  this.actual = 'not found';\n};\n\nmodule.exports = SelectedAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/text.js":"/**\n * Property that retrieves the text contained by an element. Can be chained to check if contains/equals/matches the specified text or regex.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#main').text.to.equal('The Night Watch');\n *   browser.expect.element('#main').text.to.not.equal('The Night Watch');\n *   browser.expect.element('#main').text.to.equal('The Night Watch').before(100);\n *   browser.expect.element('#main').text.to.contain('The Night Watch');\n *   browser.expect.element('#main').text.to.match(/The\\ Night\\ Watch/);\n * };\n * ```\n *\n * @method text\n * @since v0.7\n * @display .text\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction TextAssertion() {\n  this.flag('textFlag', true);\n\n  BaseAssertion.call(this);\n\n  this.message = 'Expected element <%s> text to' + (this.negate ? ' not' : '');\n  this.start();\n}\n\nutil.inherits(TextAssertion, BaseAssertion);\n\nTextAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdText(this.elementResult.ELEMENT, callback);\n};\n\n\nTextAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n\n  if (this.passed && this.waitForMs) {\n    var message = '';\n    if (this.hasCondition()) {\n      message = 'condition was met';\n    }\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - ' + message + ' in ' + this.elapsedTime + 'ms');\n  }\n};\n\nTextAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n};\n\nmodule.exports = TextAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/api/expect/type.js":"/**\n * Checks if the type (i.e. tag name) of a specified element is of an expected value.\n *\n * ```\n * this.demoTest = function (browser) {\n *   browser.expect.element('#q').to.be.an('input');\n *   browser.expect.element('#q').to.be.an('input', 'Testing if #q is an input');\n *   browser.expect.element('#w').to.be.a('span');\n * };\n * ```\n *\n * @method a\n * @display .a(type)\n * @alias an\n * @since v0.7\n * @param {string} type The expected type\n * @param {string} [message] Optional log message to display in the output. If missing, one is displayed by default.\n * @api expect\n */\nvar util = require('util');\nvar events = require('events');\nvar BaseAssertion = require('./_baseAssertion.js');\n\nfunction TypeAssertion(type, msg) {\n  this.type = type;\n\n  BaseAssertion.call(this);\n\n  this.article = ['a', 'e', 'i', 'o'].indexOf(type.substring(0, 1)) > -1 ? 'an' : 'a';\n  this.customMessage = msg;\n  this.message = msg || 'Expected element <%s> to ' + (this.negate ? 'not be' : 'be') + ' ' + this.article +' ' + type;\n  this.start();\n}\n\nutil.inherits(TypeAssertion, BaseAssertion);\n\nTypeAssertion.prototype.executeCommand = function(callback) {\n  this.protocol.elementIdName(this.elementResult.ELEMENT, callback);\n};\n\nTypeAssertion.prototype.elementFound = function() {\n  if (this.retries > 0 && this.negate) {\n    return;\n  }\n\n  this.passed = this.negate ? (this.resultValue != this.type) : (this.resultValue == this.type);\n  this.expected = this.negate ? 'not be ' + this.article + ' ' + this.type : 'be ' + this.article + ' ' + this.type;\n  this.actual = this.resultValue;\n\n  if (this.passed && this.waitForMs) {\n    this.elapsedTime = this.getElapsedTime();\n    this.messageParts.push(' - condition was met in ' + this.elapsedTime + 'ms');\n  }\n};\n\nTypeAssertion.prototype.elementNotFound = function() {\n  this.passed = false;\n};\n\nmodule.exports = TypeAssertion;\n","/home/travis/build/npmtest/node-npmtest-nightwatch/node_modules/nightwatch/lib/runner/reporters/junit.js":"/**\n * https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd\n * @type {exports}\n */\nvar fs = require('fs');\nvar mkpath = require('mkpath');\nvar path = require('path');\nvar ejs = require('ejs');\nvar util = require('util');\nvar Utils = require('../../util/utils.js');\n\nmodule.exports = new (function() {\n\n  var tmpl = __dirname + '/junit.xml.ejs';\n  var tmplData;\n  var globalResults;\n\n  function loadTemplate(cb) {\n    if (tmplData) {\n      cb(tmplData);\n      return;\n    }\n    fs.readFile(tmpl, function (err, data) {\n      if (err) {\n        throw err;\n      }\n      tmplData = data.toString();\n      cb(tmplData);\n    });\n  }\n\n  function adaptAssertions(module) {\n    Object.keys(module.completed).forEach(function(item) {\n      var testcase = module.completed[item];\n      var assertions = testcase.assertions;\n      for (var i = 0; i < assertions.length; i++) {\n        if (assertions[i].stackTrace) {\n          assertions[i].stackTrace = Utils.stackTraceFilter(assertions[i].stackTrace.split('\\n'));\n        }\n      }\n\n      if (testcase.failed > 0 && testcase.stackTrace) {\n        var stackParts = testcase.stackTrace.split('\\n');\n        var errorMessage = stackParts.shift();\n        testcase.stackTrace = Utils.stackTraceFilter(stackParts);\n        testcase.message = errorMessage;\n      }\n    });\n  }\n\n  function writeReport(moduleKey, data, opts, callback) {\n    var module = globalResults.modules[moduleKey];\n    var pathParts = moduleKey.split(path.sep);\n    var moduleName = pathParts.pop();\n    var className = moduleName;\n    var output_folder = opts.output_folder;\n\n    adaptAssertions(module);\n\n    if (pathParts.length) {\n      output_folder = path.join(output_folder, pathParts.join(path.sep));\n      mkpath.sync(output_folder);\n      className = pathParts.join('.') + '.' + moduleName;\n    }\n\n    var filename = path.join(output_folder, opts.filename_prefix + moduleName + '.xml');\n\n    var rendered = ejs.render(data, {\n      locals: {\n        module     : module,\n        moduleName : moduleName,\n        className  : className,\n        systemerr  : globalResults.errmessages.join('\\n')\n      }\n    });\n\n    fs.writeFile(filename, rendered, function(err) {\n      callback(err);\n      globalResults.errmessages.length = 0;\n    });\n  }\n\n  this.write = function(results, options, callback) {\n    globalResults = results;\n    var keys = Object.keys(results.modules);\n\n    loadTemplate(function createReport(data) {\n      var moduleKey = keys.shift();\n\n      writeReport(moduleKey, data, options, function(err) {\n        if (err || (keys.length === 0)) {\n          callback(err);\n        } else {\n          createReport(data);\n        }\n      });\n    });\n  };\n\n})();\n"}